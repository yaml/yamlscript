<!doctype html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-44C9DS3Q80"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-44C9DS3Q80');</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://yamlscript.org/doc/yes/"><link href="/assets/main.fc9b07030678f58b9d0b.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>YeS Expressions | YAMLScript</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="YeS Expressions"><meta property="og:site_name" content="YAMLScript"><meta property="og:type" content="website"><meta property="og:url" content="https://yamlscript.org/doc/yes/"><meta name="twitter:card" content="summary_large_image"><meta name="description" content="YeS Expressions Lisp has the concept of S-Expressions (aka sexprs), nested parenthesized expressions where the parentheses contain a..."><meta property="og:description" content="YeS Expressions Lisp has the concept of S-Expressions (aka sexprs), nested parenthesized expressions where the parentheses contain a..."><meta name="description" content="YeS Expressions Lisp has the concept of S-Expressions (aka sexprs), nested parenthesized expressions where the parentheses contain a..."><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/"><img src="/images/yamlscript-logo.svg"></a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/doc">Docs</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/about">About</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>YeS Expressions</h1></header><main class="post__content"><p>Lisp has the concept of <a href="https://en.wikipedia.org/wiki/S-expression">S-Expressions</a> (aka <code>sexpr</code>s), nested parenthesized expressions where the parentheses contain a function (usually a symbol bound to a function) followed by its arguments.</p><p>YAMLScript has a concept called &quot;YeS Expressions&quot; (aka <code>ysexpr</code>s) which offer alternate ways to write sexprs in a style that feels more familiar to non-Lisp language expressions.</p><blockquote><p>Note: In general, YAMLScript supports writing code as sexprs, ysexprs or as block mapping pairs. Nested expressions can combine any of those forms. It's up to the programmer to decide which works best for them in any given context.</p></blockquote><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">def</span> var1 <span class="token punctuation">(</span><span class="token function">sqrt</span> <span class="token punctuation">(</span><span class="token keyword">+</span> <span class="token punctuation">(</span><span class="token keyword">*</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>The equivalent code in Python would be:</p><pre class="language-python"><code class="language-python">var1 <span class="token operator">=</span> sqrt<span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span></code></pre><p>In YAMLScript, we could write:</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">var1 =</span><span class="token punctuation">:</span> sqrt((3 * 4) + 5)</code></pre><p>There are 3 notable transformations happening here:</p><ul><li>Functions named by a word can be placed before the opening paren instead of inside it. e.g. <code>a(b c)</code> translates to <code>(a b c)</code>. Note that no whitespace can come between the <code>a</code> and the <code>(</code>.</li><li>Prefix operations can be written infix. e.g. <code>(a + b)</code> translates to <code>(+ a b)</code>. Triplets with an operator (punctuation) symbol in the middle get this treatment.</li><li>Variable assignment (aka symbol binding) can be written using <code>=:</code> YAML mapping pairs. e.g. <code>a =: b + c</code> translates to <code>(def a (+ b c))</code>. Note that whitespace is required on both sides of the <code>=:</code>.</li></ul><p>We'll discuss the a few more details of each of these YeS expression transforms below.</p><blockquote><p>Note: YAMLScript has many other transformations that strive to make YS code clean and easy to read and understand. YeS expression transformations are among the most commonly used.</p></blockquote><h2>Prefix Call Notation</h2><p>The most common way to call a function in non-Lisp programming languages is <code>a()</code>, <code>a(b)</code>, <code>a(b c)</code> etc where <code>a</code> is the name of a function and <code>b</code> and <code>c</code> are arguments that the function is called with. Lisp languages use the same format but put the <code>a</code> inside the parens.</p><p>YAMLScript lets you do either. Again the <code>a</code> must be next to the <code>(</code>. IOW, <code>a (b c)</code> is not the same as <code>a(b c)</code>!</p><p>Another way to write the function call <code>(a b c)</code> in YAMLScript is to use it in a mapping pair context:</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">a</span><span class="token punctuation">:</span> b c<br><span class="token comment"># Or sometimes:</span><br><span class="token key atrule">a b</span><span class="token punctuation">:</span> c</code></pre><h2>Infix Operator Notation</h2><p>Lisps write binary operator expressions like:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">+</span> a <span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment">;; a + 5</span><br><span class="token punctuation">(</span><span class="token keyword">></span> a <span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment">;; a > 5</span></code></pre><p>That makes sense because <code>+</code> and <code>&gt;</code> are just ordinary Lisp symbols bound to addition and greater-than functions.</p><p>One advantage of this prefix notation is that this operations can take more than 2 arguments:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">+</span> a b c d<span class="token punctuation">)</span>  <span class="token comment">;; a + b + c + d</span><br><span class="token punctuation">(</span><span class="token keyword">></span> a b c d<span class="token punctuation">)</span>  <span class="token comment">;; a > b > c > d  or  (a > b) &amp;&amp; (b > c) &amp;&amp; (c > d)</span></code></pre><p>YeS expressions allow you to do these things:</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">=></span><span class="token punctuation">:</span> a + b        <span class="token comment"># (+ a b)</span><br><span class="token key atrule">=></span><span class="token punctuation">:</span> a + b + c    <span class="token comment"># (+ a b c)</span><br><span class="token key atrule">=></span><span class="token punctuation">:</span> a + b <span class="token punctuation">></span> c    <span class="token comment"># ERROR - no operator mixing; no implicit precedence in YS</span><br><span class="token key atrule">=></span><span class="token punctuation">:</span> (a + c) <span class="token punctuation">></span> c  <span class="token comment"># (> (+ a b) c) - Fine with parens</span></code></pre><p>Note that we didn't need any parentheses around <code>a + b</code>. When a YAML plain scalar with an operator triplet (or multiple forms separated by the same operator) the parentheses are implied and thus optional. The parentheses are implied in a few other contexts as well like:</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">if a > b</span><span class="token punctuation">:</span> c d<br><span class="token comment"># Equivalent to:</span><br><span class="token key atrule">if (a > b)</span><span class="token punctuation">:</span> c d</code></pre><h3>When Operators are Arguments</h3><p>Every once in a while you might want to pass an operator as an argument to a function call triplet like <code>(apply + numbers)</code> and YAMLScript would wrongly translate that to <code>(+ apply numbers)</code>.</p><p>This is easily avoided by using the prefix call notation described above: <code>apply(+ numbers)</code>. It is also avoided when using the block mapping pair form:</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">apply +</span><span class="token punctuation">:</span> numbers</code></pre><p>Also note that the operator switching only applies to triplet forms, so expressions like <code>(a +)</code> and <code>(a + b c)</code> are never affected.</p><h2>Assignment (Symbol Binding) Expressions</h2><p>In many programming languages, like Python for instance, it's common to see things like:</p><pre class="language-python"><code class="language-python">a <span class="token operator">=</span> b<span class="token punctuation">(</span>c<span class="token punctuation">)</span></code></pre><p>where the evaluation result of the function <code>b(c)</code> is assigned (aka bound) to the variable (or symbol) <code>a</code>.</p><p>In Clojure you would use a <code>def</code> form:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">def</span> a <span class="token punctuation">(</span><span class="token function">b</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Unless it was inside a function scope, in which case you would use a <code>let</code> form:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> f <span class="token punctuation">[</span>b c<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a <span class="token punctuation">(</span><span class="token function">b</span> c<span class="token punctuation">)</span><span class="token punctuation">]</span><br>    <span class="token punctuation">(</span><span class="token function">d</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>In YAMLScript you can write them both the same way:</p><pre><code>a =: b(c)
# and
defn f(b c):
  a =: b(c)
  d: a
</code></pre><p>In Clojure you can define multiple <code>let</code> bindings in a single <code>let</code> form.</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> f <span class="token punctuation">[</span>a<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>b <span class="token punctuation">(</span><span class="token keyword">inc</span> a<span class="token punctuation">)</span><br>        c <span class="token punctuation">(</span><span class="token keyword">dec</span> a<span class="token punctuation">)</span><span class="token punctuation">]</span><br>    <span class="token punctuation">(</span><span class="token function">d</span> b c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>In YAMLScript you can do the same thing:</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn f(a)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">b =</span><span class="token punctuation">:</span> inc(a)<br>  <span class="token key atrule">c =</span><span class="token punctuation">:</span> dec(a)<br>  <span class="token key atrule">d</span><span class="token punctuation">:</span> b c</code></pre><p>The YAMLScript compiler joins consecutive <code>=:</code> pairs into a single <code>let</code> form, resulting in the same Clojure code as the example above.</p><p>In Clojure you can bind multiple symbols at once using destructuring:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> f <span class="token punctuation">[</span><span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>a b<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token function">c</span><span class="token punctuation">)</span><span class="token punctuation">]</span><br>    <span class="token punctuation">(</span><span class="token function">g</span> a b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>This binds <code>a</code> and <code>b</code> to the first two elements of the sequence returned by calling <code>c</code>.</p><p>Note that this works for a <code>let</code> expression but not for a <code>def</code> expression:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">def</span> <span class="token punctuation">[</span>a b<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token function">c</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">;; Syntax error</span></code></pre><p>In YAMLScript it works fine:</p><pre class="language-yaml"><code class="language-yaml"><span class="token punctuation">-</span><span class="token punctuation">[</span>a b<span class="token punctuation">]</span> =<span class="token punctuation">:</span> c()</code></pre><h2>Conclusion</h2><p>YeS Expressions are a key way to help you write YAMLScript code that looks more like the code you're used to writing in non-Lisp languages, while still retaining the full power of Lisp (Clojure). It's your choice how you want your code to look, and YAMLScript gives you many options for that.</p><p>No matter what your valid YAMLScript code looks like, it always compiles to valid Lisp, which makes it extremely reliable to reason about.</p><p>The power of Lisp is that its input expressions almost completely match the internal evaluation forms that it compiles to. It's very obvious what's going on under the hood, because it's the same as what you see on the outside. This is called <a href="https://wikipedia.org/wiki/Homoiconicity">homoiconicity</a>.</p><p>In dynamic languages like JavaScript, Python, Ruby or Perl you don't really get to see what your code turns into before it is evaluated.</p><p>YAMLScript tries to offer a very flexible set of coding styles that always compile to Lisp's extremely robust evaluation form.</p></main><aside class="post__aside"><nav class="post__pagination"></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a href="https://github.com/yaml/yamlscript" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul><p class="footer__attribution">Powered by <a href="https://www.11ty.dev" target="_blank" rel="noopener">Eleventy</a>. Theme: <a href="https://github.com/yinkakun/eleventy-duo" target="_blank" rel="noopener noreferrer">Eleventy Duo</a>.</p></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>