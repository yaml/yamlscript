<!doctype html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-44C9DS3Q80"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-44C9DS3Q80');</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://yamlscript.org/doc/syntax/"><link href="/assets/main.769d3d1b7edc71568d89.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>YAMLScript Syntax | YAMLScript</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="YAMLScript Syntax"><meta property="og:site_name" content="YAMLScript"><meta property="og:type" content="website"><meta property="og:url" content="https://yamlscript.org/doc/syntax/"><meta name="twitter:card" content="summary_large_image"><meta name="description" content="YAMLScript Syntax The ys YAMLScript interpreter command runs YAMLScript programs by compiling them to Clojure code and evaluating that..."><meta property="og:description" content="YAMLScript Syntax The ys YAMLScript interpreter command runs YAMLScript programs by compiling them to Clojure code and evaluating that..."><meta name="description" content="YAMLScript Syntax The ys YAMLScript interpreter command runs YAMLScript programs by compiling them to Clojure code and evaluating that..."><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/"><img src="/images/yamlscript-logo.svg"></a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/doc">Docs</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/about">About</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>YAMLScript Syntax</h1></header><main class="post__content"><p>The <code>ys</code> YAMLScript interpreter command runs YAMLScript programs by compiling them to Clojure code and evaluating that Clojure code.</p><p>To fully understand YAMLScript you need to know:</p><ul><li><a href="/doc/yaml">How YAML works</a></li><li><a href="/doc/clojure">How Clojure works</a></li></ul><p>This document will show you the basics of YAMLScript syntax and how they translate to Clojure code.</p><blockquote><p>Note: You can play with all the concepts here by putting example code into a file like <code>example.ys</code> and running <code>ys -c example.ys</code> which will print the Clojure code that the YAMLScript code compiles to.</p></blockquote><h2>First Steps</h2><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br>(say "Hello<span class="token punctuation">,</span> world<span class="token tag">!</span>")</code></pre><p>This is a simple YAMLScript program that prints &quot;Hello, world!&quot;.</p><p>An interesting point about YAMLScript is that is always valid YAML, and the YAMLScript compiler (<code>ys -c</code>) is really just a fancy YAML loader. Almost all YAML files are valid YAMLScript and the compiler turns them into the expected data structure.</p><p>This is where the <code>!yamlscript/v0</code> tag comes in. It tells the YS compiler to &quot;load&quot; the YAML into a YAMLScript AST which prints naturally to Clojure code.</p><p>The point is that every YAMLScript program needs to start with the <code>!yamlscript/v0</code> tag, or else it just compiles to a regular data structure.</p><p>The second line is a YAMLScript function call that happens to be a Clojure function call.</p><p>Let's play around with that function call syntax a bit.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br>say("Hello<span class="token punctuation">,</span> world<span class="token tag">!</span>")</code></pre><p>This compiles to the same Clojure code as the first example. We moved the <code>say</code> function name outside the parentheses. In YAMLScript this is called a <a href="/doc/yes">YeS Expression</a>.</p><p>Note that from a YAML perspective, the entire YAML document is a single scalar value.</p><p>YAMLScript code uses YAML scalars and YAML block mappings for code. Generally a mix of the two where the top (file level) structure is a nested mapping and the leaf values are scalar expressions.</p><p>Let's change our code to use a mapping instead:</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello, world!"</span></code></pre><p>Again, this compiles to the same Clojure code as the first two examples.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">'Hello, world!'</span></code></pre><p>This is the same as the previous example, but the string is single-quoted. Single quotes aren't used for strings in Clojure, but they are in YAML.</p><p>In YAMLScript, like Perl and Ruby, double quoted strings support variable interpolation and character escaping while single quoted strings do not.</p><p>Let's get a bit fancier with our string:</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">name =</span><span class="token punctuation">:</span> <span class="token string">'world'</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello, $name!"</span></code></pre><p>That's a variable assignment and a string interpolation.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">name =</span><span class="token punctuation">:</span> <span class="token string">'world'</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> str('Hello<span class="token punctuation">,</span> '<span class="token punctuation">,</span> name<span class="token punctuation">,</span> '<span class="token tag">!')</span></code></pre><p>Clojure as a <code>str</code> function that concatenates strings together.</p><p>See the commas between the <code>str</code> call arguments? In Clojure, commas are whitespace and are completely ignored. This is also true in YAMLScript!</p><p>In general Clojure and YAMLScript only use commas in places where the code is hard to follow without them.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">name =</span><span class="token punctuation">:</span> <span class="token string">'world'</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token punctuation">-</span>'Hello<span class="token punctuation">,</span> ' + name + '<span class="token tag">!'</span></code></pre><p>Here we are doing something that you don't see in Clojure. We're using <code>+</code> to concatenate strings.</p><p>When YAMLScript operators are infix they compile to polymorphic functions that work on types of data other than numbers.</p><p>But what about the <code>-</code> in front of the string?</p><p>Without the <code>-</code> this would be invalid YAML because YAML does not allow text on the same line after a quoted string.</p><p>The <code>-</code> causes YAML to see everything after it as the scalar value: <code>-'Hello, ' + name + '!'</code>. This is like an escape character for situations where you want to write an expression but the first character is a syntax character in YAML. The <code>-</code> is removed and the rest of the scalar is compiled as an expression.</p><h2>Basic Function Definition</h2><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn greet(name)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello, $name!"</span><br><br><span class="token key atrule">greet</span><span class="token punctuation">:</span> <span class="token string">'Bob'</span></code></pre><p>In Clojure we'd write this as:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> greet <span class="token punctuation">[</span>name<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token function">say</span> <span class="token string">"Hello, "</span> name <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token punctuation">(</span><span class="token function">greet</span> <span class="token string">"Bob"</span><span class="token punctuation">)</span></code></pre><p>It's pretty easy to see what's going on here.</p><p>Note how we use indentation nesting where Clojure uses parentheses. That's just the natural way to do things in YAML. Most of YAMLScript's syntax design is about making code look natural in YAML. It works out surprisingly well!</p><h2>Variable Assignment (def and let)</h2><p>In the remaining examples we'll assume the <code>!yamlscript/v0</code> tag is present.</p><blockquote><p>What we are calling variable assignment is known as symbol binding in Clojure. Clojure differentiates between symbols and variables but the distinction is not so important for YAMLScript.</p></blockquote><p>Assignments are done by using <code>name =: expression</code>.</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">foo =</span><span class="token punctuation">:</span> bar() + 17</code></pre><p>It looks like <code>=:</code> is some syntax added to YAML, but it's actually just a plain scalar value that ends with a space and an equals sign!</p><p>These would work just as well:</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">foo   =</span>   <span class="token punctuation">:</span><br>  bar()<br>  + 17<br><br><span class="token punctuation">?</span> foo<br>  <span class="token key atrule">=</span><br><span class="token punctuation">:</span> bar()<br>  + 17</code></pre><blockquote><p>The second form above uses YAML's rarely seen explicit key syntax. It can be useful sometimes in YAMLScript when you need spread the key portion of a key/value mapping pair over multiple lines. Without it mapping keys are required by YAML to be a single line. The 'value' side can always be multiline and can start on the next line too. This is a very common pattern in YAMLScript to make code more readable.</p></blockquote><p>Assignment statements written at the file level compile to <code>def</code> forms in Clojure, while those written inside a function compile to <code>let</code> forms.</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn f1()</span><span class="token punctuation">:</span><br>  <span class="token key atrule">a =</span><span class="token punctuation">:</span> this()<br>  <span class="token key atrule">b =</span><span class="token punctuation">:</span> that()<br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> a + b</code></pre><p>This compiles to:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> f1 <span class="token punctuation">[</span><span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>a <span class="token punctuation">(</span><span class="token function">this</span><span class="token punctuation">)</span><br>        b <span class="token punctuation">(</span><span class="token function">that</span><span class="token punctuation">)</span><span class="token punctuation">]</span><br>    <span class="token punctuation">(</span><span class="token keyword">+</span> a b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Notice how multiple consecutive assignments are compiled to a single <code>let</code> form. This is the preferred Clojure style and YAMLScript tries to compile to idiomatic Clojure code whenever possible.</p><p>What's with the <code>=&gt;</code>? The special token <code>=&gt;</code> can be used as a placeholder key for when you want to use a single expression but being inside a mapping requires you use a key/value pair. The <code>=&gt;</code> is removed during compilation and the expression is left as the value.</p><h2>Destructuring Assignment</h2><p>Many modern languages have destructuring assignment, where the LHS of an assignment looks like a data structure instead of a single variable. This quasi-data-structure is a collection of variables that are assigned values from the RHS of the assignment.</p><p>Clojure and YAMLScript have destructuring assignment support for both sequences and mappings.</p><pre class="language-yaml"><code class="language-yaml"><span class="token punctuation">-</span><span class="token punctuation">[</span>a b c<span class="token punctuation">]</span> =<span class="token punctuation">:</span> foo()<br><span class="token punctuation">-</span><span class="token punctuation">{</span>d <span class="token punctuation">:</span>d e <span class="token punctuation">:</span>e<span class="token punctuation">}</span> =<span class="token punctuation">:</span> bar()</code></pre><p>This would assign the first three values of the sequence returned by <code>foo</code> to <code>a</code>, <code>b</code>, and <code>c</code>, and the values of the <code>:d</code> and <code>:e</code> keys of the mapping to <code>d</code> and <code>e</code>.</p><p>This can also be done in function arguments:</p><pre class="language-yaml"><code class="language-yaml">defn f(a <span class="token punctuation">[</span>b c<span class="token punctuation">]</span> d)<span class="token punctuation">:</span><br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> (a + (b * c)) / d<br><span class="token key atrule">f</span><span class="token punctuation">:</span> 2 <span class="token punctuation">[</span>3 4<span class="token punctuation">]</span> 7  <span class="token comment"># => 2</span></code></pre><p>Here you would call <code>f</code> with a single sequence argument and the first three values of that sequence would be assigned to <code>a</code>, <code>b</code>, and <code>c</code> respectively.</p><p>For some reason Clojure does not support destructuring assignment in <code>def</code> forms but YAMLScript makes it work just fine.</p><h3>Function Arguments</h3><p>Like Clojure, all YAMLScript functions must be defined with the number of arguments they take. This is know as the function's arity. Functions can be written to take different specific numbers of arguments, where each arity has its own definition body. Functions can also be written to take a variable number of arguments.</p><p>Multi-arity functions are called with the same name but the number of arguments used determines which body is evaluated.</p><p>Note that unlike some other languages with multi-arity functions, the type of the arguments is not used to determine which body to evaluate.</p><p>For example to define a function that takes two or more arguments:</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn foo(a b *more)</span><span class="token punctuation">:</span> <span class="token punctuation">...</span></code></pre><p>To define a function that can take 0, 1 or 3+ arguments:</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn foo</span><span class="token punctuation">:</span><br>  <span class="token key atrule">()</span><span class="token punctuation">:</span> <span class="token punctuation">...</span><br>  <span class="token key atrule">(a)</span><span class="token punctuation">:</span> <span class="token punctuation">...</span><br>  <span class="token key atrule">(a b c *more)</span><span class="token punctuation">:</span> <span class="token punctuation">...</span></code></pre><p>It would be an error to call the above function with 2 arguments.</p><h2>Default Values</h2><p>Clojure does not support default values for function arguments but YAMLScript does.</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn foo(a b=10 c='horse')</span><span class="token punctuation">:</span> <span class="token punctuation">...</span></code></pre><h2>Work in Progress</h2><p>This document is a work in progress. More content will be added soon.</p><h2>See Also</h2><ul><li><a href="/doc/modes">YAMLScript Modes</a> - Understanding code mode vs data mode</li><li><a href="/doc/yes">YeS Expressions</a></li></ul></main><aside class="post__aside"><nav class="post__pagination"></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a href="https://github.com/yaml/yamlscript" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul><p class="footer__attribution">Powered by <a href="https://www.11ty.dev" target="_blank" rel="noopener">Eleventy</a>. Theme: <a href="https://github.com/yinkakun/eleventy-duo" target="_blank" rel="noopener noreferrer">Eleventy Duo</a>.</p></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>