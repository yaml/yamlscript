<!doctype html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-44C9DS3Q80"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-44C9DS3Q80');</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://yamlscript.org/doc/clj-to-ys/"><link href="/assets/main.769d3d1b7edc71568d89.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>Learning YAMLScript from Clojure | YAMLScript</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="Learning YAMLScript from Clojure"><meta property="og:site_name" content="YAMLScript"><meta property="og:type" content="website"><meta property="og:url" content="https://yamlscript.org/doc/clj-to-ys/"><meta name="twitter:card" content="summary_large_image"><meta name="description" content="Learning YAMLScript from Clojure YAMLScript works by translating code written in YAMLScript to Clojure code, which is then evaluated. A good..."><meta property="og:description" content="Learning YAMLScript from Clojure YAMLScript works by translating code written in YAMLScript to Clojure code, which is then evaluated. A good..."><meta name="description" content="Learning YAMLScript from Clojure YAMLScript works by translating code written in YAMLScript to Clojure code, which is then evaluated. A good..."><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/"><img src="/images/yamlscript-logo.svg"></a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/doc">Docs</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/about">About</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>Learning YAMLScript from Clojure</h1></header><main class="post__content"><p>YAMLScript works by translating code written in YAMLScript to Clojure code, which is then evaluated.</p><p>A good way to learn YAMLScript is to convert existing Clojure programs to YAMLScript.</p><p>This tutorial will guide you through the process of converting various Clojure programs to idiomatic YAMLScript a step at a time.</p><p>For each Clojure program, we will:</p><ul><li>Start with a working Clojure program</li><li>Refactor some parts of the program to YAMLScript</li><li>Repeat until YAMLScript is idiomatic</li><li>Have working YAMLScript code every step of the way</li></ul><p>If you don't know Clojure, that's okay. We're starting simple and you can learn 2 languages for the price of one.</p><p>Let's get started!</p><h2>Hello World</h2><p>Since we are obligated as programmers to start with a &quot;Hello, World!&quot; program, let's look at the simplest hello-world in Clojure:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">println</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">)</span></code></pre><p>It turns out the this program is already valid YAMLScript!</p><pre class="language-sh"><code class="language-sh">$ ys <span class="token parameter variable">-e</span> <span class="token string">'(println "Hello, World!")'</span><br>Hello, World<span class="token operator">!</span></code></pre><p>Let's save it to a file called <code>program.ys</code> and run it.</p><pre class="language-yaml"><code class="language-yaml">(println "Hello<span class="token punctuation">,</span> World<span class="token tag">!</span>")</code></pre><pre class="language-sh"><code class="language-sh">$ ys program.ys<br>$</code></pre><p>Dang. Nothing happened.</p><p>Let's compile it to Clojure to see what's going on.</p><pre class="language-sh"><code class="language-sh">$ ys <span class="token parameter variable">-c</span> program.ys<br><span class="token string">"(println <span class="token entity" title="\&quot;">\"</span>Hello, World!<span class="token entity" title="\&quot;">\"</span>)"</span></code></pre><p>Ah! It compiled to a string, because we forgot to add <code>!yamlscript/v0</code> to the top of the file. All YAML files are valid YAMLScript files. They won't evaluate any code unless you explicitly tell them to.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br>(println "Hello<span class="token punctuation">,</span> World<span class="token tag">!</span>")</code></pre><pre class="language-sh"><code class="language-sh">$ ys program.ys<br>Hello, World<span class="token operator">!</span></code></pre><p>There we go!</p><p>Let's make it idiomatic now.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">'Hello, World!'</span></code></pre><p>Look mom, no parentheses!</p><p>We turned the YAML scalar into a single pair mapping, and we changed the double-quoted string to a single-quoted string.</p><p>Single-quoted strings are preferred in YAMLScript unless you need interpolation or special escaped characters.</p><p>We also changed the <code>println</code> function to the <code>say</code> function, because who has time to type <code>println</code> when you just want to <code>say</code> something?!?!</p><p>Let's compile it back to Clojure to be honest with ourselves.</p><pre class="language-sh"><code class="language-sh">$ ys <span class="token parameter variable">-c</span> program.ys<br><span class="token punctuation">(</span>say <span class="token string">"Hello, World!"</span><span class="token punctuation">)</span></code></pre><p>We got our Clojure parentheses and double-quoted string back. Clojure doesn't use single quotes for strings.</p><p>We still have <code>say</code> instead of <code>println</code>, but that's okay because <code>ys -c</code> compiles to Clojure code intended to be run by a YAMLScript runtime, and <code>say</code> is part of the YAMLScript standard library.</p><h2>Hello 2.0</h2><p>Let's make our little program a little more interesting.</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> hello<br>  <span class="token punctuation">(</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">println</span> <span class="token punctuation">(</span><span class="token keyword">str</span> <span class="token string">"Hello, "</span> name <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>  <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token function">hello</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token function">hello</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token function">hello</span> <span class="token string">"YAMLScript"</span><span class="token punctuation">)</span></code></pre><p>We've defined a function <code>hello</code> that takes an optional <code>name</code> argument. If <code>name</code> is not provided, it defaults to <code>&quot;World&quot;</code>.</p><p>Let's convert this to YAMLScript, but change as little as possible.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">=></span><span class="token punctuation">:</span> <span class="token tag">!clj</span> <span class="token punctuation">|</span><span class="token scalar string"><br>  (defn hello<br>    ([name] (println (str "Hello, " name "!")))<br>    ([] (hello "World")))<br>  (hello)<br>  (hello "YAMLScript")</span></code></pre><p>Hmm. We added 2 lines to the top and then indented the Clojure code. Does that work?</p><pre class="language-sh"><code class="language-sh">$ ys program.ys<br>Hello, World<span class="token operator">!</span><br>Hello, YAMLScript<span class="token operator">!</span></code></pre><p>Apparently it does!</p><p>We already know about the first line. The <code>=&gt;</code> is a special key in YAMLScript, when you need to write a YAML key/value pair, but you only have a value. The compiler simply removes the <code>=&gt;</code> and uses the value as the expression.</p><p>What did here is keep the entire Clojure code string intact using a YAML literal scalar (think heredocs) and then use the <code>!clj</code> tag to tell the YAMLScript compiler to treat the string as Clojure code.</p><p>The <code>!clj</code> tag is a way to write Clojure things that YAMLScript does not yet support. But it can also be a good first step to converting Clojure code to YAMLScript.</p><p>Let's keep going by leaving the function defn alone but playing with the function calls.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">=></span><span class="token punctuation">:</span> <span class="token tag">!clj</span> <span class="token punctuation">|</span><span class="token scalar string"><br>  (defn hello<br>    ([name] (println (str "Hello, " name "!")))<br>    ([] (hello "World")))</span><br><span class="token key atrule">hello</span><span class="token punctuation">:</span><br><span class="token key atrule">hello</span><span class="token punctuation">:</span> <span class="token string">'YAMLScript'</span></code></pre><p>We made the 2 calls to <code>hello</code> into YAML mapping pairs. The first one has no value, and that's valid in YAMLScript when a function has no arguments.</p><p>Now let's convert the function defn to YAMLScript.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">defn hello</span><span class="token punctuation">:</span><br> <span class="token key atrule">(name)</span><span class="token punctuation">:</span> (println (str "Hello<span class="token punctuation">,</span> " name "<span class="token tag">!</span>"))<br> <span class="token key atrule">()</span><span class="token punctuation">:</span> (hello "World")<br><span class="token key atrule">hello</span><span class="token punctuation">:</span><br><span class="token key atrule">hello</span><span class="token punctuation">:</span> <span class="token string">'YAMLScript'</span></code></pre><p>That's how you write a multi-arity function in YAMLScript. It's advanced stuff and you already learned it during hello-world! Take a moment! You deserve it!</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">defn hello(name='world')</span><span class="token punctuation">:</span><br>  (println (str "Hello<span class="token punctuation">,</span> " name "<span class="token tag">!</span>"))<br><span class="token key atrule">hello</span><span class="token punctuation">:</span><br><span class="token key atrule">hello</span><span class="token punctuation">:</span> <span class="token string">'YAMLScript'</span></code></pre><p>Hey! What happened to our multi-arity accomplishment? We don't need it here in YAMLScript, because YAMLScript has support for default function arguments.</p><p>Let's finish up with a little interpolation.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">defn hello(name='world')</span><span class="token punctuation">:</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello, $name!"</span><br><span class="token key atrule">hello</span><span class="token punctuation">:</span><br><span class="token key atrule">hello</span><span class="token punctuation">:</span> <span class="token string">'YAMLScript'</span></code></pre><p>That's come idiomatic YAMLScript if I've ever seen it!</p><h2>FizzBuzz</h2><p>Let's continue our journey of refactoring cliche coding conundrums with the classic <a href="https://wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a>.</p><p>Here's a working Clojure implementation I found at <a href="https://rosettacode.org/wiki/FizzBuzz#Clojure">Rosetta Code</a>.</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> fizzbuzz <span class="token punctuation">[</span>start finish<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">map</span> <span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token punctuation">[</span>n<span class="token punctuation">]</span><br>         <span class="token punctuation">(</span><span class="token keyword">cond</span><br>           <span class="token punctuation">(</span><span class="token keyword">zero?</span> <span class="token punctuation">(</span><span class="token function">mod</span> n <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">"FizzBuzz"</span><br>           <span class="token punctuation">(</span><span class="token keyword">zero?</span> <span class="token punctuation">(</span><span class="token function">mod</span> n <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">"Fizz"</span><br>           <span class="token punctuation">(</span><span class="token keyword">zero?</span> <span class="token punctuation">(</span><span class="token function">mod</span> n <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">"Buzz"</span><br>           <span class="token symbol">:else</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><br>    <span class="token punctuation">(</span><span class="token keyword">range</span> start finish<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token punctuation">(</span><span class="token keyword">doseq</span> <span class="token punctuation">[</span>x <span class="token punctuation">(</span><span class="token function">fizzbuzz</span> <span class="token number">1</span> <span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">println</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>We'll skip the <code>!clj</code> step this time and start by making this a top level YAML mapping.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><br><span class="token key atrule">defn fizzbuzz(start finish)</span><span class="token punctuation">:</span><br>  (map (fn <span class="token punctuation">[</span>n<span class="token punctuation">]</span><br>         (cond<br>           (zero<span class="token punctuation">?</span> (mod n 15)) "FizzBuzz"<br>           (zero<span class="token punctuation">?</span> (mod n 3)) "Fizz"<br>           (zero<span class="token punctuation">?</span> (mod n 5)) "Buzz"<br>           <span class="token punctuation">:</span>else n))<br>    (range start finish))<br><br>doseq <span class="token punctuation">[</span>x (fizzbuzz 1 101)<span class="token punctuation">]</span><span class="token punctuation">:</span><br>  (println x)</code></pre><p>It works! Trust me! Don't do that! Run it yourself! But it works! Trust me!</p><p>All we did was turn the top level expressions into YAML mapping pairs, by removing the outer parentheses and adding a colon in the middle.</p><p>We also changed the defn args to use parens instead of square brackets.</p><p>Let's make more expressions into pairs now.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><br><span class="token key atrule">defn fizzbuzz(start finish)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">map</span><span class="token punctuation">:</span><br>    <span class="token key atrule">fn(n)</span><span class="token punctuation">:</span><br>      <span class="token key atrule">cond</span><span class="token punctuation">:</span><br>        <span class="token key atrule">(zero? (mod n 15))</span><span class="token punctuation">:</span> <span class="token string">"FizzBuzz"</span><br>        <span class="token key atrule">(zero? (mod n 3))</span><span class="token punctuation">:</span> <span class="token string">"Fizz"</span><br>        <span class="token key atrule">(zero? (mod n 5))</span><span class="token punctuation">:</span> <span class="token string">"Buzz"</span><br>        <span class="token key atrule">else</span><span class="token punctuation">:</span> n<br>    <span class="token key atrule">range</span><span class="token punctuation">:</span> start finish<br><br>doseq <span class="token punctuation">[</span>x (fizzbuzz 1 101)<span class="token punctuation">]</span><span class="token punctuation">:</span><br>  <span class="token key atrule">println</span><span class="token punctuation">:</span> x</code></pre><p>We also changed <code>:else</code> to <code>else</code> because YAMLScript likes it that way.</p><p>Does it work? You betcha! Are we done? Heck no!</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><br><span class="token key atrule">defn fizzbuzz(start finish)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">map _ (start .. finish)</span><span class="token punctuation">:</span><br>    <span class="token key atrule">fn(n)</span><span class="token punctuation">:</span><br>      <span class="token key atrule">cond</span><span class="token punctuation">:</span><br>        <span class="token key atrule">(zero? (mod n 15))</span><span class="token punctuation">:</span> <span class="token string">'FizzBuzz'</span><br>        <span class="token key atrule">(zero? (mod n 3))</span><span class="token punctuation">:</span> <span class="token string">'Fizz'</span><br>        <span class="token key atrule">(zero? (mod n 5))</span><span class="token punctuation">:</span> <span class="token string">'Buzz'</span><br>        <span class="token key atrule">else</span><span class="token punctuation">:</span> n<br><br>doseq <span class="token punctuation">[</span>x (fizzbuzz 1 100)<span class="token punctuation">]</span><span class="token punctuation">:</span><br>  <span class="token key atrule">println</span><span class="token punctuation">:</span> x</code></pre><p>Ok, hmm. We moved the range up to the top of the map call but put a <code>_</code> right before it. And it's not a range call anymore, it's some operator expression.</p><p><code>..</code> is the <code>rng</code> operator in YAMLScript and the end is inclusive so we didn't need to say 101 when we meant 100.</p><p>The <code>_</code> is a placeholder for the pair value to go. In Clojure, many functions take a function as the first argument. If we need to actually define a big function there it would be nicer if we could do it last. In these cases <code>_</code> is our friend.</p><p>Double quotes to single. What's next?</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><br><span class="token key atrule">defn fizzbuzz(start finish)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">map _ (start .. finish)</span><span class="token punctuation">:</span><br>    <span class="token key atrule">fn(n)</span><span class="token punctuation">:</span><br>      <span class="token key atrule">cond</span><span class="token punctuation">:</span><br>        <span class="token key atrule">(mod n 15).!</span><span class="token punctuation">:</span> <span class="token string">'FizzBuzz'</span><br>        <span class="token key atrule">(mod n 3).!</span><span class="token punctuation">:</span>  <span class="token string">'Fizz'</span><br>        <span class="token key atrule">(mod n 5).!</span><span class="token punctuation">:</span>  <span class="token string">'Buzz'</span><br>        <span class="token key atrule">else</span><span class="token punctuation">:</span>         n<br><br><span class="token key atrule">doseq x (fizzbuzz 1 100)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span> x</code></pre><p>We replaced the <code>zero?</code> calls with a <code>.!</code> (short for <code>.falsey?()</code>) call. We also removed the square brackets from the <code>doseq</code> call because YAMLScript is cool like that.</p><p>Getting better...</p><p>In YAMLScript, if you define a function called <code>main</code> it will be called automatically when the program is run.</p><p>Let's try that.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><br><span class="token key atrule">defn main(start=1 finish=100)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">each x (start .. finish)</span><span class="token punctuation">:</span><br>    <span class="token key atrule">say</span><span class="token punctuation">:</span><br>      <span class="token key atrule">fizzbuzz</span><span class="token punctuation">:</span> x<br><br><span class="token key atrule">defn- fizzbuzz(n)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">cond</span><span class="token punctuation">:</span><br>    <span class="token key atrule">(mod n 15).!</span><span class="token punctuation">:</span> <span class="token string">'FizzBuzz'</span><br>    <span class="token key atrule">(mod n 3).!</span><span class="token punctuation">:</span>  <span class="token string">'Fizz'</span><br>    <span class="token key atrule">(mod n 5).!</span><span class="token punctuation">:</span>  <span class="token string">'Buzz'</span><br>    <span class="token key atrule">else</span><span class="token punctuation">:</span>         n</code></pre><p>We moved the heavy lifting code into a private function called <code>fizzbuzz</code> and simply call it from the <code>main</code> function for every number in our range.</p><p>We also made it so we can pass in the start and finish values as arguments:</p><pre class="language-sh"><code class="language-sh">$ ys program.ys <span class="token number">35</span> <span class="token number">42</span><br>Buzz<br>Fizz<br><span class="token number">37</span><br><span class="token number">38</span><br>Fizz<br>Buzz<br><span class="token number">41</span><br>Fizz</code></pre><p>Pretty sweet!</p><p>Let's tidy up this code a bit more, and come down from our fizzy buzz.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><br><span class="token key atrule">defn main(start=1 finish=100)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">each x (start .. finish)</span><span class="token punctuation">:</span> x.fizzbuzz().say()<br><br><span class="token key atrule">defn- fizzbuzz(n)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">cond</span><span class="token punctuation">:</span><br>    <span class="token key atrule">(n % 15).!</span><span class="token punctuation">:</span> <span class="token string">'FizzBuzz'</span><br>    <span class="token key atrule">(n % 3).!</span><span class="token punctuation">:</span>  <span class="token string">'Fizz'</span><br>    <span class="token key atrule">(n % 5).!</span><span class="token punctuation">:</span>  <span class="token string">'Buzz'</span><br>    <span class="token key atrule">else</span><span class="token punctuation">:</span>       n</code></pre><p>We made the body of <code>main</code> into a single pair by chaining the <code>x</code>, <code>fizzbuzz()</code>, and <code>say()</code> together. I wouldn't say this is idiomatic YAMLScript, it's a little less readable imho, but sometimes we got to show off a little.</p><p>This is probably how I'd write that part:</p><pre class="language-yaml"><code class="language-yaml">  <span class="token key atrule">each x (start .. finish)</span><span class="token punctuation">:</span><br>    <span class="token key atrule">say</span><span class="token punctuation">:</span> fizzbuzz(x)</code></pre><p>See how <code>fizzbuzz</code> comes before the paren, not inside it? We call that a <a href="/doc/yes">YeS expression</a> and it's definitely idiomatic!</p><p>Finally we replaced the <code>mod</code> calls with the <code>%</code> operator. To be fair, <code>%</code> is the <code>rem</code> operator and <code>%%</code> is the <code>mod</code> operator in but with positive numbers they do the same thing.</p><p>I'm fizzed out! Let's move on!</p><h2>To Be Continued...</h2><p>We'll continue this journey soon. I promise.</p><p>I have lots more Idiomatic YAMLScript to show you.</p><p>Stay tuned!</p></main><aside class="post__aside"><nav class="post__pagination"></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a href="https://github.com/yaml/yamlscript" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul><p class="footer__attribution">Powered by <a href="https://www.11ty.dev" target="_blank" rel="noopener">Eleventy</a>. Theme: <a href="https://github.com/yinkakun/eleventy-duo" target="_blank" rel="noopener noreferrer">Eleventy Duo</a>.</p></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>