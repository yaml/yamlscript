<!doctype html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-44C9DS3Q80"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-44C9DS3Q80');</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://yamlscript.org/posts/advent-2023/dec-18/"><link href="/assets/main.769d3d1b7edc71568d89.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>Santa&#39;s in d&#39;buggy | YAMLScript</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="Santa&#39;s in d&#39;buggy"><meta property="og:site_name" content="YAMLScript"><meta property="og:type" content="website"><meta property="og:url" content="https://yamlscript.org/posts/advent-2023/dec-18/"><meta name="twitter:card" content="summary_large_image"><meta name="description" content="Santa&amp;#39;s in d&amp;#39;buggy by Ingy döt Net | 18 Dec 2023 | 5 min read With one week to go, Santa&#39;s gotta get his sleigh in top shape. Can&#39;t..."><meta property="og:description" content="Santa&amp;#39;s in d&amp;#39;buggy by Ingy döt Net | 18 Dec 2023 | 5 min read With one week to go, Santa&#39;s gotta get his sleigh in top shape. Can&#39;t..."><meta name="description" content="Santa&amp;#39;s in d&amp;#39;buggy by Ingy döt Net | 18 Dec 2023 | 5 min read With one week to go, Santa&#39;s gotta get his sleigh in top shape. Can&#39;t..."><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/"><img src="/images/yamlscript-logo.svg"></a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/doc">Docs</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/about">About</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>Santa&#39;s in d&#39;buggy</h1><div class="post__details">by <a href="/about/#ingydotnet">Ingy döt Net</a> <span>| </span><time datetime="2023-12-18">18 Dec 2023 </time><span>| </span><span>5 min read</span></div></header><main class="post__content"><p>With one week to go, Santa's gotta get his sleigh in top shape. Can't have any breakdowns on the big night. His sleigh might look like a simple wooden buggy, but it's more temperamental and buggy than a 2023 Tesla!</p><p>But this is Santa we're talking about. He's done this a few times, so he knows how to get the bugs out.</p><h3>Welcome to Day 18 of the YAMLScript Advent Calendar</h3><p>Today we're going to look at a few ways to debug YAMLScript programs. We'll also cover some of the common mistakes that you might make when writing YAMLScript code.</p><pre class="language-yaml"><code class="language-yaml"><span class="token comment"># hello.ys</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello, world!"</span></code></pre><p>Let's run this very simple program:</p><pre class="language-bash"><code class="language-bash">$ ys hello.ys<br>$</code></pre><p>Hmmm. Nothing happened. What's wrong?</p><p>This first thing I do when my YAMLScript program doesn't work is see what the Clojure code that it compiled to looks like. We didn't get a compile error there when we ran <code>ys</code>, so let's look at the code we were running:</p><pre class="language-bash"><code class="language-bash">$ ys hello.ys <span class="token parameter variable">-c</span><br><span class="token punctuation">{</span><span class="token string">"say"</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">}</span></code></pre><p>Oh snap! We forgot to start the program with <code>!yamlscript/v0</code>. The program started of in <code>bare</code> mode, which is just a YAML mapping.</p><p>We also could have run the program with <code>--print</code> to see what it evaluated to:</p><pre class="language-bash"><code class="language-bash">$ ys hello.ys <span class="token parameter variable">-p</span><br><span class="token punctuation">{</span><span class="token string">"say"</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">}</span></code></pre><p>Same thing. Let's fix the program now:</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello, world!"</span></code></pre><p>now:</p><pre class="language-bash"><code class="language-bash">$ ys hello.ys<br>Hello, world<span class="token operator">!</span></code></pre><p>That's better.</p><hr><p>Let's write a program to dynamically generate a list of numbers:</p><pre class="language-yaml"><code class="language-yaml"><span class="token comment"># map.ys</span><br><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">map inc</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>1 2 3<span class="token punctuation">]</span></code></pre><p>This program doesn't <code>say</code> anything. That's because we are using it to generate data, so we'll <code>--load</code> it:</p><pre class="language-bash"><code class="language-bash">$ ys map.ys <span class="token parameter variable">-l</span><br>Compile error: Sequences <span class="token punctuation">(</span>block and flow<span class="token punctuation">)</span> not allowed <span class="token keyword">in</span> code mode</code></pre><p>That's scary! And what's up with Java?! I don't think it even compiled.</p><p>When this happens, I like to debug the 7 layers of YAMLScript compilation, with the <code>--debug-stage=all</code> option, aka <code>-d</code>:</p><pre class="language-bash"><code class="language-bash">$ ys map.ys <span class="token parameter variable">-d</span></code></pre><pre class="language-txt"><code class="language-txt">$ ys map.ys -l -d<br>*** parse output ***<br>({:+ "+MAP", :! "yamlscript/v0"}<br> {:+ "=VAL", := "map inc"}<br> {:+ "+SEQ", :flow true}<br> {:+ "=VAL", := "1 2 3"}<br> {:+ "-SEQ"}<br> {:+ "-MAP"})<br><br>*** compose output ***<br>{:! "yamlscript/v0", :% [{:= "map inc"} {:-- [{:= "1 2 3"}]}]}<br><br>Compile error: Sequences (block and flow) not allowed in code mode</code></pre><p>The 7 stages of YAMLScript compilation are: <code>parse</code>, <code>compose</code>, <code>resolve</code>, <code>build</code>, <code>transform</code>, <code>construct</code>, and <code>print</code>. It looks like we are getting an error in the <code>resolve</code> stage.</p><p>The <code>-d</code> option means the same thing as <code>-Dparse -Dcompose -Dresolve -Dbuild -Dtransform -Dconstruct -Dprint</code>.</p><p>So we parsed the YAML input into pieces and then composed a tree out of them. In the resolve stage we look at each node of the tree and figure out what it means semantically.</p><p>YAMLScript doesn't allow sequences in code mode. And it doesn't allow any flow style collections <code>[] {}</code> in code mode either. But we wrote <code>[1 2 3]</code>, not <code>[1, 2, 3]</code>. To YAML, <code>[1 2 3]</code> is valid but it means <code>[&quot;1 2 3&quot;]</code>. We really meant this list to be a YAMLScript ysexpr vector not a YAML sequence.</p><p>We wanted YAML to see the RHS as a scalar value, not a sequence. YAML plain (unquoted) scalars can't begin with certain characters, like <code>[</code>, <code>{</code>, <code>*</code>, <code>&amp;</code>, <code>!</code>, <code>|</code>, <code>&gt;</code>, <code>%</code>, <code>@</code>, <code>#</code> etc because they are YAML syntax. In YAMLScript when we want a ysexpr string that starts with one of these characters, we can escape it with a plus <code>+</code>.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">map inc</span><span class="token punctuation">:</span> +<span class="token punctuation">[</span>1 2 3<span class="token punctuation">]</span></code></pre><p>And let's just check the resolve stage this time:</p><pre class="language-bash"><code class="language-bash">$ ys map.ys <span class="token parameter variable">-l</span> <span class="token parameter variable">-Dresolve</span></code></pre><pre class="language-txt"><code class="language-txt">$ ys map.ys -l -Dresolve<br>*** resolve output ***<br>{:ysm [{:ysx "map inc"} {:ysx "[1 2 3]"}]}<br><br>[2,3,4]</code></pre><p>It resolved! And it worked! We got our list of numbers.</p><blockquote><p>Note: The error message indicated a <code>java.lang.Exception</code>. Remember that YAMLScript is Clojure and Clojure is Java. The JVM is compiled out of the picture in YAMLScript, but the error message still comes from Java stuff.</p></blockquote><hr><p>Here's a little program to calculate the factorial of a number:</p><pre class="language-yaml"><code class="language-yaml"><span class="token comment"># factorial.ys</span><br><span class="token tag">!</span><span class="token comment">#/usr/bin/env ys-0</span><br><br><span class="token key atrule">defn main(n)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span> factorial(n)<br><br><span class="token key atrule">defn factorial(x)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">apply *</span><span class="token punctuation">:</span> 2 .. x</code></pre><p>Let's see how it works:</p><pre class="language-txt"><code class="language-txt">$ ys factorial.ys<br>Error: Wrong number of args (0) passed to: sci.impl.fns/fun/arity-1--3508<br><br>$ ys factorial.ys 10<br>3628800<br>$ ys factorial.ys 20<br>2432902008176640000<br>$ ys factorial.ys 30<br>Error: long overflow</code></pre><p>Two of the four runs we got an error. Hopefully the errors are pretty obvious. The first time we forgot the number it wanted. The second time we tried to calculate a number that was too big for a 64 bit integer.</p><p>This was a very small program, but when things blow up, it's nice to have a stack trace to see exactly where the error happened and what code path it took to get there. Especially when many library files are involved.</p><p>You can see the stack trace on any error by using the <code>--stack-trace</code> option aka <code>-S</code>:</p><pre class="language-txt"><code class="language-txt">$ ys -S sample/rosetta-code/factorial.ys 30<br>Runtime error:<br>java.lang.ArithmeticException: long overflow<br> at clojure.lang.Numbers.multiply (Numbers.java:1971)<br>    clojure.lang.Numbers$LongOps.multiply (Numbers.java:503)<br>    clojure.lang.Numbers.multiply (Numbers.java:175)<br>    clojure.core$_STAR_.invokeStatic (core.clj:1018)<br>    clojure.core$_STAR_.invoke (core.clj:1010)<br>    clojure.lang.LongRange$LongChunk.reduce (LongRange.java:316)<br>    clojure.core$reduce1.invokeStatic (core.clj:944)<br>    clojure.core$_STAR_.invokeStatic (core.clj:1020)<br>    clojure.core$_STAR_.doInvoke (core.clj:1010)<br>    clojure.lang.RestFn.applyTo (RestFn.java:142)<br>    clojure.core$apply.invokeStatic (core.clj:667)<br>    clojure.core$apply.invoke (core.clj:662)<br>    sci.lang.Var.invoke (lang.cljc:202)<br>    sci.impl.analyzer$return_call$reify__6143.eval (analyzer.cljc:1422)<br>    sci.impl.fns$fun$arity_1__5030.invoke (fns.cljc:107)<br>    sci.lang.Var.invoke (lang.cljc:200)<br>    sci.impl.analyzer$return_call$reify__6139.eval (analyzer.cljc:1422)<br>    sci.impl.analyzer$return_call$reify__6147.eval (analyzer.cljc:1422)<br>    sci.impl.analyzer$return_call$reify__6139.eval (analyzer.cljc:1422)<br>    sci.impl.fns$fun$arity_1__5030.invoke (fns.cljc:107)<br>    clojure.lang.AFn.applyToHelper (AFn.java:154)<br>    clojure.lang.AFn.applyTo (AFn.java:144)<br>    clojure.core$apply.invokeStatic (core.clj:667)<br>    sci.impl.analyzer$analyze_fn_STAR_$reify__5779$f__5780.doInvoke (analyzer.cljc:538)<br>    clojure.lang.RestFn.applyTo (RestFn.java:137)<br>    clojure.core$apply.invokeStatic (core.clj:667)<br>    clojure.core$apply.invoke (core.clj:662)<br>    sci.lang.Var.invoke (lang.cljc:202)<br>    sci.impl.analyzer$return_call$reify__6143.eval (analyzer.cljc:1422)<br>    sci.impl.analyzer$return_call$reify__6139.eval (analyzer.cljc:1422)<br>    sci.impl.interpreter$eval_form.invokeStatic (interpreter.cljc:40)<br>    sci.impl.interpreter$eval_string_STAR_.invokeStatic (interpreter.cljc:66)<br>    sci.core$eval_string_PLUS_.invokeStatic (core.cljc:276)<br>    yamlscript.runtime$eval_string.invokeStatic (runtime.clj:209)<br>    yamlscript.cli$do_run.invokeStatic (cli.clj:347)<br>    yamlscript.cli$do_default.invokeStatic (cli.clj:410)<br>    yamlscript.cli$do_main.invokeStatic (cli.clj:489)<br>    yamlscript.cli$_main.invokeStatic (cli.clj:527)<br>    yamlscript.cli$_main.doInvoke (cli.clj:506)<br>    clojure.lang.RestFn.applyTo (RestFn.java:137)<br>    yamlscript.cli.main (:-1)<br>    java.lang.invoke.LambdaForm$DMH/sa346b79c.invokeStaticInit (LambdaForm$DMH:-1)<br>★```<br><br>Well... You asked for it. :- )<br><br><br>----<br><br>Print debugging is a great way to debug programs.<br>YAMLScript provides some help here with it's `WWW` and `XXX` standard library<br>functions.<br>Conceptually these come from an old Perl module I wrote years ago called<br>[XXX](https://metacpan.org/pod/XXX).<br><br>* `WWW` warns (prints to stderr) it's argument and returns it.<br>* `XXX` dies (prints and then terminates) it's argument.<br><br>Here's a contrived example that passes data through a pipeline of functions:<br><br>```yaml<br># pipeline.ys<br>!yamlscript/v0<br>->> (1..10):<br>  map: inc<br>  filter: \(= 0 (mod % 2))  # odd?<br>  reduce: +<br>  =>: say</code></pre><p>Check it:</p><pre class="language-txt"><code class="language-txt">$ ys pipeline.ys<br>30</code></pre><p>The <code>-&gt;&gt;</code> function is Clojure's threading macro. It lets you pass a value through a pipeline of transformation functions without having to reverse nest them in a ton of parentheses. It's quite nice and handy.</p><p>Often times when I'm writing a pipeline like this, I want to see what the data looks like after a particular transformation or maybe after several of them. I almost always us <code>WWW</code> for this.</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">->> (1..10)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">WWW</span><span class="token punctuation">:</span> <span class="token string">"before map"</span><br>  <span class="token key atrule">map</span><span class="token punctuation">:</span> inc<br>  <span class="token key atrule">WWW</span><span class="token punctuation">:</span> <span class="token string">"after map"</span><br>  <span class="token key atrule">filter</span><span class="token punctuation">:</span> \(= 0 (mod % 2))  <span class="token comment"># odd?</span><br>  <span class="token key atrule">WWW</span><span class="token punctuation">:</span> <span class="token string">"after filter"</span><br>  <span class="token key atrule">reduce</span><span class="token punctuation">:</span> +<br>  <span class="token key atrule">WWW</span><span class="token punctuation">:</span> <span class="token string">"after reduce"</span><br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> say<br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> WWW</code></pre><p>The <code>WWW</code> function can actually take multiple arguments. It prints them all and returns the last one. The <code>-&gt;&gt;</code> threading macro adds its value as the last argument to each function. So the way we did it here we are adding a label to each debugging section.</p><p>I used <code>=&gt;: WWW</code> to show how to call it with no extra label argument. Remember that <code>=&gt;:</code> is the YAMLScript way to write a mapping pair when you only need one thing (the <code>WWW</code> function in this case).</p><pre class="language-txt"><code class="language-txt">$ ys pipeline.ys<br>---<br>("before map" (1 2 3 4 5 6 7 8 9 10))<br>...<br>---<br>("after map" (2 3 4 5 6 7 8 9 10 11))<br>...<br>---<br>("after filter" (2 4 6 8 10))<br>...<br>---<br>("after reduce" 30)<br>...<br>30<br>---<br>nil<br>...</code></pre><p>Each WWW call wraps the output with a <code>---</code> and a <code>...</code> so you can see where the output starts and ends.</p><hr><p>I hope you enjoyed this little tour of YAMLScript debugging. There are many more ways to debug YAMLScript programs. Likely many than I've even thought of yet.</p><p>See you tomorrow for Day 19 of the YAMLScript Advent Calendar.</p></main><aside class="post__aside"><div class="post__tags"><a href="/tags/blog/">#blog</a> <a href="/tags/advent-2023/">#advent-2023</a></div><nav class="post__pagination"><a href="/posts/advent-2023/dec-17/"><span>←</span> <span>Rosetta Code</span> </a><a href="/posts/advent-2023/dec-19/"><span>Reindeer All The Way Down</span> <span>→</span></a></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a href="https://github.com/yaml/yamlscript" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul><p class="footer__attribution">Powered by <a href="https://www.11ty.dev" target="_blank" rel="noopener">Eleventy</a>. Theme: <a href="https://github.com/yinkakun/eleventy-duo" target="_blank" rel="noopener noreferrer">Eleventy Duo</a>.</p></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>