<!doctype html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-44C9DS3Q80"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-44C9DS3Q80');</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://yamlscript.org/posts/advent-2023/dec-10/"><link href="/assets/main.089cde16aad3ee63f22f.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>States and Ladders | YAMLScript</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="States and Ladders"><meta property="og:site_name" content="YAMLScript"><meta property="og:type" content="website"><meta property="og:url" content="https://yamlscript.org/posts/advent-2023/dec-10/"><meta name="twitter:card" content="summary_large_image"><meta name="description" content="States and Ladders by Ingy döt Net | 10 Dec 2023 | 6 min read Santa is a busy guy. He has a lot of work to do. He has to make a list and..."><meta property="og:description" content="States and Ladders by Ingy döt Net | 10 Dec 2023 | 6 min read Santa is a busy guy. He has a lot of work to do. He has to make a list and..."><meta name="description" content="States and Ladders by Ingy döt Net | 10 Dec 2023 | 6 min read Santa is a busy guy. He has a lot of work to do. He has to make a list and..."><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/"><img src="/images/yamlscript-logo.svg"></a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/doc">Docs</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/about">About</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>States and Ladders</h1><div class="post__details">by <a href="/about/#ingydotnet">Ingy döt Net</a> <span>| </span><time datetime="2023-12-10">10 Dec 2023 </time><span>| </span><span>6 min read</span></div></header><main class="post__content"><p>Santa is a busy guy. He has a lot of work to do. He has to make a list and check it twice. He has to find out who's naughty and nice. He has the monumental task of transforming wishes into happiness.</p><p>YS only needs to transform YAMLScript into Clojure. But it's a bit more involved than you might think.</p><p>To make things easier the YS compiler breaks the transformation into eight distinct States and seven distinct <s>Ladders</s> transformations.</p><h3>Welcome to Day 10 of the YAMLScript Advent Calendar</h3><p>Today we're going to learn more exactly how <code>ys --compile</code> turns YAMLScript into Clojure.<br><em>Fair Warning: This is going to be a long post</em>.</p><p>The <code>ys</code> CLI has an awesome tool to visualize the transformation process any time you are interested. This might be for debugging where something went wrong, or just to learn more about how the compiler works.</p><p>To begin this journey, let's use this visualizer in action. You could write it like this:</p><pre class="language-bash"><code class="language-bash">ys <span class="token parameter variable">--compile</span> --debug-stage<span class="token operator">=</span>all <span class="token parameter variable">-e</span> <span class="token string">'name =: "Clojure"'</span> <span class="token parameter variable">-e</span> <span class="token string">'say: "Hello, $name!"'</span></code></pre><p>The one line program is equivalent to the file containing:</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">name =</span><span class="token punctuation">:</span> <span class="token string">"Clojure"</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello, $name!"</span></code></pre><p>Let's run the command now (but we'll use the shorter options):</p><pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> <span class="token parameter variable">-e</span> <span class="token string">'name =: "Clojure"'</span> <span class="token parameter variable">-e</span> <span class="token string">'say: "Hello, $name!"'</span> <span class="token parameter variable">-d</span><br>*** parse     *** <span class="token number">0.127737</span> ms<br><span class="token punctuation">(</span><span class="token punctuation">{</span>:+ <span class="token string">"+MAP"</span>, :<span class="token operator">!</span> <span class="token string">"yamlscript/v0/code"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :<span class="token operator">=</span> <span class="token string">"name ="</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :$ <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :<span class="token operator">=</span> <span class="token string">"say"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :$ <span class="token string">"Hello, <span class="token variable">$name</span>!"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"-MAP"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"-DOC"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><br><br>*** compose   *** <span class="token number">0.009495</span> ms<br><span class="token punctuation">{</span>:<span class="token operator">!</span> <span class="token string">"yamlscript/v0/code"</span>,<br> :% <span class="token punctuation">[</span><span class="token punctuation">{</span>:<span class="token operator">=</span> <span class="token string">"name ="</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:$ <span class="token string">"Clojure"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:<span class="token operator">=</span> <span class="token string">"say"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:$ <span class="token string">"Hello, <span class="token variable">$name</span>!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** resolve   *** <span class="token number">0.073969</span> ms<br><span class="token punctuation">{</span>:pairs<br> <span class="token punctuation">[</span><span class="token punctuation">{</span>:def <span class="token string">"name ="</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:vstr <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:exp <span class="token string">"say"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:vstr <span class="token string">"Hello, <span class="token variable">$name</span>!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** build     *** <span class="token number">0.375378</span> ms<br><span class="token punctuation">{</span>:pairs<br> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym def<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span><span class="token punctuation">]</span><br>  <span class="token punctuation">{</span>:Str <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym str<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** transform *** <span class="token number">0.027342</span> ms<br><span class="token punctuation">{</span>:pairs<br> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym def<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span><span class="token punctuation">]</span><br>  <span class="token punctuation">{</span>:Str <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym str<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** construct *** <span class="token number">0.087933</span> ms<br><span class="token punctuation">{</span>:Top<br> <span class="token punctuation">[</span><span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym def<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Clojure"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Lst<br>   <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span><br>    <span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym str<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** print     *** <span class="token number">0.014494</span> ms<br><span class="token string">"(def name <span class="token entity" title="\&quot;">\"</span>Clojure<span class="token entity" title="\&quot;">\"</span>)(say (str <span class="token entity" title="\&quot;">\"</span>Hello, <span class="token entity" title="\&quot;">\"</span> name <span class="token entity" title="\&quot;">\"</span>!<span class="token entity" title="\&quot;">\"</span>))"</span><br><br><span class="token punctuation">(</span>def name <span class="token string">"Clojure"</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span>say <span class="token punctuation">(</span>str <span class="token string">"Hello, "</span> name <span class="token string">"!"</span><span class="token punctuation">))</span></code></pre><p>Woah! That's a lot of output. But it's exactly what I want to tell you about today.</p><p>At the bottom is the clojure code we expect. Above that is the output of each of the seven transformations (aka the 7 states that come after the first state: our YS input).</p><p>Let's look at each of these transformations in turn...</p><h3>Transformation 1: Parse</h3><p>The first transformation is parsing YAML into a sequence of &quot;parse events&quot;. This is by far the hardest transformation, not just for YS but for any YAML processor. Sadly, it's so hard that only a few of the dozens of YAML processors out there actually do it correctly. See: <a href="https://matrix.yaml.info/">https://matrix.yaml.info/</a></p><p>On the other hand, this is actually the simplest part for the YS compiler to implement. Why? Because it uses somebody else's YAML parser!!</p><blockquote><p>Note: YS currently uses the <a href="https://bitbucket.org/snakeyaml/snakeyaml-engine">SnakeYAML Engine</a> framework (only for it's YAML 1.2 parser component). Later we plan to use <a href="https://github.com/pantoniou/libfyaml">libfyaml</a> which is currently considered the best YAML parser in the world. SnakeYAML was the obvious first choice because it's written in Java, YS is written in Clojure and Clojure is a JVM language. It's doing a great job for now!</p></blockquote><p>This is a good time to mention that the YAML data language spec describes &quot;loading&quot; YAML text into native data structures as a several step process of states and transformations. In reality, the YS compiler is really just a very fancy YAML loader!</p><p>YAML parsers typically produce 10 different kinds of parse events:</p><ul><li>Start Stream</li><li>End Stream</li><li>Start Document</li><li>End Document</li><li>Start Sequence</li><li>End Sequence</li><li>Start Mapping</li><li>End Mapping</li><li>Scalar Value</li><li>Alias Reference</li></ul><p>YS (currently) doesn't care about the first 4 events, so it just ignores them.</p><p>That leaves use with a mapping containing 2 key/value pairs:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"+MAP"</span><span class="token punctuation">,</span> <span class="token symbol">:!</span> <span class="token string">"yamlscript/v0"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"=VAL"</span><span class="token punctuation">,</span> <span class="token symbol">:=</span> <span class="token string">"name ="</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"=VAL"</span><span class="token punctuation">,</span> :$ <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"=VAL"</span><span class="token punctuation">,</span> <span class="token symbol">:=</span> <span class="token string">"say"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"=VAL"</span><span class="token punctuation">,</span> :$ <span class="token string">"Hello, $name!"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"-MAP"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><p>We are showing this state as a Clojure data structure and that's the kind of serialization that we use in the YS compiler tests.</p><p>Here's a quick breakdown of the mapping keywords used above:</p><ul><li><code>:+</code> is the parse event type</li><li><code>:!</code> is the (optional) YAML tag</li><li><code>:=</code> is a plain (unquoted) scalar value</li><li><code>:$</code> is a double quoted scalar value</li></ul><p>That was a lot of info, but hopefully it sets the stage for the rest of this post.</p><p>If you are interested in seeing how all this is implemented, check out:</p><ul><li><a href="https://github.com/yaml/yamlscript/tree/main/core/src/yamlscript">All the YS transformation libraries source code</a></li><li>The YS Test Suite Files:<ul><li><a href="https://github.com/yaml/yamlscript/blob/main/core/test/compiler-stack.yaml">https://github.com/yaml/yamlscript/blob/main/core/test/compiler-stack.yaml</a></li><li><a href="https://github.com/yaml/yamlscript/blob/main/core/test/compiler.yaml">https://github.com/yaml/yamlscript/blob/main/core/test/compiler.yaml</a></li></ul></li></ul><h3>Transformation 2: Compose</h3><p>The second transformer is called the composer (in the <code>yamlscript.composer</code> library).</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:!</span> <span class="token string">"yamlscript/v0"</span><span class="token punctuation">,</span><br> :% <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:=</span> <span class="token string">"name ="</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:$ <span class="token string">"Clojure"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:=</span> <span class="token string">"say"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:$ <span class="token string">"Hello, $name!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>Its simple job is to take the parse events and compose them into a tree of mapping, sequence and scalar nodes.</p><p>It preserves the node's tag if any.</p><p>Here we see a new keyword <code>:%</code> which is used for a mapping node. Sequence nodes use the keyword <code>:-</code> but they only show up in data mode, which we aren't using here.</p><p>Now we have all the important information from the YAML input in an AST form that we can refine (transform) a few more times until it becomes a Clojure AST!</p><h3>Transformation 3: Resolve</h3><p>YAML tags are rarely seen in the wild. Many YAML users don't even know they exist. But tags play an important role in the YAML load process. Internally every single untagged node is assigned a tag based on heuristics that consider its kind, position and content.</p><p>This process is called &quot;tag resolution&quot; and it's what we are doing here:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:ysm</span><br> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:ysx</span> <span class="token string">"def name"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:ysi</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:ysx</span> <span class="token string">"say"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:ysi</span> <span class="token string">"Hello, $name!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>Notice that all the keywords changed to <code>:ys?</code> here. This is how YS stores the tag. Each tag knows what kind of node it is attached to (map, seq or scalar) so, to keep things simple, it doesn't store that info in the AST.</p><blockquote><p>Note: Keeping the structure of each state AST as simple as possible is a key concern of the YS compiler. It makes it easier to see what's going on when debugging and even more importantly, it makes it easier to write tests for each transformation.</p></blockquote><p>The keywords seen above are:</p><ul><li><code>:ysm</code> is a code mode mapping node</li><li><code>:ysi</code> is a scalar that supports interpolation</li><li><code>:ysx</code> is a ys expression (a string of code to be further parsed)</li></ul><p>Tags are are essentially the names of the transformations that will be applied to the node in the following transformation.</p><h3>Transformation 4: Build</h3><p>The build transformation is where a lot of the magic happens.</p><p>Most importantly, it's where scalars containing YAMLScript expressions are lexed and parsed into Clojure expression ASTs.</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:ysm</span><br> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> def<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span><span class="token punctuation">]</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Sym</span> say<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> str<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>For instance we can see that the simple string expression &quot;def name&quot; was parsed into 2 Clojure symbol nodes: <code>{:Sym def}</code> and <code>{:Sym name}</code>.</p><p>We can also see that the string expression &quot;Hello, $name!&quot; was parsed into a an interpolated string expression that joins string literals and variable values into a single string.</p><p>One important aspect of the build output AST is that it retains the original structure of the YAML input. Mappings still have key/value pairs, and the key info stays separate from the value info.</p><h3>Transformation 5: Transform</h3><p>The transformer transformation (that's a bit awkward I'll admit) is where &quot;special cases&quot; are handled.</p><p>Not much happens in this stage yet. In fact nothing at all happened in this example.</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:ysm</span><br> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> def<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span><span class="token punctuation">]</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Sym</span> say<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> str<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>It's exactly the same as the build output.</p><p>In the future, the transform stage is where we will add support for letting users defined their own syntax and semantic transformations for specific functions. If you know about Lisp macros, this will be something spiritually similar.</p><p>If you happen to think a particular function should be coded a specific way, you'll be able to make it so. As long as you don't break the rules of physics... or YAML!</p><p>Note that even though this transformation can change the AST quite a bit, it still retains its overall YAML structure.</p><h3>Transformation 6: Construct</h3><p>The constructor phase's job is simple. Turn the final YAML structured AST into an AST that directly represents the intended Clojure code compilation result.</p><p>It does this essentially by applying the function asscoiated with a node's tag to the node's value.</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:Lst</span><br> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> do<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> def<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span><br>   <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> say<span class="token punctuation">}</span><br>    <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> str<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>Every node in this AST directy represents a Clojure code construct. Voila!</p><h3>Transformation 7: Print</h3><p>Just like in any Lisp, a Clojure AST &quot;prints&quot; directly to Clojure code. This is because every node in the AST is essentially a token that knows how to print itself!</p><p>Again here's our final AST:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:Lst</span><br> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> do<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> def<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span><br>   <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> say<span class="token punctuation">}</span><br>    <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> str<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>The <code>yamlscript.printer/print</code> function converts that to this string (of Clojure code):</p><pre class="language-clojure"><code class="language-clojure"><span class="token string">"(def name \"Clojure\")\n(say (str \"Hello, \" name \"!\"))\n"</span></code></pre><p>When that string is printed out, it looks like this:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">def</span> name <span class="token string">"Clojure"</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token function">say</span> <span class="token punctuation">(</span><span class="token keyword">str</span> <span class="token string">"Hello, "</span> name <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Aaaand, we're done!</p><h3>Transformation 1-7: Compile</h3><p>The YAMLScript compiler is just all the above crammed together is sequence; passing YS input through the 7 transformations we just described.</p><p>I'd like to show you the actual YAMLScript <code>compile</code> function (written in Clojure):</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> compile<br>  <span class="token string">"Convert YAMLScript code string to an equivalent Clojure code string."</span><br>  <span class="token punctuation">[</span><span class="token operator">^</span>String yamlscript-string<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">->></span> yamlscript-string<br>    yamlscript.parser/parse<br>    yamlscript.composer/compose<br>    yamlscript.resolver/resolve<br>    yamlscript.builder/build<br>    yamlscript.transformer/transform<br>    yamlscript.constructor/construct<br>    yamlscript.printer/print<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Pretty straightforward, right? Or if you are more familiar with YAMLScript than Clojure:</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn compile(yamlscript-string)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">"Convert YAMLScript code string to an equivalent Clojure code string."</span><span class="token punctuation">:</span><br>  <span class="token key atrule">->></span><span class="token punctuation">:</span><br>    yamlscript<span class="token punctuation">-</span>string<br>    yamlscript<span class="token punctuation">:</span><span class="token punctuation">:</span>parser/parse<br>    yamlscript<span class="token punctuation">:</span><span class="token punctuation">:</span>composer/compose<br>    yamlscript<span class="token punctuation">:</span><span class="token punctuation">:</span>resolver/resolve<br>    yamlscript<span class="token punctuation">:</span><span class="token punctuation">:</span>builder/build<br>    yamlscript<span class="token punctuation">:</span><span class="token punctuation">:</span>transformer/transform<br>    yamlscript<span class="token punctuation">:</span><span class="token punctuation">:</span>constructor/construct<br>    yamlscript<span class="token punctuation">:</span><span class="token punctuation">:</span>printer/print</code></pre><p>I hope I didn't waste too much of your Sunday on this post. I know it was a lot to take in, and I also know you don't need to know all this to be a good YAMLScript programmer.</p><p>But then again, you probably want to know all about this to become a great one!</p><p>See you tomorrow for Day 11 of the YAMLScript Advent Calendar.</p></main><aside class="post__aside"><div class="post__tags"><a href="/tags/blog/">#blog</a> <a href="/tags/advent-2023/">#advent-2023</a></div><nav class="post__pagination"><a href="/posts/advent-2023/dec-09/"><span>←</span> <span>Coding with Style</span> </a><a href="/posts/advent-2023/dec-11/"><span>The YeS Express</span> <span>→</span></a></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a href="https://github.com/yaml/yamlscript" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul><p class="footer__attribution">Powered by <a href="https://www.11ty.dev" target="_blank" rel="noopener">Eleventy</a>. Theme: <a href="https://github.com/yinkakun/eleventy-duo" target="_blank" rel="noopener noreferrer">Eleventy Duo</a>.</p></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>