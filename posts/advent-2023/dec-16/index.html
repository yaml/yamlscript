<!doctype html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-44C9DS3Q80"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-44C9DS3Q80');</script><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://yamlscript.org/posts/advent-2023/dec-16/"><link href="/assets/main.769d3d1b7edc71568d89.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>Let Lambda Come Over | YAMLScript</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="Let Lambda Come Over"><meta property="og:site_name" content="YAMLScript"><meta property="og:type" content="website"><meta property="og:url" content="https://yamlscript.org/posts/advent-2023/dec-16/"><meta name="twitter:card" content="summary_large_image"><meta name="description" content="Let Lambda Come Over by Ingy döt Net | 16 Dec 2023 | 4 min read We know the names of Santa&#39;s reindeer: Dasher, Dancer, Prancer, Vixen,..."><meta property="og:description" content="Let Lambda Come Over by Ingy döt Net | 16 Dec 2023 | 4 min read We know the names of Santa&#39;s reindeer: Dasher, Dancer, Prancer, Vixen,..."><meta name="description" content="Let Lambda Come Over by Ingy döt Net | 16 Dec 2023 | 4 min read We know the names of Santa&#39;s reindeer: Dasher, Dancer, Prancer, Vixen,..."><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/"><img src="/images/yamlscript-logo.svg"></a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/doc">Docs</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/about">About</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>Let Lambda Come Over</h1><div class="post__details">by <a href="/about/#ingydotnet">Ingy döt Net</a> <span>| </span><time datetime="2023-12-16">16 Dec 2023 </time><span>| </span><span>4 min read</span></div></header><main class="post__content"><p>We know the names of Santa's reindeer: Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner, Blitzen and Rudolph. And his elves: Alabaster Snowball, Bushy Evergreen, Pepper Minstix, Shinny Upatree, Sugarplum Mary, Wunorse Openslae, and the head elf, Bernard.</p><p>But we don't know the names of Santa's lambda reindeer and elves. Why would we? They are anonymous! They're also the hardest working of the bunch.</p><h3>Welcome to Day 16 of the YAMLScript Advent Calendar</h3><p>Today we're going to talk about YS lambdas and their frontman named &quot;let&quot;.</p><p>It's a kinda of a big deal in your programming journey when you realize the power of <em>NOT</em> naming things, especially functions. Next you learn about functions that take functions and turn them into other functions and your head explodes. (Not literally because then you are dead and can't enjoy the power of lambdas).</p><p>A lambda is a general term for an anonymous function, ie one that is not named. In Clojure you create can create them in two different ways. Here's a simple lambda that squares a number:</p><pre class="language-clojure"><code class="language-clojure"><span class="token comment">;; Using the fn keyword</span><br><span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">*</span> x x<span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token comment">;; Using the #() reader macro</span><br><span class="token operator">#</span><span class="token punctuation">(</span><span class="token keyword">*</span> %<span class="token number">1</span> %<span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>Note: Clojure just calls them &quot;anonymous functions&quot;.</p><p>Here's both of those in YAMLScript:</p><pre class="language-yaml"><code class="language-yaml"><span class="token comment"># Using the fn keyword</span><br><span class="token key atrule">fn(x)</span><span class="token punctuation">:</span> x * x<br><span class="token comment"># Using the #() reader macro</span><br>\(%1 * %1)</code></pre><p>The latter method is shorter but the former is more flexible.</p><p>Typically you use lambdas to return closures, which are functions that have access to the variables in the scope where they were created.</p><p>Here's a function the returns a function that adds a number to another number:</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn adder(x)</span><span class="token punctuation">:</span> \(%1 + x)<br><span class="token key atrule">add-5 =</span><span class="token punctuation">:</span> adder(5)<br><span class="token key atrule">add-5</span><span class="token punctuation">:</span> <span class="token number">10</span>           <span class="token comment"># => 15</span></code></pre><p>In the <code>adder</code> function, the <code>x</code> variable gets created in the scope of the function and is not available outside of it. But we returned a function that &quot;closed over&quot; it so that it could be used by the returned function later on.</p><h2>let in the lexicals!</h2><p>In the <code>adder</code> function, the <code>x</code> variable was a parameter to the function and created a lexical variable whose scope was the function body. How do we create more lexical variables in to use in a function?</p><p>In Python you we get the lexicals <code>x</code>, <code>y</code> and <code>z</code> by defining them in the function body:</p><pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span><br>    y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><br>    z <span class="token operator">=</span> y <span class="token operator">/</span> <span class="token number">2</span><br>    <span class="token keyword">return</span> z</code></pre><p>Pretty clean and simple.</p><p>In Clojure we use the <code>let</code> keyword to create more lexical variables:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> foo <span class="token punctuation">[</span>x<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>y <span class="token punctuation">(</span><span class="token keyword">+</span> x <span class="token number">1</span><span class="token punctuation">)</span><br>        z <span class="token punctuation">(</span><span class="token keyword">/</span> y <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><br>    z<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>The <code>let</code> keyword takes a vector (array in <code>[]</code>) of bindings and then a body of code to execute. The binding vector contains one or more pairs of a name (symbol) and an expression that evaluates to a value.</p><p>The Clojure code looks a little more complicated than the Python code. That's the price for needing to write everything the same way with parenthesized lists.</p><p>Let's see how YAMLScript does it:</p><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn foo(x)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">y =</span><span class="token punctuation">:</span> x + 1<br>  <span class="token key atrule">z =</span><span class="token punctuation">:</span> y / 2<br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> z</code></pre><p>How can that be the same as the Clojure code?!?! There's no <code>let</code> keyword. Let's try compiling it and see what happens:</p><pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> let.ys<br><span class="token punctuation">(</span>defn foo <span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token punctuation">(</span>let <span class="token punctuation">[</span>y <span class="token punctuation">(</span>_+ x <span class="token number">1</span><span class="token punctuation">)</span> z <span class="token punctuation">(</span>/ y <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> z<span class="token punctuation">))</span></code></pre><p>Well look at that! It generated the <code>let</code> keyword for us.</p><p>The <code>a =: b</code> YS syntax has super powers. When used at th top level in a program it simply creates a <code>def</code> expression like <code>(def a b)</code>, but when used inside another YS mapping it turns into a <code>let</code>! Not only that, but when their are multiple <code>x := y</code> expressions in a row, they are all put into the same <code>let</code> binding vector, just like you'd do if you wrote the Clojure code by hand.</p><p>The big win here is that the code you write looks clean like the Python code, but works perfectly as Clojure code. It's one of my favorite features of YAMLScript. The need for lexical variables is constant and this makes it painless.</p><h3>LoL!!!</h3><p>Let and Lambdas are 2 of the most important features for Lisp (thus Clojure) programmers. There's a famous book called &quot;Let Over Lambda&quot; that is a must read for any serious Lisp programmer. Note: I haven't read it yet, but I am serious, therefore it's a must!</p><p>Here's a great snippet from the book:</p><blockquote><p>Sometimes it's called a closure, other times a saved lexical environment. Or, as some of us like to say, let over lambda. Whatever terminology you use, mastering this concept of a closure is the first step to becoming a professional lisp programmer. In fact, this skill is vital for the proper use of many modern programming languages, even ones that don't explicitly contain let or lambda, such as Perl or Javascript.</p></blockquote><p>Let over Lambda (LoL!) is built around this simple Lisp idiom:</p><pre class="language-lisp"><code class="language-lisp"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token car">x</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>  <span class="token punctuation">(</span><span class="token lambda"><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token arguments"></span><span class="token punctuation">)</span></span> x<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>But there' a little more to it than that. In most Lisps the <code>x</code> value is mutable. That means the lambda can change the value of <code>x</code> when it is called. This is a very powerful feature because it allows you to create functions that can hold state. You can use this to create iterators, generators, and even object oriented systems.</p><p>But in Clojure all values are immutable. This is foundational to making Clojure a functional and thread safe language. But Clojure is also famous for being a <strong>practical</strong> (functional and thread safe) language. It has a kind of value that <em>is</em> mutable. These are called atoms.</p><p>Let's make the quintessential LoL example, a counter, in Clojure:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> new-counter <span class="token punctuation">[</span>n<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token punctuation">(</span><span class="token function">atom</span> n<span class="token punctuation">)</span><span class="token punctuation">]</span><br>    <span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token function">swap!</span> x inc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token keyword">def</span> counter <span class="token punctuation">(</span><span class="token function">new-counter</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token keyword">println</span> <span class="token punctuation">(</span><span class="token function">counter</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">#</span> => <span class="token number">11</span><br><span class="token punctuation">(</span><span class="token keyword">println</span> <span class="token punctuation">(</span><span class="token function">counter</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">#</span> => <span class="token number">12</span><br><span class="token punctuation">(</span><span class="token keyword">println</span> <span class="token punctuation">(</span><span class="token function">counter</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">#</span> => <span class="token number">13</span></code></pre><p>Writing this in YAMLScript is a simple port:</p><pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">defn new-counter(n)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">x =</span><span class="token punctuation">:</span> atom(n)<br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> \(swap<span class="token tag">!</span> x inc)<br><span class="token key atrule">counter =</span><span class="token punctuation">:</span> new<span class="token punctuation">-</span>counter(10)<br><span class="token key atrule">say</span><span class="token punctuation">:</span> counter() <span class="token comment"># => 11</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> counter() <span class="token comment"># => 12</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> counter() <span class="token comment"># => 13</span></code></pre><p>Someone told me the other day that YAMLScript was a &quot;lol language&quot;. This must be what they meant.</p><p>The lols continue tomorrow, on Day 17 of the YAMLScript Advent Calendar!</p></main><aside class="post__aside"><div class="post__tags"><a href="/tags/blog/">#blog</a> <a href="/tags/advent-2023/">#advent-2023</a></div><nav class="post__pagination"><a href="/posts/advent-2023/dec-15/"><span>←</span> <span>Naughty is Nice!</span> </a><a href="/posts/advent-2023/dec-17/"><span>Rosetta Code</span> <span>→</span></a></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a href="https://github.com/yaml/yamlscript" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul><p class="footer__attribution">Powered by <a href="https://www.11ty.dev" target="_blank" rel="noopener">Eleventy</a>. Theme: <a href="https://github.com/yinkakun/eleventy-duo" target="_blank" rel="noopener noreferrer">Eleventy Duo</a>.</p></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>