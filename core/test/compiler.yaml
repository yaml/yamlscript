# Copyright 2023-2024 Ingy dot Net
# This code is licensed under MIT license (See License for details)

- name: Test label / description
  yamlscript: |
  clojure: |
  TEMPLATE: true


- name: Simple map pair expression
  yamlscript: |
    !yamlscript/v0
    foo: bar
  clojure: |
    (foo bar)


- name: An 'if' statement
  yamlscript: |
    !yamlscript/v0
    if (x > 10):
      foo(x)
      bar(x)
  clojure: |
    (if (> x 10) (foo x) (bar x))


- name: Double quoted string
  yamlscript: |
    !yamlscript/v0
    println: "foo"
  clojure: |
    (println "foo")


- name: Single quoted string
  yamlscript: |
    !yamlscript/v0
    println: 'foo'
  clojure: |
    (println "foo")


- name: Literal style string
  yamlscript: |
    !yamlscript/v0
    println: |-
      foo
  clojure: |
    (println "foo")


- name: Folded style string
  yamlscript: |
    !yamlscript/v0
    println: >-
      foo
  clojure: |
    (println "foo")


- name: rng operator
  yamlscript: |
    !yamlscript/v0
    say: (1 .. 10)
  clojure: |
    (say (rng 1 10))


- name: String concat operator
  yamlscript: |
    !yamlscript/v0
    (a + "-" + b)
  clojure: |
    (_+ a "-" b)


- name: String repeat operator
  yamlscript: |
    !yamlscript/v0
    ("foo" * 3)
  transform: |
    {:Lst [{:Sym _*} {:Str "foo"} {:Int 3}]}
  clojure: |
    (_* "foo" 3)


- name: Nested mappings
  yamlscript: |
    !yamlscript/v0
    foo:
      bar: baz
  resolve: |
    {:pairs [{:exp "foo"} {:pairs [{:exp "bar"} {:exp "baz"}]}]}
  clojure: |
    (foo (bar baz))


- name: String interpolation
  yamlscript: |
    !yamlscript/v0
    say: "Hello $name $(inc 41) $dec(43)!"
  clojure: |
    (say (str "Hello " name " " (inc 41) " " (dec 43) "!"))


- name: Multi-line string interpolation
  yamlscript: |
    !yamlscript/v0
    say: |
      Dear $word(:name),

      Sincerely, $word(:name)
  clojure: |
    (say (str "Dear " (word :name) ",\n\nSincerely, " (word :name) "\n"))


- name: String interpolation escaped $
  yamlscript: |
    !yamlscript/v0
    say: "Hello \\$name"
  clojure: |
    (say "Hello $name")


- name: Automatically call the main function when defined
  yamlscript: |
    !yamlscript/v0
    defn main(name):
      say: "Hello $name"
    x =: 1
  clojure: |
    (defn main [name] (say (str "Hello " name)))
    (def x 1)
    (apply main ARGS)


- name: The => operator
  yamlscript: |
    !yamlscript/v0
    x =: 41
    =>: (x + 1)
  clojure: |
    (def x 41)
    (_+ x 1)


- name: (a + b + c) -> (+ a b c)
  yamlscript: |
    !yamlscript/v0
    =>: (a + b + c)
  clojure: |
    (_+ a b c)


- name: Pre-declare top level functions as needed
  yamlscript: |
    !yamlscript/v0
    defn foo():
      bar: 123
    defn bar(n):
      =>: 321
  clojure: |
    (declare bar)
    (defn foo [] (bar 123))
    (defn bar [n] 321)


- name: Pre-declare symbols not called as functions
  yamlscript: |
    !yamlscript/v0
    defn a():
      map b: (1 .. 3)
    defn b():
      c()
    defn c():
      =>: 123
  clojure: |
    (declare b c)
    (defn a [] (map b (rng 1 3)))
    (defn b [] (c))
    (defn c [] 123)


- name: The || or operator
  yamlscript: |
    !yamlscript/v0
    =>: (a || b)
  clojure: |
    (or a b)


- name: Multiple && and operators
  yamlscript: |
    !yamlscript/v0
    =>: (a && b && c)
  clojure: |
    (and a b c)


- name: Triplets without parens
  yamlscript: |
    !yamlscript/v0
    =>: a + b
  clojure: |
    (_+ a b)


- name: Multiple same operators without parens
  yamlscript: |
    !yamlscript/v0
    =>: a + b + c
  clojure: |
    (_+ a b c)


- name: The => operator inside parens
  yamlscript: |
    !yamlscript/v0
    =>: (=> 123)
  clojure: |
    123


- name: Code generation for let
  yamlscript: |
    !yamlscript/v0
    defn foo(x):
      y =: x + 1
      x =: y * x
      =>: x
  clojure: |
    (defn foo [x] (let [y (_+ x 1) x (_* y x)] x))


- name: Multiple pairs in let
  yamlscript: |
    !yamlscript/v0
    defn foo(x):
      y =: x + 1
      prn: y
      prn: x
      =>: x
  clojure: |
    (defn foo [x] (let [y (_+ x 1)] (prn y) (prn x) x))


- name: let in let
  yamlscript: |
    !yamlscript/v0
    defn foo(x):
      y =: x + 1
      prn: y
      x =: y * x
      prn: x
      =>: x
  clojure: |
    (defn foo [x] (let [y (_+ x 1)] (prn y) (let [x (_* y x)] (prn x) x)))


- name: let not first in defn
  yamlscript: |
    !yamlscript/v0
    defn foo(x):
      prn: x
      y =: x + 1
      prn: y
      =>: x + y
  clojure: |
    (defn foo [x] (prn x) (let [y (_+ x 1)] (prn y) (_+ x y)))


- name: let over lambda
  yamlscript: |
    !yamlscript/v0

    defn lol(x):
      y =: 2 * x
      =>: \(%1 + y)

    say:
      lol(10): 4
  clojure: |
    (defn lol [x] (let [y (_* 2 x)] (fn [& [_1]] (_+ _1 y))))
    (say ((lol 10) 4))


- name: Default args
  yamlscript: |
    !yamlscript/v0
    defn increase(x n=1):
      =>: x + n
  clojure: |
    (defn increase ([x n] (_+ x n)) ([x] (increase x 1)))


- name: Call main when program has one top level (defn main ...) form
  yamlscript: |
    !yamlscript/v0
    defn main():
      say: "Hello World"
  clojure: |
    (defn main [] (say "Hello World"))
    (apply main ARGS)


- name: Interpolate variable with - in it
  yamlscript: |
    !yamlscript/v0
    foo-bar =: "World"
    defn say-hi():
      say: "Hello $foo-bar!!"
  clojure: |
    (def foo-bar "World")
    (defn say-hi [] (say (str "Hello " foo-bar "!!")))


- name: Fully qualified symbols
  yamlscript: |
    !yamlscript/v0
    ys::std/say: ys
    foo/bar: baz
  clojure: |
    (ys.std/say ys)
    (foo/bar baz)


- name: Anonymous function
  yamlscript: |
    !yamlscript/v0
    foo =: \(%1 + %4)
  build: |
   {:pairs
    ([{:Sym def} {:Sym foo}]
     {:Lst
      [{:Sym fn}
       {:Vec
        [{:Sym &}
         {:Vec [{:Sym _1} {:Sym _} {:Sym _} {:Sym _4}]}]}
       {:Lst [{:Sym +} {:Sym _1} {:Sym _4}]}]})}
  clojure: |
    (def foo (fn [& [_1 _ _ _4]] (_+ _1 _4)))


- name: Anonymous function 2
  yamlscript: |
    !yamlscript/v0
    map: \(str ((%1 / %3) + %2)) (1 .. 3)
  clojure: |
    (map (fn [& [_1 _2 _3]] (str (_+ (/ _1 _3) _2))) (rng 1 3))


- name: Default mapping semantic is a list of pairs
  yamlscript: |
    !yamlscript/v0
    a:
      b c: d
      e: f g
  build: |
    {:pairs
     ({:Sym a}
      {:pairs
       ([{:Sym b} {:Sym c}]
        {:Sym d}
        {:Sym e}
        [{:Sym f} {:Sym g}])})}
  construct: |
    {:Top
     [{:Lst
       [{:Sym a}
        {:Lst [{:Sym b} {:Sym c} {:Sym d}]}
        {:Lst [{:Sym e} {:Sym f} {:Sym g}]}]}]}
  clojure: |
    (a (b c d) (e f g))


- name: let with function call in yaml
  yamlscript: |
    !yamlscript/v0
    defn a():
      b =:
        c: d
      =>: b
  clojure: |
    (defn a [] (let [b (c d)] b))


- name: multi-let with function call in yaml
  yamlscript: |
    !yamlscript/v0
    defn tree(width):
      stars =:  \(inc(%1) * "*")
      spaces =: \(%1 * " ")
      top =:
        join:
          map:
            \(line width, %1): (width..1)
  clojure: |
    (defn
      tree
      [width]
      (let
       [stars
        (fn [& [_1]] (_* (inc _1) "*"))
        spaces
        (fn [& [_1]] (_* _1 " "))
        top
        (join (map ((fn [& [_1]] (line width _1)) (rng width 1))))]))


- name: Star operator in anonymous function
  yamlscript: |
    !yamlscript/v0
    say: \(inc(%1) * 2)
  clojure: |
    (say (fn [& [_1]] (_* (inc _1) 2)))


- name: Function call symbol ends with ?
  yamlscript: |
    !yamlscript/v0
    =>: (a? b)
  clojure: |
    (a? b)


- name: Dot path access
  yamlscript: |
    !yamlscript/v0
    =>: a.5.6.b."c d".'e f'.g(h).i().:j
  build: |
    {:pairs
     [{:Sym =>}
      {:Lst
       [{:Sym __}
        {:Sym a}
        {:Int 5}
        {:Int 6}
        {:Lst [{:Sym quote} {:Sym b}]}
        {:Str "c d"}
        {:Str "e f"}
        {:Lst [{:Sym quote} {:Lst [{:Sym g} {:Sym h}]}]}
        {:Lst [{:Sym quote} {:Lst [{:Sym i}]}]}
        {:Key :j}]}]}
  clojure: |
    (__ a 5 6 'b "c d" "e f" '(g h) '(i) :j)


- name: Switching to data mode
  yamlscript: |
    !yamlscript/v0
    d =: load("data.yaml")
    =>: !
      foo: ! d.bar
  clojure: |
    (def d (load "data.yaml"))
    {"foo" (__ d 'bar)}


- name: Switching to data mode with '::'
  yamlscript: |
    !yamlscript/v0
    d =: load("data.yaml")
    =>::
      foo:: d.bar
  clojure: |
    (def d (load "data.yaml"))
    {"foo" (__ d 'bar)}


- name: Switch modes with '::' for def/let '=::'
  yamlscript: |
    !yamlscript/v0
    nums =:: [1, 2, 3]
    =>:: {foo:: nums}
  clojure: |
    (def nums [1 2 3])
    {"foo" nums}


- name: rem operator
  yamlscript: |
    !yamlscript/v0
    =>: (a % b)
  clojure: |
    (rem a b)


- name: mod operator
  yamlscript: |
    !yamlscript/v0
    =>: (a %% b)
  clojure: |
    (mod a b)


- name: Error on % in anonymous function
  yamlscript: |
    !yamlscript/v0
    =>: \(inc(%) * 2)
  error: |
    ~~ Invalid symbol '%'. Did you mean '%1'?


- name: Support doc string in defn
  yamlscript: |
    !yamlscript/v0
    defn foo():
      =>: "This is a doc string"
      say: "Hello World"
  build: |
    {:pairs
     [[{:Sym defn} {:Sym foo} {:Str "This is a doc string"} {:Vec []}]
      {:pairs ({:Sym say} {:Str "Hello World"})}]}
  clojure: |
    (defn foo "This is a doc string" [] (say "Hello World"))


- name: Support doc string as key
  yamlscript: |
    !yamlscript/v0
    defn foo():
      "This is a doc string":
      say: "Hello World"
  clojure: |
    (defn foo "This is a doc string" [] (say "Hello World"))


- name: Error on `a+b`
  yamlscript: |
    !yamlscript/v0
    =>: a+b
  error: |-
    Invalid symbol: 'a+b'


- name: Underscore not allowed in symbol - A
  yamlscript: |
    !yamlscript/v0
    =>: (a _+ b)
  error: |-
    Invalid symbol: '_+'


- name: Underscore not allowed in symbol - B
  yamlscript: |
    !yamlscript/v0
    =>: (_+ a b)
  error: |-
    Invalid symbol: '_+'


- name: Underscore not allowed in symbol - C
  yamlscript: |
    !yamlscript/v0
    =>: (a + b_c)
  error: |-
    Invalid symbol: 'b_c'


- name: Regex literal syntax
  yamlscript: |
    !yamlscript/v0
    re1 =: /foo\t"bar".*/
  clojure: |
    (def re1 #"foo\t\"bar\".*")


- name: Regex operator
  yamlscript: |
    !yamlscript/v0
    when (a =~ b): c()
  clojure: |
    (when (=-- a b) (c))


- name: Macros for case, cond, condp
  yamlscript: |
    !yamlscript/v0
    cond:
      (a > b): c
      (a < d): e
      =>: f
  clojure: |
    (cond (> a b) c (< a d) e :else f)


- name: Single quoted string
  yamlscript: |
    !yamlscript/v0
    say: ."123" + ' let''s go'
    say: '123 let''s go'
  clojure: |
    (say (_+ "123" " let's go"))
    (say "123 let's go")


- name: String keys with empty values
  yamlscript: |
    !yamlscript/v0
    foo:
      'bar':
      "baz":
      call:
      nada::
      =>:
  clojure: |
    (foo "bar" "baz" (call) (nada nil))


- name: Interpolation in YS strings
  yamlscript: |
    !yamlscript/v0
    =>: 3 * "hi $name\n"
  clojure: |
    (_* 3 (str "hi " name "\n"))


- name: Interpolated path lookup
  yamlscript: |
    !yamlscript/v0
    =>: "Hi $(ARGS.0)!!"
  clojure: |
    (str "Hi " (__ ARGS 0) "!!")


- name: Floating point numbers
  yamlscript: |
    !yamlscript/v0
    =>: .[ 0. 0.1 -1.2e3 2.3e-4 ]
  clojure: |
    [0.0 0.1 -1200.0 2.3E-4]


- name: Exponentiation operator
  yamlscript: |
    !yamlscript/v0
    =>: a ** b
    =>: (a ** b) ** c
  clojure: |
    (pow a b)
    (pow (pow a b) c)


- name: Form indicator
  yamlscript: |
    !yamlscript/v0
    a: b
    c |: d()
    e: f
  clojure: |
    (a b)
    c
    (d)
    (e f)


- name: Single underscore as a symbol
  yamlscript: |
    !yamlscript/v0
    defn foo(a _ b):
      =>: a + b
  clojure: |
    (defn foo [a _ b] (_+ a b))


- name: Invalid symbol '__'
  yamlscript: |
    !yamlscript/v0
    __: 2
  error: |
    ~~ Invalid symbol: '__'


- name: Destructuring let
  yamlscript: |
    !yamlscript/v0
    defn foo():
      .[a b c] =: .[1 2 3]
      .{:d d :e e} =: .{:d 4 :e 5}
      =>: a + b + c
  clojure: |
    (defn
      foo
      []
      (let [[a b c] [1 2 3] {:d d, :e e} {:d 4, :e 5}] (_+ a b c)))


- name: Destructuring def not allowed
  yamlscript: |
    !yamlscript/v0
    .[a b c] =: .[1 2 3]
  error: |
    ~~ Destructured def not allowed


- name: Multi-arity defn
  yamlscript: |
    !yamlscript/v0
    defn foo:
      (): 0
      (a): a
      (a b): a + b
  clojure: |
    (defn foo ([] 0) ([a] a) ([a b] (_+ a b)))


- name: Constructing a mapping with code mode
  yamlscript: |
    !yamlscript/v0/data
    a::
      b: c
  construct: |
    {:Top [{:Map [{:Str "a"} {:Lst [{:Sym b} {:Sym c}]}]}]}
  clojure: |
    {"a" (b c)}


- name: Constructing a sequence with code mode
  yamlscript: |
    !yamlscript/v0/data
    - !
      a: b c
  construct: |
    {:Top [{:Vec [{:Lst [{:Sym a} {:Sym b} {:Sym c}]}]}]}
  clojure: |
    [(a b c)]


- name: Invalid number A
  yamlscript: |
    !yamlscript/v0
    =>: 1.2.3
  error: |
    ~~ Invalid number: 1.2.3


- name: Invalid number B
  yamlscript: |
    !yamlscript/v0
    =>: -3.foo.5
  error: |
    ~~ Invalid number: -3.foo.5


- name: Dot grouping in sub-expression
  yamlscript: |
    !yamlscript/v0
    =>: a.3.b + c.4.d
  clojure: |
    (_+ (__ a 3 'b) (__ c 4 'd))


- name: Dot grouping in dot path
  yamlscript: |
    !yamlscript/v0
    =>: a.3.b(c.4.d)
  clojure: |
    (__ a 3 '(b (__ c 4 'd)))


- name: Dot grouping in if statement
  yamlscript: |
    !yamlscript/v0
    if a.b: c.d * 3
  clojure: |
    (if (__ a 'b) (_* (__ c 'd) 3))


- name: Yes expression in sym-paren form
  yamlscript: |
    !yamlscript/v0
    =>: a(b * c)
  clojure: |
    (a (_* b c))


- name: Dot groupings in vectors
  yamlscript: |
    !yamlscript/v0
    =>: .[a.3.b(x.y),
          c.4.d]
  clojure: |
    [(__ a 3 '(b (__ x 'y))) (__ c 4 'd)]


- name: Fully qualified symbol with paren
  yamlscript: |
    !yamlscript/v0
    =>: a::b/c(d)
  clojure: |
    (a.b/c d)


- name: Dot with var lookup
  yamlscript: |
    !yamlscript/v0
    =>: a.b.$c.d(e)
  clojure: |
    (__ a 'b c '(d e))


- name: Multiple document stream
  yamlscript: |
    foo: 42
    --- !yamlscript/v0
    =>::
      bar:: _.foo.inc()
      foo: 123
    ---
    bar: 44
  clojure: |
    {"foo" 42}
    {"bar" (__ _ 'foo '(inc)), "foo" 123}
    {"bar" 44}
