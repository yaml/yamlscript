<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YAMLScript</title>
  <subtitle></subtitle>
  <link href="https://yamlscript.org/feed.xml" rel="self"/>
  <link href="https://yamlscript.org/"/>
  
    <updated>2024-06-20T00:00:00Z</updated>
  
  <id>https://yamlscript.org</id>
  <author>
    <name>Ingy döt Net</name>
    <email>ingy@yaml.com</email>
  </author>
  
    
    <entry>
      <title>Welcome to the YAMLScript Blog</title>
      <link href="https://yamlscript.org/posts/welcome-to-the-yamlscript-blog/"/>
      <updated>2023-10-26T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/welcome-to-the-yamlscript-blog/</id>
      <content type="html">
        <![CDATA[
      <p><strong>Greetings!</strong></p>
<p>Welcome to the YAMLScript blog. This is where we will introduce you to novel concepts about YAMLScript as the language evolves.</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>YAMLScript Advent 2023</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-01/"/>
      <updated>2023-12-01T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-01/</id>
      <content type="html">
        <![CDATA[
      <h3>Seasons Greetings, my YAML friends!</h3>
<p>What if I told you that you could write a <strong>program in YAML</strong> that would
generate a Christmas tree?</p>
<p>Well, you can! Here's how:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment">#!/usr/bin/env ys-0</span><br><br><span class="token key atrule">defn main(width=5)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span> tree(width)<br><br><span class="token key atrule">defn tree(width)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">top =</span><span class="token punctuation">:</span><br>    <span class="token key atrule">join "\n"</span><span class="token punctuation">:</span><br>      mapv \(line width<span class="token punctuation">,</span> %1)<span class="token punctuation">:</span> width .. 1<br><br>  <span class="token key atrule">trunk =</span><span class="token punctuation">:</span> trunk(width) * 2<br><br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token punctuation">-</span><br>    $top<br>    $trunk<br><br><span class="token key atrule">defn trunk(num)</span><span class="token punctuation">:</span> spaces(num) + "<span class="token important">*\n"</span><br><br>defn line(width<span class="token punctuation">,</span> <span class="token key atrule">num)</span><span class="token punctuation">:</span><br>  <span class="token comment"># stars is a lexically defined function</span><br>  <span class="token key atrule">stars =</span><span class="token punctuation">:</span> \(inc(%1) * '<span class="token important">*')</span><br><br>  <span class="token key atrule">join ''</span><span class="token punctuation">:</span><br>    <span class="token key atrule">spaces</span><span class="token punctuation">:</span> num<br>    <span class="token key atrule">stars</span><span class="token punctuation">:</span> (width <span class="token punctuation">-</span> num) * 2<br><br><span class="token key atrule">defn spaces(num)</span><span class="token punctuation">:</span> num * ' '<br></code></pre>
<p>Let's get a tree!</p>
<pre class="language-bash"><code class="language-bash">$ ys tree.ys<br>     *<br>    ***<br>   *****<br>  *******<br> *********<br>     *<br>     *</code></pre>
<p>That's a pretty nice tree, but it's a little small. Let's make it bigger!</p>
<pre class="language-bash"><code class="language-bash">$ ys tree.ys <span class="token number">10</span><br>          *<br>         ***<br>        *****<br>       *******<br>      *********<br>     ***********<br>    *************<br>   ***************<br>  *****************<br> *******************<br>          *<br>          *</code></pre>
<p>Welcome to the first day of YAMLScript Advent 2023!
We're going to be writing a lot of YAMLScript this month, so let's get started…</p>
<p>Wait! What is YAMLScript?</p>
<p>YAMLScript is a new programming language that uses YAML as its syntax.
You can do anything in YAMLScript that you can do in a language like
Python or JavaScript such as:</p>
<ul>
<li>Defining functions</li>
<li>Using variables</li>
<li>String manipulation and interpolation</li>
<li>Loops and conditionals</li>
<li>Importing modules</li>
<li>And more!</li>
</ul>
<p>YAMLScript looks and feels like an imperative programming language, but it's
actually a functional programming language.
This means that YAMLScript programs are made up of expressions that are
evaluated to produce a result.</p>
<p>But why would you even want to write a program in YAML?</p>
<p>YAMLScript is a full-featured, general purpose programming language, but it's
also designed to be a great language for writing YAML configuration files.
To that point, almost all YAML files are valid YAMLScript programs!
And they evaluate to the same result that a YAML loader would produce.</p>
<p>For example, here's a YAML file that defines a list of fruits:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># fruits.yaml</span><br><span class="token punctuation">-</span> apple<br><span class="token punctuation">-</span> banana<br><span class="token punctuation">-</span> cherry<br></code></pre>
<p>Let's run this file as a YAMLScript program:</p>
<pre class="language-bash"><code class="language-bash">$ ys fruits.yaml<br>$</code></pre>
<p>Nothing happens!</p>
<p>But why would anything happen? The program doesn't do anything!</p>
<p>It's the same as running this Python program:</p>
<pre class="language-python"><code class="language-python">$ python <span class="token operator">-</span>c <span class="token string">'["apple", "banana", "cherry"]'</span><br>$</code></pre>
<p>To obtain the evaluation result of a YAMLScript program, we need to use the
<code>--load</code> option:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--load</span> fruits.yaml<br><span class="token punctuation">[</span><span class="token string">"apple"</span>, <span class="token string">"banana"</span>, <span class="token string">"cherry"</span><span class="token punctuation">]</span><br>$</code></pre>
<p>We got some JSON back!
That's because by default, <code>--load</code> evaluates the YAMLScript and prints the
result as JSON.</p>
<p>What if we want to include these fruits in our YAML grocery list?
Let's try it:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># grocery.yaml</span><br><span class="token punctuation">-</span> bread<br><span class="token punctuation">-</span> <span class="token key atrule">fruits</span><span class="token punctuation">:</span> load("fruits.yaml")<br><span class="token punctuation">-</span> milk</code></pre>
<p>Let's add the <code>--yaml</code> option to print the result as YAML:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--load</span> grocery.yaml <span class="token parameter variable">--yaml</span><br>- bread<br>- fruits: load<span class="token punctuation">(</span><span class="token string">"fruits.yaml"</span><span class="token punctuation">)</span><br>- milk<br>$</code></pre>
<p>That's not what we wanted!
We wanted the contents of the fruits list to be included in the grocery list.</p>
<p>But if you think about it, this is exactly what we asked for.
Since every YAML file is a valid YAMLScript program, it certainly should be
loaded just like any other YAML loader would do it.</p>
<p>Let's fix this to do what we want:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># grocery.yaml</span><br><span class="token tag">!yamlscript/v0/data</span><br><br><span class="token punctuation">-</span> bread<br><span class="token punctuation">-</span> <span class="token key atrule">fruits</span><span class="token punctuation">:</span> <span class="token tag">!</span> load('fruits.yaml')<br><span class="token punctuation">-</span> milk<br></code></pre>
<p>Now when we run it:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-l</span> <span class="token parameter variable">-Y</span> grocery.yaml<br>- bread<br>- fruits:<br>  - apple<br>  - banana<br>  - cherry<br>- milk<br>$</code></pre>
<p>There we go! We got our fruits!</p>
<p>So what did we do here?
We added 2 things:</p>
<ul>
<li>A <code>!yamlscript/v0/data</code> tag at the top</li>
<li>A <code>!</code> tag before the <code>load</code> function call</li>
</ul>
<p>We won't get into the details of what these tags mean today, but you'll learn
about them soon enough.</p>
<h3>YAMLScript Advent 2023 Teasers</h3>
<p>My name is <a href="https://github.com/ingydotnet">Ingy döt Net</a>.
I'm one of the original creators of the <a href="https://yaml.org/">YAML data language</a> and I lead the <a href="https://yaml.org/spec/1.2.2/ext/team/">YAML Language Development Team</a>.</p>
<p>I've been working on YAMLScript for about a year now, and I'm excited to finally
share it with you.
I believe that YAMLScript is going to take YAML to exciting new places, while
remedying many of its shortcomings, limitations and frustrations.
I hope you'll come to agree as you join me on this holiday season unwrapping of
the gift that is YAMLScript!</p>
<p>I also hope that you enjoyed this first day of the <strong>YAMLScript Advent 2023</strong>!
I'll be posting a new blog article every day this month, so stay tuned!
Well at least until December 25th, but I might keep going after that. :-)</p>
<p>Here's a sneak peek of some of the things to come:</p>
<ul>
<li>Installing and using <code>ys</code> — the YAMLScript interpreter</li>
<li>The history of YAMLScript</li>
<li>How YAMLScript is compiled and evaluated</li>
<li>How YAMLScript can fix many of YAML's problems</li>
<li>How to use YAMLScript like a YAML loader in any programming language</li>
<li>Is YAMLScript actually a Lisp???</li>
<li>Refactoring complicated YAML configurations with YAMLScript</li>
<li>Writing polyglot libraries in YAMLScript</li>
<li>What makes a YAML file a valid (or invalid) YAMLScript program?</li>
<li>Compiling YAMLScript to native binaries and shared libraries</li>
</ul>
<p>Hopefully you're as excited as I am to learn more about YAMLScript!</p>
<p>See you tomorrow!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Twas a Bit</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-02/"/>
      <updated>2023-12-02T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-02/</id>
      <content type="html">
        <![CDATA[
      <blockquote>
<p>'Twas a bit before Hanukkah, and all through the igloo,<br>
not a creature was stirring, not even a frog.<br>
The stockings were hung by the window with care,<br>
In hopes that St. Krampus soon would be there.<br>
The offspring were nestled all snug in their bunks,<br>
While visions of spicy-cookies danced in their heads.<br>
And cuz in their 'kerchief, and I in my bonnet,<br>
Had just settled down for a long winter's snooze.<br>
When out on the lawn there arose such a clatter,<br>
I sprang from my bench to see what was the matter.<br>
Away to the window, I flew like a jet,<br>
Tore open the shutters and threw up the curtain.<br>
The asteroid on the breast of the new-fallen frost,<br>
Gave the lustre of mid-day to dirt below.<br>
When what to my wondering eyes should materialize?<br>
But a miniature car, and eight tiny elephants.</p>
</blockquote>
<p>Well that was a bit weird.
Let's try again.
Don't worry, it's not that hard to write Winter holiday poetry when you have
YAMLScript on your side!</p>
<h3>Welcome to day 2 of YAMLScript Advent 2023!</h3>
<p>Today we're going to write a program that generates a winter holiday poem in the
Mad Libs style.
Along the way, we'll learn about several of YAMLScript's basic language
features, including:</p>
<ul>
<li>The <code>load</code> function</li>
<li>Defining functions</li>
<li>Calling functions</li>
<li>Variables</li>
<li>Random numbers</li>
<li>String interpolation</li>
</ul>
<p>So where is this awesome YAMLScript poetry generator?
Well, it's right here, of course; wrapped up in a nice little package for you to
open and enjoy!</p>
<details><summary><strong style="color:green">Open Me!!!</strong></summary>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment">#!/usr/bin/env ys-0</span><br><span class="token comment"># twas-a-bit -- Generate a winter-holiday poem in the Mad Libs style</span><br><br><span class="token key atrule">defn main()</span><span class="token punctuation">:</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span> poem()<br><br><span class="token key atrule">data =</span><span class="token punctuation">:</span> load('a<span class="token punctuation">-</span>bit<span class="token punctuation">-</span>of<span class="token punctuation">-</span>data.ys')<br><br><span class="token key atrule">defn W(kind)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">rand-nth</span><span class="token punctuation">:</span> get(data<span class="token punctuation">,</span> name(kind))<br><br><span class="token key atrule">defn poem()</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string"><br>  'Twas a bit before $W(:holiday), and all through the $W(:place),<br>  not a creature was stirring, not even a $W(:animal).<br>  The stockings were hung by the $W(:hang-by) with care,<br>  In hopes that St. $W(:saint) soon would be there.<br>  The $W(:children) were nestled all snug in their $W(:beds),<br>  While visions of $W(:adj)-$W(:candies) danced in their heads.<br>  And $W(:relative) in their 'kerchief, and I in my $W(:hat),<br>  Had just settled down for a long winter's $W(:activity).<br>  When out on the $W(:outside) there arose such a clatter,<br>  I sprang from my $W(:seat) to see what was the matter.<br>  Away to the window, I flew like a $W(:flyer),<br>  Tore open the $W(:covers) and threw up the $W(:cover).<br>  The $W(:luminary) on the breast of the new-fallen $W(:fallers),<br>  Gave the lustre of mid-day to $W(:outers) below.<br>  When what to my wondering eyes should $W(:arrive)?<br>  But a miniature $W(:vehicle), and eight tiny $W(:service-animals).</span><br></code></pre>
</details>
<p>You can run this program with one of the following commands:</p>
<pre class="language-bash"><code class="language-bash">$ ys twas-a-bit<br><br>$ <span class="token function">chmod</span> +x twas-a-bit <span class="token operator">&amp;&amp;</span> ./twas-a-bit</code></pre>
<p>and you'll (very likely) get a different version of the poem every time you run
it!</p>
<p>You might be wondering where all the data for this poem comes from.
I hid it in a secret place... see if you can find it!</p>
<details><summary><strong style="color:red">Don't Open Me!!!</strong></summary>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># a-bit-of-data.ys -- Data for a-bit-before</span><br><br><span class="token key atrule">holiday</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>Christmas<span class="token punctuation">,</span> Hanukkah<span class="token punctuation">,</span> Kwanzaa<span class="token punctuation">,</span> Winter<span class="token punctuation">,</span> Solstice<span class="token punctuation">,</span> Yule<span class="token punctuation">,</span> Saturnalia<span class="token punctuation">]</span><br><span class="token key atrule">place</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>house<span class="token punctuation">,</span> apartment<span class="token punctuation">,</span> condo<span class="token punctuation">,</span> igloo<span class="token punctuation">,</span> cave<span class="token punctuation">,</span> castle<span class="token punctuation">,</span> mansion<span class="token punctuation">,</span> tent<span class="token punctuation">,</span> hut<span class="token punctuation">]</span><br><span class="token key atrule">animal</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>mouse<span class="token punctuation">,</span> cat<span class="token punctuation">,</span> dog<span class="token punctuation">,</span> bird<span class="token punctuation">,</span> fish<span class="token punctuation">,</span> snake<span class="token punctuation">,</span> pug<span class="token punctuation">,</span> frog<span class="token punctuation">,</span> turtle<span class="token punctuation">,</span> rabbit<span class="token punctuation">]</span><br><span class="token key atrule">hang-by</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>chimney<span class="token punctuation">,</span> fireplace<span class="token punctuation">,</span> window<span class="token punctuation">,</span> toilet<span class="token punctuation">,</span> door<span class="token punctuation">,</span> wall<span class="token punctuation">,</span> faucet<span class="token punctuation">,</span> tree<span class="token punctuation">]</span><br><span class="token key atrule">saint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>Nicholas<span class="token punctuation">,</span> Grinchy<span class="token punctuation">,</span> Krampus<span class="token punctuation">,</span> Valentines<span class="token punctuation">,</span> Jack<span class="token punctuation">,</span> Frosty<span class="token punctuation">,</span> Santa<span class="token punctuation">,</span> Bernard<span class="token punctuation">]</span><br><span class="token key atrule">children</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>children<span class="token punctuation">,</span> kids<span class="token punctuation">,</span> tots<span class="token punctuation">,</span> babies<span class="token punctuation">,</span> offspring<span class="token punctuation">,</span> spawn<span class="token punctuation">,</span> progeny<span class="token punctuation">,</span> brats<span class="token punctuation">]</span><br><span class="token key atrule">beds</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>beds<span class="token punctuation">,</span> bunks<span class="token punctuation">,</span> cots<span class="token punctuation">,</span> hammocks<span class="token punctuation">,</span> pallets<span class="token punctuation">,</span> mats<span class="token punctuation">,</span> futons<span class="token punctuation">,</span> blankets<span class="token punctuation">]</span><br><span class="token key atrule">adj</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>sweet<span class="token punctuation">,</span> sour<span class="token punctuation">,</span> salty<span class="token punctuation">,</span> bitter<span class="token punctuation">,</span> spicy<span class="token punctuation">,</span> savory<span class="token punctuation">,</span> pungent<span class="token punctuation">,</span> tart<span class="token punctuation">,</span> tangy<span class="token punctuation">]</span><br><span class="token key atrule">candies</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>candies<span class="token punctuation">,</span> chocolates<span class="token punctuation">,</span> sweets<span class="token punctuation">,</span> cookies<span class="token punctuation">,</span> cakes<span class="token punctuation">,</span> pies<span class="token punctuation">,</span> pastries<span class="token punctuation">]</span><br><span class="token key atrule">relative</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>mamma<span class="token punctuation">,</span> papa<span class="token punctuation">,</span> sis<span class="token punctuation">,</span> bro<span class="token punctuation">,</span> aunty<span class="token punctuation">,</span> uncle<span class="token punctuation">,</span> cuz<span class="token punctuation">,</span> gram<span class="token punctuation">,</span> gramps<span class="token punctuation">]</span><br><span class="token key atrule">hat</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>cap<span class="token punctuation">,</span> hat<span class="token punctuation">,</span> bonnet<span class="token punctuation">,</span> beanie<span class="token punctuation">,</span> beret<span class="token punctuation">,</span> fedora<span class="token punctuation">,</span> sombrero<span class="token punctuation">,</span> helmet<span class="token punctuation">,</span> crown<span class="token punctuation">]</span><br><span class="token key atrule">activity</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>nap<span class="token punctuation">,</span> sleep<span class="token punctuation">,</span> slumber<span class="token punctuation">,</span> snooze<span class="token punctuation">,</span> rest<span class="token punctuation">,</span> hibernation<span class="token punctuation">,</span> siesta<span class="token punctuation">,</span> doze<span class="token punctuation">]</span><br><span class="token key atrule">outside</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>lawn<span class="token punctuation">,</span> yard<span class="token punctuation">,</span> field<span class="token punctuation">,</span> forest<span class="token punctuation">,</span> woods<span class="token punctuation">,</span> jungle<span class="token punctuation">,</span> desert<span class="token punctuation">,</span> tundra<span class="token punctuation">,</span> ocean<span class="token punctuation">]</span><br><span class="token key atrule">seat</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>bed<span class="token punctuation">,</span> chair<span class="token punctuation">,</span> couch<span class="token punctuation">,</span> sofa<span class="token punctuation">,</span> futon<span class="token punctuation">,</span> hammock<span class="token punctuation">,</span> bench<span class="token punctuation">,</span> stool<span class="token punctuation">,</span> throne<span class="token punctuation">]</span><br><span class="token key atrule">flyer</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>flash<span class="token punctuation">,</span> bolt<span class="token punctuation">,</span> bullet<span class="token punctuation">,</span> rocket<span class="token punctuation">,</span> plane<span class="token punctuation">,</span> jet<span class="token punctuation">,</span> eagle<span class="token punctuation">,</span> hawk<span class="token punctuation">,</span> falcon<span class="token punctuation">]</span><br><span class="token key atrule">covers</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>shutters<span class="token punctuation">,</span> blinds<span class="token punctuation">,</span> curtains<span class="token punctuation">,</span> shades<span class="token punctuation">,</span> drapes<span class="token punctuation">,</span> screens<span class="token punctuation">,</span> panels<span class="token punctuation">]</span><br><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>shutter<span class="token punctuation">,</span> blind<span class="token punctuation">,</span> curtain<span class="token punctuation">,</span> shade<span class="token punctuation">,</span> drape<span class="token punctuation">,</span> screen<span class="token punctuation">,</span> panel<span class="token punctuation">]</span><br><span class="token key atrule">luminary</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>moon<span class="token punctuation">,</span> sun<span class="token punctuation">,</span> star<span class="token punctuation">,</span> planet<span class="token punctuation">,</span> comet<span class="token punctuation">,</span> asteroid<span class="token punctuation">,</span> meteor<span class="token punctuation">,</span> satellite<span class="token punctuation">]</span><br><span class="token key atrule">fallers</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>snow<span class="token punctuation">,</span> rain<span class="token punctuation">,</span> hail<span class="token punctuation">,</span> sleet<span class="token punctuation">,</span> ice<span class="token punctuation">,</span> slush<span class="token punctuation">,</span> frost<span class="token punctuation">,</span> dew<span class="token punctuation">,</span> fog<span class="token punctuation">,</span> mist<span class="token punctuation">]</span><br><span class="token key atrule">outers</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>trees<span class="token punctuation">,</span> bushes<span class="token punctuation">,</span> shrubs<span class="token punctuation">,</span> flowers<span class="token punctuation">,</span> grass<span class="token punctuation">,</span> weeds<span class="token punctuation">,</span> rocks<span class="token punctuation">,</span> dirt<span class="token punctuation">,</span> sand<span class="token punctuation">]</span><br><span class="token key atrule">arrive</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>appear<span class="token punctuation">,</span> arrive<span class="token punctuation">,</span> come<span class="token punctuation">,</span> materialize<span class="token punctuation">,</span> manifest<span class="token punctuation">,</span> show up<span class="token punctuation">,</span> land<span class="token punctuation">]</span><br><span class="token key atrule">vehicle</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>sleigh<span class="token punctuation">,</span> car<span class="token punctuation">,</span> truck<span class="token punctuation">,</span> van<span class="token punctuation">,</span> bus<span class="token punctuation">,</span> train<span class="token punctuation">,</span> plane<span class="token punctuation">,</span> boat<span class="token punctuation">,</span> ship<span class="token punctuation">,</span> rocket<span class="token punctuation">]</span><br><span class="token key atrule">service-animals</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>reindeer<span class="token punctuation">,</span> horses<span class="token punctuation">,</span> camels<span class="token punctuation">,</span> elephants<span class="token punctuation">,</span> oxen<span class="token punctuation">,</span> donkeys<span class="token punctuation">,</span> mules<span class="token punctuation">]</span><br></code></pre>
</details>
<h3>The <code>load</code> Function</h3>
<p>If you found the secret database you can see that it's just a YAML file.
Our YAMLScript program loads this file using the <code>load</code> function.
The <code>load</code> function is one of the most important functions in YAMLScript.
It reads a YAMLScript file, evaluates it, and returns the result.</p>
<p>But we loaded a YAML file, not a YAMLScript file.
How did that work?
Remember that (almost) every YAML file is a valid YAMLScript program, so it just
works.</p>
<p>We can also use it to load a JSON data file.
Why?
Because JSON is a subset of YAML.
That means that (absolutely) every JSON file is a valid YAML file, and therefore
every JSON file is a valid YAMLScript program!</p>
<p>The <code>load</code> function is just one of literally hundreds of core functions
available to you by default in YAMLScript.
It's part of the YAMLScript standard library.
These functions give you the ability to code anything possible in any modern
programming language.
We'll be learning more about them in the coming days.</p>
<h3>Defining Functions</h3>
<p>We defined 3 functions in our poem generator: <code>main</code>, <code>W</code>, and <code>poem</code>.
We did this using <code>defn</code>, which is short for &quot;define function&quot;.</p>
<p>Here's a simple function that tells you how far away you are from the answer to
life, the universe, and everything:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn how-far-away(n)</span><span class="token punctuation">:</span> abs(42 <span class="token punctuation">-</span> n)</code></pre>
<p>In YAML terms this is a mapping pair whose key is a plain (unquoted) string
containing <code>defn</code>, the function name, and the function parameters.
The mapping pair's value is the function body, which is a YAMLScript expression.</p>
<p>A YAMLScript function returns the value of its last evaluated expression.</p>
<h3>Calling Functions</h3>
<p>There are a lot of ways to call a function in YAMLScript.
In fact, there are a lot of ways to do almost everything in YAMLScript.
The only hard and fast rule is that the entire program must be valid YAML.</p>
<p>Consider this expression:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">map inc</span><span class="token punctuation">:</span> range(1<span class="token punctuation">,</span> 10)</code></pre>
<p>Here we are calling 2 functions: <code>map</code> and <code>range</code>.
Another way to write this would be:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">map inc</span><span class="token punctuation">:</span><br>  <span class="token key atrule">range</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span></code></pre>
<p>or:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">=></span><span class="token punctuation">:</span> map(inc<span class="token punctuation">,</span> range(1<span class="token punctuation">,</span> 10))</code></pre>
<p>or:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">->></span><span class="token punctuation">:</span> range(1<span class="token punctuation">,</span> 10)<span class="token punctuation">,</span> map(inc)</code></pre>
<p>There's actually many more ways to write this, but this is only day 2 of
YAMLScript Advent 2023, so we'll save those for later.</p>
<p>In general, these 2 forms are equivalent:</p>
<pre class="language-yaml"><code class="language-yaml">a b<span class="token punctuation">,</span> <span class="token key atrule">c</span><span class="token punctuation">:</span> d<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<br><span class="token punctuation">---</span><br>a(b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f)</code></pre>
<p>In YAMLScript, a function call is either a mapping pair or a scalar.
When it is a mapping pair, the key and the value can both have 1 or more
expressions.
The first expression on the key side is the function name and all the rest of
the expressions on both sides are the function arguments.
When it is a scalar, a function name is followed by a parenthesized list of
arguments.
Note that the opening parenthesis must immediately follow the function name
without any intervening whitespace.</p>
<p>You may have noticed a few more functions just now: <code>inc</code>, <code>=&gt;</code>, and <code>-&gt;&gt;</code>.
Well, <code>inc</code> is a function but we didn't call it directly.
We passed it as an argument to the <code>map</code> function.</p>
<p>I'll tell you about <code>=&gt;</code> and <code>-&gt;&gt;</code> later.</p>
<blockquote>
<h3>Comma Chameleon</h3>
<p>I was going to save this for later, but I just can't wait...</p>
<p><strong>Commas are a Lie!</strong></p>
<p>In YAMLScript, commas are optional whitespace.
You can use them to make your code more readable, if that's your thing.
It's not my thing, so I won't use them much from here on out.</p>
</blockquote>
<h3>Variables</h3>
<p>One of my favorite things about YAMLScript is that you can use any word as a
variable or function name.
We call these names &quot;symbols&quot;.</p>
<p>For example almost every language has an <code>if</code> keyword, and (since it is a
special keyword) you can't use it for a name.
In YAMLScript you are free to use the <code>if</code> symbol (as a variable or function
name) as long as you don't need to use the standard <code>if</code> function in the same
scope.</p>
<p>We assign a value to a variable like so:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">foo =</span><span class="token punctuation">:</span> <span class="token number">42</span></code></pre>
<p>This is a mapping pair whose key is a plain string containing the variable name
followed by <code>=:</code> separated by at least one space character.
The pair value is the assignment value.
Simple!</p>
<h3>Strings</h3>
<p>If you know your YAML, you know that YAML has 5 different styles to represent
a scalar value (a string, number, boolean, etc).
The styles are called &quot;plain&quot; (unquoted), &quot;single-quoted&quot;, &quot;double-quoted&quot;,
&quot;literal&quot;, and &quot;folded&quot;.
Plain scalar turns strings, numbers, booleans, etc.
The other 4 styles are always strings.</p>
<p>In YAMLScript code, the scalar style is very important.
Symbols and expressions are always plain scalars.
The 4 other styles are used for strings.</p>
<h3>Random Numbers</h3>
<p>We used the <code>rand-nth</code> function to select a random value from a list.
Not much to say about that, except that it's a function that takes a list as an
argument and returns a random value from it.</p>
<h3>String Interpolation</h3>
<p>YAMLScript strings written in the &quot;single-quoted&quot; or &quot;folded&quot; styles are just
strings, but when you use the &quot;double-quoted&quot; or &quot;literal&quot; styles, the strings
have interpolation super powers!</p>
<p>Interpolation is the process of inserting the value of variables or expressions
into a string in the place where they appear.
In YAMLScript, these expanding objects are indicated by a <code>$</code> character
immediately followed by the variable or expression.</p>
<p>This is pretty much the same as string interpolation in a shell like Bash:</p>
<pre class="language-bash"><code class="language-bash"><span class="token assign-left variable">name</span><span class="token operator">=</span>World<br><span class="token builtin class-name">echo</span> <span class="token string">"Hello <span class="token variable">$name</span>. The answer is <span class="token variable"><span class="token variable">$((</span><span class="token number">43</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token variable">))</span></span>."</span></code></pre>
<p>The equivalent YAMLScript code would be:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">name =</span><span class="token punctuation">:</span> <span class="token string">'World'</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello $name. The answer is $(43 - 1)."</span></code></pre>
<p>You can also interpolate a YAMLScript function call (symbol followed by argument
list) like this:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello $inc(41)."</span></code></pre>
<p>In most languages that support interpolation <code>inc</code> would expand as a variable,
but in YAMLScript it's a function and the parenthesized argument list is part of
the expression.</p>
<p>This is the kind of interpolation syntax we used in our poem generator program.</p>
<h3>Conclusion</h3>
<p>Well that wraps up day 2 of the YAMLScript Advent 2023.
I hope you enjoyed it, and learned a bit more about YAMLScript.</p>
<p>Honestly, at this point you probaby have more questions than answers.
Luckily for you, December has more than 2 days in it.
See you tomorrow!</p>
<p>I'll leave you with a little poem that a close friend of mine just wrote:</p>
<blockquote>
<p>'Twas a bit before Winter, and all through the hut,<br>
not a creature was stirring, not even a snake.<br>
The stockings were hung by the faucet with care,<br>
In hopes that St. Frosty soon would be there.<br>
The tots were nestled all snug in their bunks,<br>
While visions of pungent-candies danced in their heads.<br>
And uncle in their 'kerchief, and I in my fedora,<br>
Had just settled down for a long winter's rest.<br>
When out on the lawn there arose such a clatter,<br>
I sprang from my sofa to see what was the matter.<br>
Away to the window, I flew like a bullet,<br>
Tore open the panels and threw up the blind.<br>
The planet on the breast of the new-fallen snow,<br>
Gave the lustre of mid-day to flowers below.<br>
When what to my wondering eyes should materialize?<br>
But a miniature train, and eight tiny oxen.</p>
</blockquote>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Load em Up!</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-03/"/>
      <updated>2023-12-03T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-03/</id>
      <content type="html">
        <![CDATA[
      <blockquote>
<p>On the 3rd day of Advent, my YS gave to me...<br>
A sequence in a map tree!</p>
</blockquote>
<p>Did you know that all JSON <em>is</em> YAML?
You should, because I told you that <a href="/posts/advent-2023/dec-02/">yesterday</a>!</p>
<p>It's true.
YAML is a superset of JSON.
Both in terms of syntax and data model.</p>
<p>This means that any possible valid JSON input is also valid as a YAML input.
A proper YAML loader and a JSON loader should produce the same data structure
from the same JSON input.</p>
<blockquote>
<p>Assuming a YAML 1.2 loader using the YAML 1.2 JSON Schema</p>
</blockquote>
<h3>Welcome to day 3 of YAMLScript Advent 2023!</h3>
<p>This YAML/JSON relationship has some interesting implications for people
interacting with systems that read YAML or JSON as input.</p>
<p>People often prefer to read or write data in YAML because it's more
human-friendly with its structured indentation, lack of excessive punctuation
and its support for comments.
JSON is more machine-friendly due to its simplicity and robust tooling, thus
often prererable for machine-to-machine communication.</p>
<p>It's quite common to see people configure their systems that have JSON inputs by
using YAML instead, and setting things up to convert the hand maintained YAML to
JSON before the system sees it.
It can also be helpful to format large JSON API responses as YAML so that they
are easier to read.</p>
<p>Going the other way, people can refactor large YAML configurations by first
converting them to JSON, using JSON tools like <code>jq</code> to manipulate the data and
then converting the data back to YAML.</p>
<p>YAMLScript is an ideal technology for performing these kinds of conversions and
manipulations.</p>
<h3>Loading vs Running YAMLScript</h3>
<p>On one hand, YAMLScript is a complete programming language that you can use for
writing new applications (and libraries).
In YAMLScript jargon, we &quot;run&quot; these applications.
We'll discuss YAMLScript apps and &quot;running&quot; them extensively in the coming days.</p>
<p>Today we are covering YAMLScript's purpose we just described: reading YAML
files into data; possibly transforming the data dynamically along the way.</p>
<p>This use of YAMLScript is called &quot;loading&quot; and can be done on most existing YAML
files and all existing JSON files.</p>
<details><summary>What does "most" mean?</summary>
<p>When I say &quot;most YAML input files&quot; I mean YAML input that fits into the JSON
data model.
Almost all YAML files used for configuration purposes fall into this category.</p>
<p>Specifically:</p>
<ul>
<li>Mapping keys must be strings.</li>
<li>Aliases may not create circular references.</li>
<li>Custom tags (those beyond the YAML 1.2 JSON Schema) must not be used.</li>
</ul>
<p>I've never seen any of those things used in a configuration file.</p>
<hr>
</details>
<p>Let's look at an example.</p>
<p>YAML uses the term &quot;load&quot; to refer to the process of a computer program
converting a YAML text into a data structure in memory.
It is common for a YAML framework to have a <code>load</code> (and <code>dump</code>) function or
method as its primary API.</p>
<p>Here's a Python single line program that loads a YAML text into a Python
dictionary and and then prints it.</p>
<pre class="language-bash"><code class="language-bash">$ python <span class="token parameter variable">-c</span> <span class="token string">'import yaml; print(yaml.safe_load("Advent day: 3"))'</span><br><span class="token punctuation">{</span><span class="token string">'Advent day'</span><span class="token builtin class-name">:</span> <span class="token number">3</span><span class="token punctuation">}</span></code></pre>
<p>YAMLScript has a Python binding that does the same thing:</p>
<pre class="language-bash"><code class="language-bash">$ python <span class="token parameter variable">-c</span> <span class="token string">'from yamlscript import YAMLScript; print(YAMLScript().load("Advent day: 3"))'</span><br><span class="token punctuation">{</span><span class="token string">'Advent day'</span><span class="token builtin class-name">:</span> <span class="token number">3</span><span class="token punctuation">}</span></code></pre>
<p>It also has these bindings in many other programming languages and plans to have
them in all modern programming languages.</p>
<p>A major goal of the YAMLScript project is to have these YAMLScript binding
libraries be the best way to load YAML config files in all modern programming
languages.
This will be a big improvement over the current situation where every YAML
framework has its own API and its own set of bugs and quirks.</p>
<h3>Loading YAMLScript from the Command Line</h3>
<p>We can also load YAMLScript outside of any programming language.</p>
<p>We can do it from the command line using the <code>ys</code> command with the <code>--load</code>
option.</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-le</span> <span class="token string">'Advent day: 3'</span><br><span class="token punctuation">{</span><span class="token string">"Advent day"</span><span class="token builtin class-name">:</span> <span class="token number">3</span><span class="token punctuation">}</span></code></pre>
<blockquote>
<p>Note: The <code>-le</code> option is a short for <code>-l</code> (short for <code>--load</code>) and <code>-e</code>
(short for `--eval).</p>
</blockquote>
<p>Since the command line doesn't have any way to store the loaded YAML (like a
programming language would as a data structure) we have to get it back as text.
By default, <code>ys</code> prints the loaded YAML as JSON.</p>
<p>That may seem strange; a YAML loader defaulting to JSON.
But it's not strange at all, for two reasons:</p>
<ul>
<li>JSON <em>is</em> YAML. Remember?!</li>
<li>JSON is the de facto Lingua Franca of inter-program communication.</li>
</ul>
<p>Put another way, <code>ys</code> outputs YAML in its most compatible format.</p>
<p>In a programming language, we load YAML data into an object and pass it to some
function to do something with it.
In the CLI-as-programming-language analogy, the functions are other programs!</p>
<h3>Loading YAML Dynamically</h3>
<p>The main point of today's post is to show how YAMLScript can be used as a normal
YAML loader.
But of course, YS has SuperPowers™ that other YAML loaders don't have.</p>
<blockquote>
<p>NOTE: From now on I will sometimes use &quot;YS&quot; as shorthand for &quot;YAMLScript&quot;.
This is distinct from <code>ys</code> which is the command-line tool that runs/loads YS.</p>
</blockquote>
<p>With great SuperPowers comes SuperResponsibility.
YS won't use its SuperPowers unless you ask it to.
You may ask it (politely) in one of these ways:</p>
<ul>
<li>Start the YS with the <code>!yamlscript/v0</code> tag
<ul>
<li>Words are commands by default</li>
</ul>
</li>
<li>Start the YS with the <code>!yamlscript/v0/data</code> tag
<ul>
<li>Words are data by default</li>
</ul>
</li>
<li>Use a <code>ys-0</code> shebang line like: <code>#!/usr/bin/env ys-0</code>
<ul>
<li>Implicitly defaults to <code>!yamlscript/v0</code></li>
</ul>
</li>
<li>Use the <code>-e</code> option for YS one-liners
<ul>
<li>Imlicitly defaults to <code>!yamlscript/v0</code> (for one-liner convenience)</li>
</ul>
</li>
</ul>
<p>After that you are good to go!</p>
<p>Imagine we have YAML files containing top level mappings such as:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># map1.yaml</span><br><span class="token key atrule">reindeer</span><span class="token punctuation">:</span><br><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Dancer<br><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Blitzen<br><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Rudolph<br>  <span class="token key atrule">nosy</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre>
<p>We can pull data from these files into our YAML dynamically:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># file1.ys</span><br><span class="token tag">!yamlscript/v0/data</span><br><br><span class="token key atrule">key1</span><span class="token punctuation">:</span> val1<br><span class="token key atrule">key2</span><span class="token punctuation">:</span> <span class="token tag">!</span> load('map1.yaml')<br><span class="token key atrule">key3</span><span class="token punctuation">:</span> val3</code></pre>
<p>Now if we &quot;ran&quot; the YS nothing would happen, but when we &quot;load&quot; it, we get the
data we expect.</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--load</span> file1.ys<br><span class="token punctuation">{</span><span class="token string">"key1"</span><span class="token builtin class-name">:</span> <span class="token string">"val1"</span>, <span class="token string">"key2"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span><span class="token string">"reindeer"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"Dancer"</span><span class="token punctuation">}</span>, <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"Blitzen"</span><span class="token punctuation">}</span>, <span class="token punctuation">{</span><span class="token string">"name"</span><span class="token builtin class-name">:</span> <span class="token string">"Rudolph"</span>, <span class="token string">"nosy"</span><span class="token builtin class-name">:</span> true<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span>, <span class="token string">"key3"</span><span class="token builtin class-name">:</span> <span class="token string">"val3"</span><span class="token punctuation">}</span></code></pre>
<p>Now I can explain those pesky YAML tags!
What does this YS mapping pair mean?</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token number">123</span></code></pre>
<p>Well, it depends.
It could be a command to print the number 123 as text to the console.
Or it could be a mapping pair with the key <code>say</code> and the value <code>123</code>.
The starting tag tells us which it is.
The <code>!yamlscript/v0</code> tag means that we start off things in a state where plain
(unquoted) YAML scalars are code.
OTOH, with <code>!yamlscript/v0/data</code> these scalars are data like in normal YAML.</p>
<p>The <code>!</code> tag is how we switch back and forth (toggle) between these two states.
If you have existing YAML files and you want to use a couple of YS functions in
them, start them with <code>!yamlscript/v0/data</code> and then use <code>!</code> tags before the
functional parts.</p>
<p>Another way to accomplish the same result is:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># file2.ys</span><br><span class="token tag">!yamlscript/v0</span><br><br><span class="token key atrule">map1 =</span><span class="token punctuation">:</span> load('map1.yaml')<br><br><span class="token key atrule">=></span><span class="token punctuation">:</span><br>  .<span class="token punctuation">{</span><br>    <span class="token punctuation">:</span>key1 "val1"<br>    <span class="token punctuation">:</span>key2 map1<br>    <span class="token punctuation">:</span>key3 "val3"<br>  <span class="token punctuation">}</span></code></pre>
<p>Here everything is code, and the final expression is the data we want to load.
When you run <code>ys --load file2.ys</code> you get the same result as before.</p>
<blockquote>
<p>Note: The things starting with <code>:</code> are called keywords, and they turn into one
word strings on output.
More on keywords another day.</p>
</blockquote>
<h3>Merging Mappings and Joining Sequences</h3>
<p>I'll leave you with the two most frequent requests that Santa gets from YAML
kids: <code>merge</code> and <code>concat</code>.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># file3.ys</span><br><span class="token tag">!yamlscript/v0/data</span><br><br><span class="token key atrule">my-map</span><span class="token punctuation">:</span> <span class="token tag">!</span><br>  <span class="token key atrule">merge</span><span class="token punctuation">:</span><br>    load('map1.yaml')<br>    load('map2.yaml')<br><span class="token key atrule">my-seq</span><span class="token punctuation">:</span> <span class="token tag">!</span><br>  <span class="token key atrule">concat</span><span class="token punctuation">:</span><br>    load('seq1.yaml')<br>    load('seq2.yaml')</code></pre>
<p>When we were inventing YAML 20 years ago, one of the most confusing things we
did was to suggest that <code>&lt;&lt;</code> used as a key could trigger a merge operation.</p>
<p>It wasn't a good idea because:</p>
<ul>
<li>It's the only dynamic thing we put in YAML</li>
<li>It actually wasn't in the spec proper</li>
<li>It's not well defined at all</li>
<li>Many YAML frameworks don't support it at all</li>
<li>The ones that do it, all do it differently</li>
</ul>
<p>But people love it, and they want more!</p>
<p>Well... YS gives you more.
100s more (standard functions) in fact!
(All in good time, my patient Advent-urers.)</p>
<p>Let's end this day by making that last YS file even cooler than Rudolph's toes!</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0/data</span><br><br><span class="token key atrule">my-map</span><span class="token punctuation">:</span> <span class="token tag">!</span> load('map1.yaml') + load('map2.yaml')<br><span class="token key atrule">my-seq</span><span class="token punctuation">:</span> <span class="token tag">!</span> load('seq1.yaml') + load('seq2.yaml')</code></pre>
<p>YAMLScript's <code>+</code> operator is a general purpose joiner.
It's polymorphic for numbers, strings, sequences and mappings.</p>
<p>As ususal, I hope you enjoyed today's post.
I'll see you tomorrow for day 4 of YAMLScript Advent 2023!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Santa&#39;s Big Secret</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-04/"/>
      <updated>2023-12-04T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-04/</id>
      <content type="html">
        <![CDATA[
      <p>I've got a little secret to tell you.
I've been hiding a little something from you.
Even that's a lie.
I've actually been hiding something very very big something from you.</p>
<blockquote>
<h3>*** YAMLScript is a Lisp! *****</h3>
</blockquote>
<h3>Welcome to day 4 of YAMLScript Advent 2023!</h3>
<p>Today is Monday and Monday's are made for big headlines.</p>
<p>That's right.
Not only is YAMLScript a Lisp, it's a very specific and modern Lisp.
It's a Lisp that has a community and conferences and books and jobs and that pay
people to write code in Lisp!</p>
<p>If you know the slightest thing about Lisp, you must think I'm crazy.
YAMLScript is YAML, and YAML is no Lisp.
It's almost the Anti-Lisp incarnate.</p>
<p>OK. Here's the deal...</p>
<blockquote>
<h3>YAMLScript <em>is</em> Clojure</h3>
</blockquote>
<p>There you go. The secret is out.
Every YAMLScript program is program is a Clojure program.</p>
<p>Every time you run (or load!) a YAMLScript program, it compiles to Clojure code
that is then run by a Clojure runtime engine.
I can prove it!</p>
<p>Consider this YAMLScript program:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># hw.ys</span><br><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">println</span><span class="token punctuation">:</span> <span class="token string">'Hello, world!'</span></code></pre>
<p>Let's run it:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--run</span> hw.ys<br>Hello, world<span class="token operator">!</span></code></pre>
<p>No surprises there.
Now let's first compile it to Clojure:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--compile</span> hw.ys<br><span class="token punctuation">(</span>println <span class="token string">"Hello, world!"</span><span class="token punctuation">)</span></code></pre>
<p>Looks pretty Lispy to me.
Now let's run the Clojure code:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> hw.ys <span class="token operator">|</span> clojure -<br>Hello, world<span class="token operator">!</span></code></pre>
<p>It works!
YAMLScript really <em>is</em> Clojure.
And Clojure most definitely <em>is</em> a Lisp.
Soooooo...?!
Yeah, you get it. QED, baby!</p>
<h3>What is Clojure?</h3>
<p>Oh wait, you don't know what Clojure is?
Or maybe you need a quick refresher?</p>
<p>Clojure is a modern Lisp that runs on the JVM.
It was created by this really interesting guy named <a href="https://en.wikipedia.org/wiki/Rich_Hickey">Rich Hickey</a> whom I've actually met many times...</p>
<p>...on YouTube.</p>
<p>I don't typically watch a lot of programming videos, but I've seen at least a
dozen of his.
I encourage you to watch some too.
Or at least peruse some of his <a href="https://gist.github.com/reborg/dc8b0c96c397a56668905e2767fd697f">various opinions on varying programming topics</a></p>
<p>Rich programmed professionally in Java for many years.
One day he decided that he couldn't take it anymore.
He took a couple years off and he changed the world.
The Java world anyway.</p>
<p>Java is a widely used imperative programming language, with mutable data
structures and a noisy syntax.
Clojure by contrast is a functional programming language, with immutable data
structures and a very clean syntax.
You can use any Java library directly from Clojure and vice versa, making
Clojure an extremely practical language.</p>
<p>In a phrase: <strong>&quot;Clojure makes Java not suck&quot;</strong>. (Ingy's words, not Rich's)</p>
<h3>What does this all have to say about YAMLScript?</h3>
<p><strong>Yesterday we learned that all JSON is YAML and that almost all YAML is
YAMLScript.
Does this means that all JSON is Clojure?</strong></p>
<p>Actually it kind of does.</p>
<p>Let's compile some JSON with <code>ys</code>:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-md</span> <span class="token parameter variable">-ce</span> <span class="token string">'{ "foo": "bar", "baz": [1, 2, null, true] }'</span><br><span class="token punctuation">{</span><span class="token string">"foo"</span> <span class="token string">"bar"</span>, <span class="token string">"baz"</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> nil true<span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>
<p>Yep. That's Clojure.
It also happens to be EDN, which is Clojure's native data format.</p>
<blockquote>
<p>Note: The <code>-md</code> option tells <code>ys</code> not to add the <code>!yamlscript/v0</code> tag that it
usually does with <code>-e</code> to make your YS life easier.
We'll learn more about <code>-m</code> another time.</p>
</blockquote>
<p><strong>Lisp puts parentheses around everything.
Does that mean that YAMLScript does too?</strong></p>
<p>Good question. The answer may surprise you.
YAMLScript has a lot of different ways to express code.
It embraces diversity. (As long as that diversity can be written as YAML!)
One of the ways to write code in YAMLScript is in Clojure syntax!</p>
<p>This YAMLScript prints 3 symbol names available in the current namespace:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-e</span> <span class="token string">'(say (take (+ 1 2) (keys (ns-map NS))))'</span><br><span class="token punctuation">(</span>+' decimal? sort-by<span class="token punctuation">)</span></code></pre>
<p>In Lisp every expression (function call) is a paranthesized list where the first
word is the function name and the rest are the arguments.
That means arithmetic expressions like <code>1 + 2</code> are written as <code>(+ 1 2)</code>.</p>
<p>This feels very natural to Lisp programmers, but it can be a bit of a shock to
the rest of us.
YAMLScript offers alternate ways (called ysexprs or YeS Expressions) to write
these Lisp basic forms.</p>
<p>We'll learn the gritty details in another post, but here's the basics:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">=></span><span class="token punctuation">:</span> 1 + 2               <span class="token comment"># (+ 1 2)   ;; + - * /</span><br><span class="token key atrule">=></span><span class="token punctuation">:</span> 3 * 4 * 5           <span class="token comment"># (* 3 4 5) ;; if operators are the same</span><br><span class="token key atrule">=></span><span class="token punctuation">:</span> foo(bar(42 true))   <span class="token comment"># (foo (bar 42 true))</span></code></pre>
<p>We could write the above YAMLScript expression like this:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">say</span><span class="token punctuation">:</span><br>  <span class="token key atrule">take (+</span><span class="token punctuation">:</span> <span class="token key atrule">1 2)</span><span class="token punctuation">:</span><br>    <span class="token key atrule">keys</span><span class="token punctuation">:</span> ns<span class="token punctuation">-</span>map(NS)</code></pre>
<p>Both YAMLScript forms compile to the same Clojure code.</p>
<p>Basically at any level of YAML in YAMLScript, you can switch to using Clojure.
Since an entire YAML document can be a single string you can sometimes use an
entire Clojure file as a YAMLScript program.
As long as it's valid YAML, of course.</p>
<p><strong>Clojure is a JVM Language.
Does that mean that YAMLScript is a JVM language?</strong></p>
<p>This one is crazy.
YAMLScript does not need the JVM or anything Java whatsoever.
The <code>ys</code> binary is a native machine code executable.
The <code>libyamlscript</code> shared library is also native machine code and thus can be
FFI bound to almost any programming language.</p>
<p>You don't even need to have Java installed on your system to <em>build</em> YAMLScript.
That's a little fib.
The build system always downloads a Java build system and then discards it when
it's done.
The point is that to build <code>ys</code> you don't need to set up any prerequisites.
It just works.</p>
<p>How is this possible?
It's all thanks to <a href="https://www.graalvm.org/">GraalVM</a> which is, as one of my YS
friends puts it, &quot;a cheat code&quot;!
GraalVM's <code>native-image</code> compiler can magically turn anything Java into native
machine code on Linux, macOS and Windows.
<strong>Wow!</strong></p>
<p>A very noticeable difference between YAMLScript and Clojure is startup time:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">time</span> ys <span class="token parameter variable">-e</span> <span class="token number">1</span><br>real    0m0.044s<br>$ <span class="token function">time</span> perl <span class="token parameter variable">-e</span> <span class="token number">1</span>    <span class="token comment"># for comparison</span><br>real    0m0.048s<br>$ <span class="token function">time</span> clojure <span class="token parameter variable">-M</span> <span class="token parameter variable">-e</span> <span class="token number">1</span><br><span class="token number">1</span><br>real    0m0.637s</code></pre>
<p>Clojure's not 10 times slower than YS (or Perl).
It just takes 10 times longer to start up a JVM.</p>
<p><strong>Do you need to know Clojure to use YAMLScript?</strong></p>
<p>No, not at first.
Proof?
I just got through 3 days of YAMLScript Advent without mentioning Clojure once.</p>
<p>If you just want to make your out of control YAML files more manageable,
composable and maintainable, you can easily learn how to wield YAMLScript
without knowing a lick of Clojure.</p>
<p>When you need more power it's there for you because Clojure is there for you.
But you have to learn some new things first.</p>
<p>I honestly think YS can be a great introduction to Clojure.
I think that Clojure is a great introduction to Lisp, working with immutable
data structures, and functional programming.
And I think that learning these things will make you a better programmer in
whatever language you use.</p>
<p>YAML has always been about making things easier in all programming languages.
My love for Clojure is that it has the right parts to make YAML more powerful
in all those same languages.
I have no desire to see the whole world switch to Clojure (or anything else).
Clojure is a great gift and I hope YS can help more people benefit from it in
the languages and technologies they already use.</p>
<p><strong>How does YAMLScript benefit from building over Clojure?</strong></p>
<p>In a nutshell, it makes YAMLScript a complete, robust, battle tested, and
well-documented language from the get go.
Rich knew that to make a new language in 2006 he needed to build on something
that was already a big deal; the Java ecosystem.</p>
<p>I feel the exact same way about YAMLScript.</p>
<p>YAMLScript is poised to take YAML to a whole new level.
This is all thanks to the shoulders of these specific giants:</p>
<ul>
<li><a href="https://yaml.org/">YAML</a></li>
<li><a href="https://clojure.org/">Clojure</a></li>
<li><a href="https://bitbucket.org/asomov/snakeyaml/src/master/">SnakeYAML</a></li>
<li><a href="https://github.com/babashka/sci">Small Clojure Interpreter (SCI)</a></li>
<li><a href="https://www.graalvm.org/">GraalVM</a></li>
</ul>
<p>I'll have more to say about each of these in future posts.
For now, I'll just say that I'm extremely grateful for all of them.</p>
<p>I'll see you tomorrow for day 5 of YAMLScript Advent 2023!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Unwrapping Gifts</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-05/"/>
      <updated>2023-12-05T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-05/</id>
      <content type="html">
        <![CDATA[
      <p>It's certainly a relief now that I've told you the big secret about YAMLScript.
Now that you know that YAMLScript is really Clojure, I don't have to dance
around the subject anymore.
I didn't want to scare you away by going Full-Lisp on you from the start!</p>
<p>Now we can just get into it.
We can write, run and load YAMLScript until the cows come home.</p>
<p>But wait... How do we do that?
You don't even have YS installed yet!</p>
<h3>Welcome to Day 5 of the YAMLScript Advent Calendar</h3>
<p>Today we're going to learn how to install YAMLScript a couple different ways.</p>
<p>Luckily for you I just finished creating the <a href="https://github.com/yaml/yamlscript/releases/tag/0.1.20">first official YAMLScript
release</a>.
What a coincidence!</p>
<p>At he moment there are only releases published for Linux x86_64 and macOS
aarch64.
If you happen to be running on one of those platforms, you can run the following
command to install YAMLScript's CLI, <code>ys</code>:</p>
<blockquote>
<p>UPDATE: Releases are now available for Linux and macOS on both x86_64 and
aarch64 (for either). See the <a href="https://github.com/yaml/yamlscript/releases/">YAMLScript Releases Page</a></p>
</blockquote>
<pre class="language-bash"><code class="language-bash"><span class="token function">curl</span> https://yamlscript.org/install <span class="token operator">|</span> <span class="token function">bash</span></code></pre>
<p>This installer defaults to installing <code>ys</code> into <code>~/.local/bin</code>, unless you run
it as root in which case it defautlls to <code>/usr/local/bin</code>.</p>
<p>If you want to install it somewhere else, like say <code>~/local/bin</code>, you can do:</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">curl</span> https://yamlscript.org/install <span class="token operator">|</span> <span class="token assign-left variable">PREFIX</span><span class="token operator">=~</span>/local <span class="token function">bash</span></code></pre>
<p>Wherever you install it, make sure that the <code>$PREFIX/bin</code> directory is in your
<code>PATH</code> environment variable.</p>
<p>YAMLScript also provides a release for <code>libyamlscript.so</code>, the YAMLScript shared
library.
You can install it like above but with (some variation of):</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">curl</span> https://yamlscript.org/install <span class="token operator">|</span> <span class="token function">bash</span></code></pre>
<p>We'll be using the shared library soon when we start playing around with using
YAMLScript from other programming languages.</p>
<h3>Building from Source</h3>
<p>The most reliable way to install YAMLScript is to build it from source.
We've put a lot of effort into making this as easy as possible.
You don't need any special prerequisites; just git, bash, curl and make.</p>
<p>The first thing you need to do is clone the YAMLScript repo:</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/yaml/yamlscript</code></pre>
<p>Then you can build and install the CLI with:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> yamlscript<br>$ <span class="token function">make</span> build<br>$ <span class="token function">make</span> <span class="token function">install</span><br>or<br>$ <span class="token function">make</span> <span class="token function">install</span> <span class="token assign-left variable">PREFIX</span><span class="token operator">=</span><span class="token punctuation">..</span>.</code></pre>
<p>The <code>make install</code> command will install both <code>ys</code> and <code>libyamlscript.so</code> into
<code>$PREFIX/bin</code> and <code>$PREFIX/lib</code> respectively.</p>
<p>YAMLScript has a pretty sophisticated build system, built around GNU Make.
Even though the build uses Java, Clojure and GraalVM, you don't need to install
any of those things.
In fact, even if you have them installed, the build will ignore them.</p>
<h3>Running YAMLScript</h3>
<p>Now that you have YAMLScript installed, you can run it.
Try:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--help</span></code></pre>
<p>It should display:</p>
<pre class="language-text"><code class="language-text">ys - The YAMLScript (YS) Command Line Tool - v0.1.63<br><br>Usage: ys [<option...>] [<file>]<br><br>Options:<br><br>      --run                Run a YAMLScript program file (default)<br>  -l, --load               Output (compact) JSON of YAMLScript evaluation<br>  -e, --eval YSEXPR        Evaluate a YAMLScript expression<br>                           multiple -e values joined by newline<br><br>  -c, --compile            Compile YAMLScript to Clojure<br>  -b, --binary             Compile to a native binary executable<br><br>  -p, --print              Print the result of --run in code mode<br>  -o, --output FILE        Output file for --load, --compile or --binary<br><br>  -T, --to FORMAT          Output format for --load:<br>                             json, yaml, edn<br>  -J, --json               Output (pretty) JSON for --load<br>  -Y, --yaml               Output YAML for --load<br>  -E, --edn                Output EDN for --load<br><br>  -m, --mode MODE          Add a mode tag: code, data, or bare (for -e)<br>  -C, --clojure            Treat input as Clojure code<br><br>  -d                       Debug all compilation stages<br>  -D, --debug-stage STAGE  Debug a specific compilation stage:<br>                             parse, compose, resolve, build,<br>                             transform, construct, print<br>                           can be used multiple times<br>  -S, --stack-trace        Print full stack trace for errors<br>  -x, --xtrace             Print each expression before evaluation<br><br>      --install            Install the libyamlscript shared library<br>      --upgrade            Upgrade both ys and libyamlscript<br><br>      --version            Print version and exit<br>  -h, --help               Print this help and exit</code></pre>
<p>In the next day or two we'll go over all of these options in detail.</p>
<p>Here's a quick example of how to run YAMLScript to process a file from the
internet that Google just told me about:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">curl</span> https://gist.githubusercontent.com/chriscowley/8598119/raw/8f671464f914320281e5e75bb8dcbe11285d21e6/nfs.example.lan.yml <span class="token operator">|</span><br>ys <span class="token parameter variable">-J</span> - <span class="token operator">|</span> jq .classes<br><span class="token punctuation">{</span><br>  <span class="token string">"nfs::server"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span><br>    <span class="token string">"exports"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><br>      <span class="token string">"/srv/share1"</span>,<br>      <span class="token string">"/srv/share3"</span><br>    <span class="token punctuation">]</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>The special file name <code>-</code> tells <code>ys</code> to read the program from STDIN.
The <code>-J</code> option tells <code>ys</code> to <code>--load</code> the YAMLScript and output the evaluation
to JSON.</p>
<p>Well that's a wrap.
Thanks again for following along each day.</p>
<p>I'll see you tomorrow for day 6 of YAMLScript Advent 2023!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Modes of Transportation</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-06/"/>
      <updated>2023-12-06T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-06/</id>
      <content type="html">
        <![CDATA[
      <p>How do you get around?
Some people walk, some ride bikes, some drive cars (or the cars drive them),
some take trains, some in planes, so many ways, even some in sleighs.</p>
<p>In YAMLScript, data gets around via various modes of transportation...
3 modes to be exact.</p>
<p>Rememeber back on December 3rd when we talked about the 2 different states that
a YAMLScript program can be in?
In one state <code>say</code> is a function, and in the other it's just a plain string.</p>
<p>We call these states &quot;modes&quot;, and there is actually three of them.</p>
<h3>Welcome to Day 6 of the YAMLScript Advent Calendar</h3>
<p>YAMLScript has these 3 modes:</p>
<ul>
<li>
<p>Code Mode</p>
<p>A starting <code>!yamlscript/v0</code> tag puts the YS file into Code Mode.
Unquoted strings are code expressions which are further parsed into AST
forms.
A <code>!</code> tag can switch the mode to Data Mode.</p>
</li>
<li>
<p>Data Mode</p>
<p>A starting <code>!yamlscript/v0/data</code> tag puts the YS file into Data Mode.
Everything is the regular YAML data language that you are used to.
But a <code>!</code> tag can switch the mode to Code Mode.</p>
</li>
<li>
<p>Bare Mode</p>
<p>Without a magic starting <code>!yamlscript</code> tag, the YS file is in Bare Mode.
This is like Data Mode but you aren't allowed to ever switch to Code Mode.
This is the default mode for YAMLScript files, and the reason we can claim
that almost all existing YAML files are valid YAMLScript files.
<em>Specifically all those that adhere to the JSON data model, which is almost
all YAML config files.</em></p>
</li>
</ul>
<p>The <code>ys</code> CLI tool will implicitly add a <code>!yamlscript/v0</code> tag when you use the
<code>--eval</code> (aka <code>-e</code>) option, unless you actually provide a tag yourself.
This is simply for convenience when you are testing out code snippets.</p>
<p>Note that you can use multiple <code>-e</code> options and each one acts like a separate
line of code in a file.</p>
<p>So <code>ys -e 'say: &quot;Hello&quot;' -e 'say: &quot;World&quot;'</code> is the same as this YS program:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello"</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"World"</span></code></pre>
<p>If you wanted to write a <code>ys</code> one-liner that used Data Mode, you could do this:
<code>ys --load -e '!yamlscript/v0/data' -e 'foo: 111' -e 'bar: 222'</code> which is the
same as this YS program:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0/data</span><br><span class="token key atrule">foo</span><span class="token punctuation">:</span> <span class="token number">111</span><br><span class="token key atrule">bar</span><span class="token punctuation">:</span> <span class="token number">222</span></code></pre>
<p>If you wanted to write a <code>ys</code> one-liner that used Bare Mode, you could do this:
<code>ys --load -e </code>!yamlscript/v0/bare<code> -e 'foo: 111' -e 'bar: 222'</code> which is the
same as the Data Mode example above.</p>
<p>There's actually a better way to write Data and Bare Mode one-liners.
The <code>ys</code> command has a <code>--mode</code> (aka <code>-m</code>) option that lets you set the mode to
<code>code</code> (<code>c</code>), <code>data</code> (<code>d</code>) or <code>bare</code> (<code>b</code>).</p>
<p>Thus the last one liner could be written as:
<code>ys -mb -l -e 'foo: 111' -e 'bar: 222'</code>.</p>
<blockquote>
<p>Note: The <code>-m</code> option only works with the <code>-e</code> option.
You can't use it to change the mode of a file that you are loading or running.</p>
</blockquote>
<h3>Switching Modes</h3>
<p>In YAML tags are words that start with <code>!</code>.
They are instructions to the YAML loader (specifically to the constructor phase)
about what exactly to construct.</p>
<p>It's quite rare to see a YAML tag in the wild.
But here's something you probably didn't know...
Every untagged node in an internal YAML loader tree is implicitly assigned a
tag.
This process (of a YAML loader) is called &quot;tag resolution&quot;.
This is how the unquoted string <code>123</code> becomes the integer <code>123</code>.
It is implicitly tagged with <code>!!int</code>, which happens to be shorthand for
<code>tag:yaml.org,2002:int</code>.</p>
<p>All YAML loaders understand the set of <code>yaml.org,2002</code> tags: <code>!!map</code>, <code>!!seq</code>,
<code>!!str</code>, etc.
In fact you are free to use these tags in YAMLScript programs, even in Bare
Mode.
But there is really no good reason to do so.</p>
<p>The <code>!</code> tag is a valid YAML tag, but it is special in YAMLScript.
It switches between Code Mode and Data Mode.</p>
<p>If you think <code>!</code> looks weird, there is another cleaner looking way to switch
from Code Mode to Data Mode.</p>
<p>You can use <code>::</code> instead of <code>:</code> to separate the key and value of a mapping.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br>my<span class="token punctuation">-</span>map =<span class="token punctuation">:</span><span class="token punctuation">:</span><br>  foo = 111<br>  bar = 222</code></pre>
<p>is the same as:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">my-map =</span><span class="token punctuation">:</span> <span class="token tag">!</span><br>  <span class="token key atrule">foo</span><span class="token punctuation">:</span> <span class="token number">111</span><br>  <span class="token key atrule">bar</span><span class="token punctuation">:</span> <span class="token number">222</span></code></pre>
<p>At this point you can't do the same thing to switch from Data Mode to Code Mode.</p>
<p>Well that concludes our coverage of YAMLScript a la Mode!
Mmmm... Now doesn't that just sound delicious? (or at least fashionable!)</p>
<p>I'll see you tomorrow for day 7 of YAMLScript Advent 2023!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Sharpen Your Tools</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-07/"/>
      <updated>2023-12-07T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-07/</id>
      <content type="html">
        <![CDATA[
      <p>Wanna make some fun toys with YAMLScript?
You'll need some sharp tools.
You think those elves make all those toys with dull tools?</p>
<p>The CLI tool <code>ys</code> is the main tool you'll use to work with YAMLScript.
Today we'll learn about all the things you can do with it.</p>
<h3>Welcome to Day 7 of the YAMLScript Advent Calendar</h3>
<p>On Tuesday you learned how to install YAMLScript.
Reminder, here's the quick way to install the latest version:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">curl</span> https://yamlscript.org/install <span class="token operator">|</span> <span class="token assign-left variable">PREFIX</span><span class="token operator">=~</span>/.yamlscript <span class="token function">bash</span><br>$ <span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$HOME</span>/.yamlscript/bin:<span class="token environment constant">$PATH</span><br>$ ys <span class="token parameter variable">--version</span><br>YAMLScript v0.1.63</code></pre>
<p>The best first command to run is <code>ys --help</code>:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--help</span><br><br>ys - The YAMLScript <span class="token punctuation">(</span>YS<span class="token punctuation">)</span> Command Line Tool - v0.1.58<br><br>Usage: ys <span class="token punctuation">[</span><span class="token operator">&lt;</span>option<span class="token punctuation">..</span>.<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>file<span class="token operator">></span><span class="token punctuation">]</span><br><br>Options:<br><br>      <span class="token parameter variable">--run</span>                Run a YAMLScript program <span class="token function">file</span> <span class="token punctuation">(</span>default<span class="token punctuation">)</span><br>  -l, <span class="token parameter variable">--load</span>               Output <span class="token punctuation">(</span>compact<span class="token punctuation">)</span> JSON of YAMLScript evaluation<br>  -e, <span class="token parameter variable">--eval</span> YSEXPR        Evaluate a YAMLScript expression<br>                           multiple <span class="token parameter variable">-e</span> values joined by newline<br><br>  -c, <span class="token parameter variable">--compile</span>            Compile YAMLScript to Clojure<br>  -b, <span class="token parameter variable">--binary</span>             Compile to a native binary executable<br><br>  -p, <span class="token parameter variable">--print</span>              Print the result of <span class="token parameter variable">--run</span> <span class="token keyword">in</span> code mode<br>  -o, <span class="token parameter variable">--output</span> FILE        Output <span class="token function">file</span> <span class="token keyword">for</span> --load, <span class="token parameter variable">--compile</span> or <span class="token parameter variable">--binary</span><br><br>  -T, <span class="token parameter variable">--to</span> FORMAT          Output <span class="token function">format</span> <span class="token keyword">for</span> --load:<br>                             json, yaml, edn<br>  -J, <span class="token parameter variable">--json</span>               Output <span class="token punctuation">(</span>pretty<span class="token punctuation">)</span> JSON <span class="token keyword">for</span> <span class="token parameter variable">--load</span><br>  -Y, <span class="token parameter variable">--yaml</span>               Output YAML <span class="token keyword">for</span> <span class="token parameter variable">--load</span><br>  -E, <span class="token parameter variable">--edn</span>                Output EDN <span class="token keyword">for</span> <span class="token parameter variable">--load</span><br><br>  -m, <span class="token parameter variable">--mode</span> MODE          Add a mode tag: code, data, or bare <span class="token punctuation">(</span>for -e<span class="token punctuation">)</span><br>  -C, <span class="token parameter variable">--clojure</span>            Treat input as Clojure code<br><br>  <span class="token parameter variable">-d</span>                       Debug all compilation stages<br>  -D, --debug-stage STAGE  Debug a specific compilation stage:<br>                             parse, compose, resolve, build,<br>                             transform, construct, print<br>                           can be used multiple <span class="token builtin class-name">times</span><br>  -S, --stack-trace        Print full stack trace <span class="token keyword">for</span> errors<br>  -x, <span class="token parameter variable">--xtrace</span>             Print each expression before evaluation<br><br>      <span class="token parameter variable">--install</span>            Install the libyamlscript shared library<br>      <span class="token parameter variable">--upgrade</span>            Upgrade both ys and libyamlscript<br><br>      <span class="token parameter variable">--version</span>            Print version and <span class="token builtin class-name">exit</span><br>  -h, <span class="token parameter variable">--help</span>               Print this <span class="token builtin class-name">help</span> and <span class="token builtin class-name">exit</span></code></pre>
<h3>Ready, set, actions!</h3>
<p>The first thing to notice is that <code>ys</code> has 3 &quot;actions&quot;:</p>
<ul>
<li><code>--run</code> (default) - Compile and evaluate a YAMLScript file</li>
<li><code>--load</code> - Output the evaluated YAMLScript value as JSON (by default)</li>
<li><code>--compile</code> - Compile YAMLScript code to Clojure code</li>
</ul>
<p>For each action you'll need some YAMLScript source code.
This can come from 3 different places:</p>
<ul>
<li>The <code>--eval</code> (<code>-e</code>) option - specifies a line of YAMLScript code.
You can use this option multiple times to specify multiple lines of code.</li>
<li>A file path - specify a path to a file containing YAMLScript code.</li>
<li>Standard input - specify <code>-</code> as the file path to read YAMLScript code from
standard input.
If no file or <code>-e</code> options are specified, <code>ys</code> will check to see if there is
data on stdin.
That means you can leave off the <code>-</code> and pipe data into <code>ys</code> like this:
<code>echo $'!yamlscript/v0\nsay: &quot;Hello&quot;' | ys</code>.
Of course, it doesn't hurt to specify the <code>-</code> anyway.</li>
</ul>
<h3>Running Clojure  with <code>ys</code></h3>
<p>Clojure code is often valid YAMLScript code:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--compile</span> <span class="token parameter variable">-e</span> <span class="token string">'(println (+ 1 2))'</span><br><span class="token punctuation">(</span>println <span class="token punctuation">(</span>+ <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">))</span></code></pre>
<p>This YAMLScript compiles to the exact same Clojure code.</p>
<p>If you want the code you run to be considered to be Clojure code (thus not
compiled by the yamlscript compiler), you can use the <code>--clj</code> (<code>-C</code>) option.
This is useful when you want to test out the YAMLScript runtime envronment
directly with Clojure code.</p>
<p>Also you can pipe the output of <code>ys --compile</code> to <code>ys --clj</code> to run the
compiler's Clojure code ouput:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> <span class="token parameter variable">-e</span> <span class="token string">'say: 123'</span> <span class="token operator">|</span> ys <span class="token parameter variable">-C</span></code></pre>
<h3>Modes and Formats</h3>
<p>We learned about modes and the <code>--mode</code> option yesterday.
You can set the mode for <code>--eval</code> (<code>-e</code>) code with the <code>--mode</code> (<code>-m</code>) option.
The accepted values are <code>code</code> (<code>c</code>), <code>data</code> (<code>d</code>) and <code>bare</code> (<code>b</code>).</p>
<p>When you &quot;load&quot; YAMLScript using <code>--load</code> you get the result printed to stdout
as JSON.
These are 3 formatting options to control how the output is displayed:</p>
<ul>
<li><code>--json</code> (<code>-J</code>) - Output JSON (default)
Note that this JSON is a bit more nicely formatted than the default output.</li>
<li><code>--yaml</code> (<code>-Y</code>) - Output YAML</li>
<li><code>--edn</code> (<code>-E</code>) - Output EDN. EDN is Clojure's native data format.
It is also valid Clojure code.</li>
</ul>
<p>Note that when you specify a formatting option, it implies the <code>--load</code> action.</p>
<h3>Debugging</h3>
<p>When you &quot;run&quot; a YAMLScript program it doesn't print anything unless you use a
printing command.
This isn't surprising; all languages work this way.</p>
<p>Sometimes you want to know what the final value of the run was.
To get this you could print it with <code>say.</code>
You can also use the special <code>--print</code> (<code>-p</code>) option, which does exactly that
(with less typing)..</p>
<p>Finally there a 2 special debugging options:</p>
<ul>
<li><code>--debug</code> (<code>-X</code>) - Print a full stack trace for errors (more info)</li>
<li><code>--debug-stage</code> (<code>-x</code>) - Display the result of a stage/stages</li>
</ul>
<p>The <code>--debug-stage</code> option is super useful for understanding exactly how
YAMLScript code compiles to Clojure code.</p>
<p>For example, to see the internal AST when compiling some YAMLScript:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> <span class="token parameter variable">-e</span> <span class="token string">'say: "Hello"'</span> <span class="token parameter variable">-xconstruct</span><br>*** construct output ***<br><span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br><span class="token punctuation">(</span>say <span class="token string">"Hello"</span><span class="token punctuation">)</span></code></pre>
<p>And to see all 7 compilation stages:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> <span class="token parameter variable">-e</span> <span class="token string">'say: "Hello"'</span> <span class="token parameter variable">-xall</span><br>*** parse output ***<br><span class="token punctuation">(</span><span class="token punctuation">{</span>:+ <span class="token string">"+MAP"</span>, :<span class="token operator">!</span> <span class="token string">"yamlscript/v0"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :<span class="token operator">=</span> <span class="token string">"say"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :$ <span class="token string">"Hello"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"-MAP"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><br><br>*** compose output ***<br><span class="token punctuation">{</span>:<span class="token operator">!</span> <span class="token string">"yamlscript/v0"</span>, :% <span class="token punctuation">[</span><span class="token punctuation">{</span>:<span class="token operator">=</span> <span class="token string">"say"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:$ <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** resolve output ***<br><span class="token punctuation">{</span>:ysm <span class="token punctuation">(</span><span class="token punctuation">{</span>:ysx <span class="token string">"say"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:ysi <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><br><br>*** build output ***<br><span class="token punctuation">{</span>:ysm <span class="token punctuation">(</span><span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><br><br>*** transform output ***<br><span class="token punctuation">{</span>:ysm <span class="token punctuation">(</span><span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><br><br>*** construct output ***<br><span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** print output ***<br><span class="token string">"(say <span class="token entity" title="\&quot;">\"</span>Hello<span class="token entity" title="\&quot;">\"</span>)<span class="token entity" title="\n">\n</span>"</span><br><br><span class="token punctuation">(</span>say <span class="token string">"Hello"</span><span class="token punctuation">)</span></code></pre>
<p>We'll go over all of these stages in detail in a future post.</p>
<p>In the meantime, try out your new <code>ys</code> tool and see what you can do with it.
The more you use it, the sharper it will get.</p>
<p>I'll see you tomorrow for day 8 of YAMLScript Advent 2023!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Going to the Library</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-08/"/>
      <updated>2023-12-08T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-08/</id>
      <content type="html">
        <![CDATA[
      <p>Programming in YAMLScript is as easy as reading a book.
The only thing you really need is some good books!
For that let's go to the library.</p>
<p>By books of course I mean YAMLScript functions.
And by library I mean the YAMLScript Standard Library!
There you'll find all-time best sellers like <code>map</code>, <code>filter</code>, <code>reduce</code> and
<code>say</code>.</p>
<p>And Standard isn't the only Library in town...</p>
<h3>Welcome to Day 8 of the YAMLScript Advent Calendar</h3>
<p>In our YS programming so far, we've been using various functions like <code>say</code>,
<code>take</code>, <code>keys</code>, <code>join</code> and <code>map</code>.
Also we've been using various operators like <code>+</code>, <code>*</code>, <code>=&gt;</code> and <code>..</code>.
Operators are just functions with names made out of punctuation characters.</p>
<p>Where do these functions come from?
Are they built into the YAMLScript language?</p>
<p>Nope. They all come from the Library!</p>
<details><summary>
<strong style="color:brown">Libraries and Namespaces</strong></summary>
<p>It's probably a good idea to explain what a Clojure library is.
And we should probably talk about namespaces too.
Don't worry, it's quite simple.</p>
<p>A library is a file that contains a namespace and a bunch of functions (who
belong to that library/namespace).
The namespace name is made up of 2 or more words separated by the <code>.</code> character.
The name corresponds to the file path of the library.</p>
<p>For example (in Clojure) the <code>foo.bar</code> library would contain a <code>foo.bar</code>
namespace and be located at <code>foo/bar.clj</code> in your Java classpath.
To access a function called <code>thinger</code> in <code>foo.bar</code>, you would use the fully
qualified name (aka a Clojure symbol) <code>foo.bar/thinger</code>.</p>
<p>YAMLScript is the same except:</p>
<ul>
<li>File names end with <code>.ys</code></li>
<li>The 2 or more words are separated by <code>::</code> instead of <code>.</code></li>
<li>A fully qualified symbol looks like <code>foo::bar.thinger</code>.
<ul>
<li>You'll find out later why this is really cool</li>
</ul>
</li>
</ul>
</details>
<p>The YAMLScript runtime has several libraries that are always available.
The two primary ones are <code>clojure::core</code> and <code>ys::std</code>.</p>
<p>The <code>clojure::core</code> library is what YAMLScript calls Clojure's famous
<code>clojure.core</code> library.
In Clojure (and thus YAMLScript!) <code>clojure.core</code> is the heart and soul of the
language.
It's where all the Good Parts live.
All of the functions (and macros) that you use constantly in your day-to-day
programming.</p>
<p>How many publicly accessible functions does <code>clojure::core</code> give you?
581!!</p>
<p>How do I know that?
YAMLScript just told me so:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-pe</span> <span class="token string">'->(clojure::core quote find-ns ns-publics count)'</span><br><span class="token number">581</span></code></pre>
<p>That's a lot of functions!</p>
<details><summary><strong style="color:red">Why not 671?</strong></summary>
<p>Honestly it's not as many as the real <code>clojure.core</code> library called from
Clojure.</p>
<pre class="language-bash"><code class="language-bash">$ clojure <span class="token parameter variable">-M</span> <span class="token parameter variable">-e</span> <span class="token string">'(-> clojure.core quote ns-publics count)'</span><br><span class="token number">671</span></code></pre>
<p>The reason for this is because YAMLScript uses a special version of Clojure
the <a href="https://github.com/babashka/sci">SCI</a> (Small Clojure Interpreter).</p>
<p>SCI offers a subset of Clojure's functionality, but it's a very useful subset.
It's also a &quot;safe&quot; subset.</p>
<p>I don't think you'll run into anything that's not available in your day to day
YAMLScripting.
If you do, give me a ring and we'll see what we can do to get it added.</p>
</details>
<p>The <code>clojure.core</code> library is very well documented so we won't talk about it
more right now.</p>
<p>Let's discuss the other one I mentioned, <code>ys::std</code>.
This is the YAMLScript Standard Library.
It's where you'll find functions that make YS nicer to work with.
The <code>say</code> function that shows up constantly is defined as <code>ys::std.say</code>.</p>
<p>How many functions does it offer?</p>
<pre class="language-bash"><code class="language-bash">$ YS <span class="token parameter variable">-pe</span> <span class="token string">'->(ys::std quote find-ns ns-publics count)'</span><br><span class="token number">17</span></code></pre>
<p>Not that many yet, but it is still being actively defined.</p>
<p>Here's a few of them:</p>
<ul>
<li><code>say</code> - A shorter way to say <code>println</code></li>
<li><code>warn</code> - Like <code>say</code> but prints to stderr</li>
<li><code>load</code> - Load an external YAMLScript file</li>
<li><code>=&gt;</code> - <code>=&gt;: 123</code> or <code>(=&gt; 123)</code> compiles to <code>123</code></li>
<li><code>pretty</code> - Pretty formats a data structure (without printing it)</li>
<li><code>toI</code>, <code>toS</code>, <code>toB</code> etc casting functions (Integer, String, Boolean)</li>
<li><code>_+</code> and <code>_*</code> - The polymorphic versions of <code>+</code> and <code>*</code> infix operators</li>
</ul>
<p>The <code>ys::std</code> library will certainly grow over time.
Functions is this library use names that are not used by <code>clojure.core</code>
functions.</p>
<h3>Other <code>ys::</code> Libraries</h3>
<p>There are currently 3 other <code>ys::</code> libraries that are always available.</p>
<ul>
<li><code>ys::yaml</code> - YAML <code>load</code> and <code>dump</code> functions</li>
<li><code>ys::json</code> - JSON <code>load</code> and <code>dump</code> functions</li>
<li><code>ys::ys</code> - <code>compile</code>, <code>eval</code> and <code>load</code> YS from within YS!</li>
</ul>
<p>For fun let's write a silly YS program that uses them.</p>
<p>Let's call it <code>silly.ys</code>:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment">#!/usr/bin/env ys-0</span><br><br><span class="token key atrule">my-yaml =</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string"><br>  - Hello<br>  - Salutations<br>  - Ho Ho Ho<br>  - Merry Christmas<br>  - Happy Holidays<br>  - Seasons Greetings<br>  - Happy New Year<br>  - Happy Hanukkah<br>  - Happy Kwanzaa</span><br><br><span class="token key atrule">my-json =</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string"><br>  [ "World",<br>    "Santa",<br>    "Elves",<br>    "Reindeer",<br>    "Snowman",<br>    "Mrs. Claus",<br>    "Rudolph",<br>    "Frosty",<br>    "Kids" ]</span><br><br><span class="token key atrule">greets =</span><span class="token punctuation">:</span> yaml/load(my<span class="token punctuation">-</span>yaml)<br><br><span class="token key atrule">names =</span><span class="token punctuation">:</span> json/load(my<span class="token punctuation">-</span>json)<br><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"$rand-nth(greets), $rand-nth(names)!!"</span><br></code></pre>
<p>Now let's run it a few times:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token keyword">for</span> <span class="token for-or-select variable">x</span> <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">do</span> ys silly.ys<span class="token punctuation">;</span> <span class="token keyword">done</span><br>Happy Holidays, Kids<span class="token operator">!</span><span class="token operator">!</span><br>Hello, World<span class="token operator">!</span><span class="token operator">!</span><br>Happy New Year, World<span class="token operator">!</span><span class="token operator">!</span><br>Hello, Rudolph<span class="token operator">!</span><span class="token operator">!</span><br>Salutations, Santa<span class="token operator">!</span><span class="token operator">!</span><br>Salutations, Mrs. Claus<span class="token operator">!</span><span class="token operator">!</span><br>Happy Hanukkah, Mrs. Claus<span class="token operator">!</span><span class="token operator">!</span><br>Merry Christmas, Santa<span class="token operator">!</span><span class="token operator">!</span><br>Ho Ho Ho, Rudolph<span class="token operator">!</span><span class="token operator">!</span><br>Hello, Elves<span class="token operator">!</span><span class="token operator">!</span></code></pre>
<p>That's a lot of fun!
We wrote a program in YAML to play with some YAML that was inside the YAML!</p>
<p>I hope you're starting to see the power of YAMLScript, and I hope you have a wonderful day.</p>
<p>Full disclosure: I'm stuck in the Winnipeg airport, writing this and hacking on
YAMLScript because my flight's toilets stopped working and they decided to land
here for the night. True story.</p>
<p>Tune in tomorrow for Day 9 of the YAMLScript Advent Calendar.</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Coding with Style</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-09/"/>
      <updated>2023-12-09T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-09/</id>
      <content type="html">
        <![CDATA[
      <p>What's the best thing about Rudolph's nose?
Is it that lights the way for Santa's sleigh?
I'm calling BS on that.
I'd say it's the main thing that gives the whole <strong>Sanata Story some Serious
Style!</strong></p>
<p>Good programmers do more than just get their solutions right.
They do the whole thing with style.
That makes the program easier to read, understand and maintain.
It also gives the code a certain je ne sais quoi.</p>
<h3>Welcome to Day 9 of the YAMLScript Advent Calendar</h3>
<p>We know that YAMLScript compiles to Clojure.
And we know that YAML doesn't really look anything like a Lisp.
But it turns out that YAMLScript can use as much or as little Lisp style as you
want it to.
It's all about your personal style.</p>
<p>Here's a YS program that sings my favorite drinking song:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment">#!/usr/bin/env ys-0</span><br><span class="token comment"># 99-bottles.ys</span><br><br><span class="token comment"># Print the verses to "99 Bottles of Beer"</span><br><span class="token comment">#</span><br><span class="token comment"># usage:</span><br><span class="token comment">#   ys 99-bottles.ys [&lt;count>]</span><br><br>defn main(&amp;<span class="token punctuation">[</span>number<span class="token punctuation">]</span>)<span class="token punctuation">:</span><br>  each <span class="token punctuation">[</span>n ((number <span class="token punctuation">|</span><span class="token punctuation">|</span> 99) .. 1)<span class="token punctuation">]</span><span class="token punctuation">:</span><br>    <span class="token key atrule">say</span><span class="token punctuation">:</span><br>      <span class="token key atrule">paragraph</span><span class="token punctuation">:</span> n<br><br><span class="token key atrule">defn paragraph(num)</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string"><br>  $(bottles num) of beer on the wall,<br>  $(bottles num) of beer.<br>  Take one down, pass it around.<br>  $(bottles (num - 1)) of beer on the wall.</span><br><br><span class="token key atrule">defn bottles(n)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">cond</span><span class="token punctuation">:</span><br>    (n == 0) "No more bottles"<br>    (n == 1) "1 bottle"<br>    <span class="token punctuation">:</span>else    str(n " bottles")</code></pre>
<p>Let's give it a try:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token number">99</span>-bottles.ys <span class="token number">3</span><br><span class="token number">3</span> bottles of beer on the wall,<br><span class="token number">3</span> bottles of beer.<br>Take one down, pass it around.<br><span class="token number">2</span> bottles of beer on the wall.<br><br><span class="token number">2</span> bottles of beer on the wall,<br><span class="token number">2</span> bottles of beer.<br>Take one down, pass it around.<br><span class="token number">1</span> bottle of beer on the wall.<br><br><span class="token number">1</span> bottle of beer on the wall,<br><span class="token number">1</span> bottle of beer.<br>Take one down, pass it around.<br>No <span class="token function">more</span> bottles of beer on the wall.</code></pre>
<p>I feel tipsy.</p>
<p>Let's compile this program to Clojure and see what it looks like:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> <span class="token number">99</span>-bottles.ys<br><span class="token punctuation">(</span>declare paragraph bottles<span class="token punctuation">)</span><br><span class="token punctuation">(</span>defn main <span class="token punctuation">[</span><span class="token operator">&amp;</span> <span class="token punctuation">[</span>number<span class="token punctuation">]</span><span class="token punctuation">]</span><br>  <span class="token punctuation">(</span>doall <span class="token punctuation">(</span>map say <span class="token punctuation">(</span>map paragraph <span class="token punctuation">(</span>rng <span class="token punctuation">(</span>or number <span class="token number">99</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">))</span><span class="token punctuation">))</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span>defn paragraph <span class="token punctuation">[</span>num<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span>str<br>    <span class="token punctuation">(</span>bottles num<span class="token punctuation">)</span><br>    <span class="token string">" of beer on the wall,<span class="token entity" title="\n">\n</span>"</span><br>    <span class="token punctuation">(</span>bottles num<span class="token punctuation">)</span><br>    <span class="token string">" of beer.<span class="token entity" title="\n">\n</span>Take one down, pass it around.<span class="token entity" title="\n">\n</span>"</span><br>    <span class="token punctuation">(</span>bottles <span class="token punctuation">(</span>- num <span class="token number">1</span><span class="token punctuation">))</span><br>    <span class="token string">" of beer on the wall."</span> <span class="token string">"<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">))</span><br><span class="token punctuation">(</span>defn bottles <span class="token punctuation">[</span>n<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span>cond<br>    <span class="token punctuation">(</span><span class="token operator">==</span> n <span class="token number">0</span><span class="token punctuation">)</span> <span class="token string">"No more bottles"</span><br>    <span class="token punctuation">(</span><span class="token operator">==</span> n <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1 bottle"</span> :else<br>    <span class="token punctuation">(</span>str n <span class="token string">" bottles"</span><span class="token punctuation">))</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span>apply main ARGV<span class="token punctuation">)</span></code></pre>
<p>It turns out that the compiled Clojure code is actually valid YAMLScript syntax
as well.
Well, almost.</p>
<p>The file is valid YAML.
It represents a single big string.
Normally YAML files represent a single big mapping or sequence, but they can
also define a top level scalar (string).</p>
<p>If I run this program though, it doesn't print anything.
The reason is simple.
We didn't give it the power to.
We didn't add the <code>!yamlscript/v0</code> tag to the beginning of the file.</p>
<p>If we do that it works fine.</p>
<p>So apparently we can write YAMLScript in a purely Lisp style.
The truth is you can write YAMLScript is a completely YAML style (no parens),
a completely Lisp style (all parens), or somewhere in between.</p>
<p>Good looking YS programs start with YAML style and then switch to the Lisp style
for certain nicer idioms.
Note that you can't switch back to YAML style once you've switched to Lisp
style.</p>
<p>Let's iterate on the above code and make it YAML just at the top level:</p>
<pre class="language-yaml"><code class="language-yaml">defn main <span class="token punctuation">[</span>&amp; <span class="token punctuation">[</span>number<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span><br>  (doall (map say (map paragraph (rng (or number 99) 1))))<br>defn paragraph <span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">:</span><br>  (str<br>    (bottles num)<br>    " of beer on the wall<span class="token punctuation">,</span>\n"<br>    (bottles num)<br>    " of beer.\nTake one down<span class="token punctuation">,</span> pass it around.\n"<br>    (bottles (<span class="token punctuation">-</span> num 1))<br>    " of beer on the wall." "\n")<br>defn bottles <span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">:</span><br>  (cond<br>    (== n 0) "No more bottles"<br>    (== n 1) "1 bottle" <span class="token punctuation">:</span>else<br>    (str n " bottles"))<br><span class="token key atrule">apply</span><span class="token punctuation">:</span> main ARGV</code></pre>
<p>That already looks a lot better.</p>
<p>We get a big win turning the <code>paragraph</code> into a YAML literal scalar (heredoc)
with string interpolation.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn paragraph(num)</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string"><br>  $(bottles num) of beer on the wall,<br>  $(bottles num) of beer.<br>  Take one down, pass it around.<br>  $(bottles (num - 1)) of beer on the wall.</span></code></pre>
<p>That's so much easier to read and understand.</p>
<p>I hope you are inspired to write some beautiful YAMLScript code.</p>
<p><strong>You've got style, baby!</strong></p>
<p>Come back tomorrow for day 10 of the YAMLScript Advent Calendar.</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>States and Ladders</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-10/"/>
      <updated>2023-12-10T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-10/</id>
      <content type="html">
        <![CDATA[
      <p>Santa is a busy guy.
He has a lot of work to do.
He has to make a list and check it twice.
He has to find out who's naughty and nice.
He has the monumental task of transforming wishes into happiness.</p>
<p>YS only needs to transform YAMLScript into Clojure.
But it's a bit more involved than you might think.</p>
<p>To make things easier the YS compiler breaks the transformation into eight
distinct States and seven distinct <s>Ladders</s> transformations.</p>
<h3>Welcome to Day 10 of the YAMLScript Advent Calendar</h3>
<p>Today we're going to learn more exactly how <code>ys --compile</code> turns YAMLScript into
Clojure.<br>
<em>Fair Warning: This is going to be a long post</em>.</p>
<p>The <code>ys</code> CLI has an awesome tool to visualize the transformation process any
time you are interested.
This might be for debugging where something went wrong, or just to learn more
about how the compiler works.</p>
<p>To begin this journey, let's use this visualizer in action.
You could write it like this:</p>
<pre class="language-bash"><code class="language-bash">ys <span class="token parameter variable">--compile</span> --debug-state<span class="token operator">=</span>all <span class="token parameter variable">-e</span> <span class="token string">'name =: "Clojure"'</span> <span class="token parameter variable">-e</span> <span class="token string">'say: "Hello, $name!"'</span></code></pre>
<p>The one line program is equivalent to the file containing:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">name =</span><span class="token punctuation">:</span> <span class="token string">"Clojure"</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello, $name!"</span></code></pre>
<p>Let's run the command now (but we'll use the shorter options):</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> <span class="token parameter variable">-e</span> <span class="token string">'name =: "Clojure"'</span> <span class="token parameter variable">-e</span> <span class="token string">'say: "Hello, $name!"'</span> <span class="token parameter variable">-xall</span><br>*** parse output ***<br><span class="token punctuation">(</span><span class="token punctuation">{</span>:+ <span class="token string">"+MAP"</span>, :<span class="token operator">!</span> <span class="token string">"yamlscript/v0"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :<span class="token operator">=</span> <span class="token string">"name ="</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :$ <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :<span class="token operator">=</span> <span class="token string">"say"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"=VAL"</span>, :$ <span class="token string">"Hello, <span class="token variable">$name</span>!"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span>:+ <span class="token string">"-MAP"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><br><br>*** compose output ***<br><span class="token punctuation">{</span>:<span class="token operator">!</span> <span class="token string">"yamlscript/v0"</span>,<br> :% <span class="token punctuation">[</span><span class="token punctuation">{</span>:<span class="token operator">=</span> <span class="token string">"name ="</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:$ <span class="token string">"Clojure"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:<span class="token operator">=</span> <span class="token string">"say"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:$ <span class="token string">"Hello, <span class="token variable">$name</span>!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** resolve output ***<br><span class="token punctuation">{</span>:ysm<br> <span class="token punctuation">[</span><span class="token punctuation">{</span>:ysx <span class="token string">"def name"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:ysi <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:ysx <span class="token string">"say"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:ysi <span class="token string">"Hello, <span class="token variable">$name</span>!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** build output ***<br><span class="token punctuation">{</span>:ysm<br> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym def<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span><span class="token punctuation">]</span><br>  <span class="token punctuation">{</span>:Str <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym str<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span><br><br>*** transform output ***<br><span class="token punctuation">{</span>:ysm<br> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym def<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span><span class="token punctuation">]</span><br>  <span class="token punctuation">{</span>:Str <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym str<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** construct output ***<br><span class="token punctuation">{</span>:Lst<br> <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym do<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym def<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Clojure"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span>:Lst<br>   <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym say<span class="token punctuation">}</span><br>    <span class="token punctuation">{</span>:Lst <span class="token punctuation">[</span><span class="token punctuation">{</span>:Sym str<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:Sym name<span class="token punctuation">}</span> <span class="token punctuation">{</span>:Str <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br><br>*** print output ***<br><span class="token string">"(def name <span class="token entity" title="\&quot;">\"</span>Clojure<span class="token entity" title="\&quot;">\"</span>)<span class="token entity" title="\n">\n</span>(say (str <span class="token entity" title="\&quot;">\"</span>Hello, <span class="token entity" title="\&quot;">\"</span> name <span class="token entity" title="\&quot;">\"</span>!<span class="token entity" title="\&quot;">\"</span>))<span class="token entity" title="\n">\n</span>"</span><br><br><span class="token punctuation">(</span>def name <span class="token string">"Clojure"</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span>say <span class="token punctuation">(</span>str <span class="token string">"Hello, "</span> name <span class="token string">"!"</span><span class="token punctuation">))</span></code></pre>
<p>Woah! That's a lot of output.
But it's exactly what I want to tell you about today.</p>
<p>At the bottom is the clojure code we expect.
Above that is the output of each of the seven transformations (aka the 7 states
that come after the first state: our YS input).</p>
<p>Let's look at each of these transformations in turn...</p>
<h3>Transformation 1: Parse</h3>
<p>The first transformation is parsing YAML into a sequence of &quot;parse events&quot;.
This is by far the hardest transformation, not just for YS but for any YAML
processor.
Sadly, it's so hard that only a few of the dozens of YAML processors out there
actually do it correctly.
See: <a href="https://matrix.yaml.info/">https://matrix.yaml.info/</a></p>
<p>On the other hand, this is actually the simplest part for the YS compiler to
implement.
Why?
Because it uses somebody else's YAML parser!!</p>
<blockquote>
<p>Note: YS currently uses the
<a href="https://bitbucket.org/snakeyaml/snakeyaml-engine">SnakeYAML Engine</a> framework
(only for it's YAML 1.2 parser component).
Later we plan to use <a href="https://github.com/pantoniou/libfyaml">libfyaml</a> which is
currently considered the best YAML parser in the world.
SnakeYAML was the obvious first choice because it's written in Java, YS is
written in Clojure and Clojure is a JVM language.
It's doing a great job for now!</p>
</blockquote>
<p>This is a good time to mention that the YAML data language spec describes
&quot;loading&quot; YAML text into native data structures as a several step process of
states and transformations.
In reality, the YS compiler is really just a very fancy YAML loader!</p>
<p>YAML parsers typically produce 10 different kinds of parse events:</p>
<ul>
<li>Start Stream</li>
<li>End Stream</li>
<li>Start Document</li>
<li>End Document</li>
<li>Start Sequence</li>
<li>End Sequence</li>
<li>Start Mapping</li>
<li>End Mapping</li>
<li>Scalar Value</li>
<li>Alias Reference</li>
</ul>
<p>YS (currently) doesn't care about the first 4 events, so it just ignores them.</p>
<p>That leaves use with a mapping containing 2 key/value pairs:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"+MAP"</span><span class="token punctuation">,</span> <span class="token symbol">:!</span> <span class="token string">"yamlscript/v0"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"=VAL"</span><span class="token punctuation">,</span> <span class="token symbol">:=</span> <span class="token string">"name ="</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"=VAL"</span><span class="token punctuation">,</span> :$ <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"=VAL"</span><span class="token punctuation">,</span> <span class="token symbol">:=</span> <span class="token string">"say"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"=VAL"</span><span class="token punctuation">,</span> :$ <span class="token string">"Hello, $name!"</span><span class="token punctuation">}</span><br> <span class="token punctuation">{</span><span class="token symbol">:+</span> <span class="token string">"-MAP"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre>
<p>We are showing this state as a Clojure data structure and that's the kind of
serialization that we use in the YS compiler tests.</p>
<p>Here's a quick breakdown of the mapping keywords used above:</p>
<ul>
<li><code>:+</code> is the parse event type</li>
<li><code>:!</code> is the (optional) YAML tag</li>
<li><code>:=</code> is a plain (unquoted) scalar value</li>
<li><code>:$</code> is a double quoted scalar value</li>
</ul>
<p>That was a lot of info, but hopefully it sets the stage for the rest of this
post.</p>
<p>If you are interested in seeing how all this is implemented, check out:</p>
<ul>
<li><a href="https://github.com/yaml/yamlscript/tree/main/core/src/yamlscript">All the YS transformation libraries source code</a></li>
<li>The YS Test Suite Files:
<ul>
<li><a href="https://github.com/yaml/yamlscript/blob/main/core/test/compiler-stack.yaml">https://github.com/yaml/yamlscript/blob/main/core/test/compiler-stack.yaml</a></li>
<li><a href="https://github.com/yaml/yamlscript/blob/main/core/test/compiler.yaml">https://github.com/yaml/yamlscript/blob/main/core/test/compiler.yaml</a></li>
</ul>
</li>
</ul>
<h3>Transformation 2: Compose</h3>
<p>The second transformer is called the composer (in the <code>yamlscript.composer</code>
library).</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:!</span> <span class="token string">"yamlscript/v0"</span><span class="token punctuation">,</span><br> :% <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:=</span> <span class="token string">"name ="</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:$ <span class="token string">"Clojure"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:=</span> <span class="token string">"say"</span><span class="token punctuation">}</span> <span class="token punctuation">{</span>:$ <span class="token string">"Hello, $name!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>
<p>Its simple job is to take the parse events and compose them into a tree of
mapping, sequence and scalar nodes.</p>
<p>It preserves the node's tag if any.</p>
<p>Here we see a new keyword <code>:%</code> which is used for a mapping node.
Sequence nodes use the keyword <code>:-</code> but they only show up in data mode, which we
aren't using here.</p>
<p>Now we have all the important information from the YAML input in an AST form
that we can refine (transform) a few more times until it becomes a Clojure AST!</p>
<h3>Transformation 3: Resolve</h3>
<p>YAML tags are rarely seen in the wild.
Many YAML users don't even know they exist.
But tags play an important role in the YAML load process.
Internally every single untagged node is assigned a tag based on heuristics that
consider its kind, position and content.</p>
<p>This process is called &quot;tag resolution&quot; and it's what we are doing here:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:ysm</span><br> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:ysx</span> <span class="token string">"def name"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:ysi</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:ysx</span> <span class="token string">"say"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:ysi</span> <span class="token string">"Hello, $name!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>
<p>Notice that all the keywords changed to <code>:ys?</code> here.
This is how YS stores the tag.
Each tag knows what kind of node it is attached to (map, seq or scalar) so, to
keep things simple, it doesn't store that info in the AST.</p>
<blockquote>
<p>Note: Keeping the structure of each state AST as simple as possible is a key
concern of the YS compiler.
It makes it easier to see what's going on when debugging and even more
importantly, it makes it easier to write tests for each transformation.</p>
</blockquote>
<p>The keywords seen above are:</p>
<ul>
<li><code>:ysm</code> is a code mode mapping node</li>
<li><code>:ysi</code> is a scalar that supports interpolation</li>
<li><code>:ysx</code> is a ys expression (a string of code to be further parsed)</li>
</ul>
<p>Tags are are essentially the names of the transformations that will be applied
to the node in the following transformation.</p>
<h3>Transformation 4: Build</h3>
<p>The build transformation is where a lot of the magic happens.</p>
<p>Most importantly, it's where scalars containing YAMLScript expressions are lexed
and parsed into Clojure expression ASTs.</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:ysm</span><br> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> def<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span><span class="token punctuation">]</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Sym</span> say<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> str<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre>
<p>For instance we can see that the simple string expression &quot;def name&quot; was parsed
into 2 Clojure symbol nodes: <code>{:Sym def}</code> and <code>{:Sym name}</code>.</p>
<p>We can also see that the string expression &quot;Hello, $name!&quot; was parsed into a an
interpolated string expression that joins string literals and variable values
into a single string.</p>
<p>One important aspect of the build output AST is that it retains the original
structure of the YAML input.
Mappings still have key/value pairs, and the key info stays separate from the
value info.</p>
<h3>Transformation 5: Transform</h3>
<p>The transformer transformation (that's a bit awkward I'll admit) is where
&quot;special cases&quot; are handled.</p>
<p>Not much happens in this stage yet.
In fact nothing at all happened in this example.</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:ysm</span><br> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> def<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span><span class="token punctuation">]</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Sym</span> say<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> str<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>
<p>It's exactly the same as the build output.</p>
<p>In the future, the transform stage is where we will add support for letting
users defined their own syntax and semantic transformations for specific
functions.
If you know about Lisp macros, this will be something spiritually similar.</p>
<p>If you happen to think a particular function should be coded a specific way,
you'll be able to make it so.
As long as you don't break the rules of physics... or YAML!</p>
<p>Note that even though this transformation can change the AST quite a bit, it
still retains its overall YAML structure.</p>
<h3>Transformation 6: Construct</h3>
<p>The constructor phase's job is simple.
Turn the final YAML structured AST into an AST that directly represents the
intended Clojure code compilation result.</p>
<p>It does this essentially by applying the function asscoiated with a node's tag
to the node's value.</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:Lst</span><br> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> do<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> def<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span><br>   <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> say<span class="token punctuation">}</span><br>    <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> str<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>
<p>Every node in this AST directy represents a Clojure code construct.
Voila!</p>
<h3>Transformation 7: Print</h3>
<p>Just like in any Lisp, a Clojure AST &quot;prints&quot; directly to Clojure code.
This is because every node in the AST is essentially a token that knows how to
print itself!</p>
<p>Again here's our final AST:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token symbol">:Lst</span><br> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> do<span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> def<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Clojure"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><br>  <span class="token punctuation">{</span><span class="token symbol">:Lst</span><br>   <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> say<span class="token punctuation">}</span><br>    <span class="token punctuation">{</span><span class="token symbol">:Lst</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token symbol">:Sym</span> str<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"Hello, "</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Sym</span> name<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token symbol">:Str</span> <span class="token string">"!"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre>
<p>The <code>yamlscript.printer/print</code> function converts that to this string (of Clojure
code):</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token string">"(def name \"Clojure\")\n(say (str \"Hello, \" name \"!\"))\n"</span></code></pre>
<p>When that string is printed out, it looks like this:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">def</span> name <span class="token string">"Clojure"</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token function">say</span> <span class="token punctuation">(</span><span class="token keyword">str</span> <span class="token string">"Hello, "</span> name <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Aaaand, we're done!</p>
<h3>Transformation 1-7: Compile</h3>
<p>The YAMLScript compiler is just all the above crammed together is sequence;
passing YS input through the 7 transformations we just described.</p>
<p>I'd like to show you the actual YAMLScript <code>compile</code> function (written in
Clojure):</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> compile<br>  <span class="token string">"Convert YAMLScript code string to an equivalent Clojure code string."</span><br>  <span class="token punctuation">[</span><span class="token operator">^</span>String yamlscript-string<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">->></span> yamlscript-string<br>    yamlscript.parser/parse<br>    yamlscript.composer/compose<br>    yamlscript.resolver/resolve<br>    yamlscript.builder/build<br>    yamlscript.transformer/transform<br>    yamlscript.constructor/construct<br>    yamlscript.printer/print<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Pretty straightforward, right?
Or if you are more familiar with YAMLScript than Clojure:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn compile(yamlscript-string)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">"Convert YAMLScript code string to an equivalent Clojure code string."</span><span class="token punctuation">:</span><br>  <span class="token key atrule">->></span><span class="token punctuation">:</span><br>    yamlscript<span class="token punctuation">-</span>string<br>    yamlscript.parser/parse<br>    yamlscript.composer/compose<br>    yamlscript.resolver/resolve<br>    yamlscript.builder/build<br>    yamlscript.transformer/transform<br>    yamlscript.constructor/construct<br>    yamlscript.printer/print</code></pre>
<p>I hope I didn't waste too much of your Sunday on this post.
I know it was a lot to take in, and I also know you don't need to know all this
to be a good YAMLScript programmer.</p>
<p>But then again, you probably want to know all about this to become a great one!</p>
<p>See you tomorrow for Day 11 of the YAMLScript Advent Calendar.</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>The YeS Express</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-11/"/>
      <updated>2023-12-11T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-11/</id>
      <content type="html">
        <![CDATA[
      <p>Santa's got a lot of ground to cover in a short amount of time.
He doesn't have time to deal with confusing maps and directions.</p>
<p>Lisp has other-worldly powers of abstraction, but when it comes to reading
syntax, most people prefer the familiarity of this world.</p>
<p>YAMLScript fully embraces all that Clojure has to offer, but syntax-wise it
also offers a more familiar face.</p>
<h3>Welcome to Day 11 of the YAMLScript Advent Calendar!</h3>
<p>Today we'll look at YAMLScript Expressions, aka YeS-Expressions.
Lisp has S-Expressions, YAMLScript has YeS-Expressions!</p>
<p>When writing YAMLScript instructions in &quot;code mode&quot; you are always working with
3 basic YAML elements:</p>
<ul>
<li>YAML Block Mappings - The indented style <code>key: value</code> pairs</li>
<li>YAML Quoted Scalars - String literals</li>
<li>YAML Plain Scalars - The unquoted <code>value</code> scalars</li>
</ul>
<p>YAMLScript treats all YAML plain scalars as YeS-Expressions (ysexprs).</p>
<p>Let's look at some examples.</p>
<h3>Infix Expressions</h3>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">x =</span><span class="token punctuation">:</span> (y * 2)<br><span class="token key atrule">z =</span><span class="token punctuation">:</span> (x + 5 + y)</code></pre>
<p>Compiles to Clojure (Lisp) like this:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">def</span> x <span class="token punctuation">(</span><span class="token keyword">*</span> y <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token keyword">def</span> z <span class="token punctuation">(</span><span class="token keyword">+</span> x <span class="token number">5</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>YeS-Expressions support infix operators for very simple expressions.
If you put exactly 3 forms in parentheses, and the second one is an operator,
then the first and third forms are operands.
The compiler will swap the first and second forms making it work like Lisp wants
it to.</p>
<p>If you have a parenthesized expression with more than 2 operands and the
operators are all the same, then the compiler will make a Lisp form starting
with the operator and followed by the operands.</p>
<blockquote>
<p>Note: In rare cases in Lisp <code>(a + 1)</code> is valid when <code>a</code> is a function that
takes two arguments, an operator function add a number in this case.
There are ways to specifiy this in YAMLScript, but we won't cover them here.</p>
</blockquote>
<p>In simple cases where the infix expression is the only thing in the YAML scalar,
you can omit the parentheses.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">x =</span><span class="token punctuation">:</span> y * 2<br><span class="token key atrule">z =</span><span class="token punctuation">:</span> x + 5 + y</code></pre>
<p>Note that YAMLScript has no support for operator precedence.
You must use parentheses to group expressions and group operations in triplets.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">x =</span><span class="token punctuation">:</span> ((y * 2) + 5) / 2</code></pre>
<h3>Prefix Expressions</h3>
<p>In Lisp you might see a function call like this:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token function">abspath</span> <span class="token punctuation">(</span><span class="token keyword">join</span> <span class="token string">"/"</span> <span class="token punctuation">[</span><span class="token string">"foo"</span> <span class="token string">"bar"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Many non-Lisp languages would write this as:</p>
<pre class="language-javascript"><code class="language-javascript"><span class="token function">abspath</span><span class="token punctuation">(</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>YAMLScript supports this style of function call as well.</p>
<p>YAMLScript is very flexible about how you can write function calls.
You could do the above in all the ways below:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">path1 =</span><span class="token punctuation">:</span> abspath(join("/" <span class="token punctuation">[</span>"foo" "bar"<span class="token punctuation">]</span>))<br><span class="token key atrule">path2 =</span><span class="token punctuation">:</span> (abspath (join "/" <span class="token punctuation">[</span>"foo" "bar"<span class="token punctuation">]</span>))<br><span class="token key atrule">path3 =</span><span class="token punctuation">:</span><br>  <span class="token key atrule">abspath</span><span class="token punctuation">:</span><br>    <span class="token key atrule">join "/"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>"foo" "bar"<span class="token punctuation">]</span><br><span class="token key atrule">=></span><span class="token punctuation">:</span> (def path4 abspath(join("/" <span class="token punctuation">[</span>"foo" "bar"<span class="token punctuation">]</span>)))</code></pre>
<p>Look closely at the last example (<code>path4</code>).
It looks like a Clojure form, but it actually makes use of prefix function
calls.</p>
<h3>Special Operators</h3>
<p>YAMLScript has a few special operators that are not part of Clojure.</p>
<p>The <code>..</code> operator is used to create a range of consectutive integers.
The expression <code>(1 .. 3)</code> is equivalent to the Clojure form <code>(range 1 4)</code> and
evaluates to the list <code>(1 2 3)</code>.
The expression <code>(3 .. 1)</code> is equivalent to the Clojure form <code>(range 3 0 -1)</code> and
evaluates to the list <code>(3 2 1)</code>.</p>
<p>The <code>+</code> and <code>*</code> operators are polymorphic.</p>
<ul>
<li><code>&quot;x&quot; * 3</code> -&gt; <code>&quot;xxx&quot;</code></li>
<li><code>&quot;x&quot; + &quot;y&quot; + &quot;z&quot;</code> -&gt; <code>&quot;xyz&quot;</code></li>
<li><code>{a: 1} + {b: 2}</code> -&gt; <code>{a: 1, b: 2}</code></li>
<li><code>[1 2] + [3 4]</code> -&gt; <code>[1 2 3 4]</code></li>
</ul>
<h3>Special Thanks</h3>
<p>I'd like to say thank you to David A. Wheeler for his web page <a href="https://dwheeler.com/readable/sweet-expressions.html">Curly infix,
Modern-expressions, and Sweet-expressions: A suite of readable formats for
Lisp-like languages</a>.</p>
<p>I adapted many of those ideas to make YeS-Expressions.</p>
<h3>Conclusion</h3>
<p>As I've said before, YAMLScript is very flexible, allowing you to decide how
much Lisp or YAML style you want to use at any point.
YeS-Expressions allow you to lean to the Lisp but keep it readable for your
non-Lisper friends.</p>
<p>Join me tomorrow for Day 12 of the YAMLScript Advent Calendar.</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Future Proof</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-12/"/>
      <updated>2023-12-12T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-12/</id>
      <content type="html">
        <![CDATA[
      <p>Santa has very little margin for error.
He has to get everything just right all in one night.</p>
<p>YAMLScript is a work in progress, and will be for a long time.
I'm trying to get it right, but I'm no Santa!
In fact I'm quite sure I'll get some things wrong.
That's just the nature of the beast when you're a programmer.</p>
<p>Also, have you ever wondered why the magic YAMLScript starter tag has that <code>/v0</code>
at the end?</p>
<h3>Welcome to Day 12 of the YAMLScript Advent Calendar!</h3>
<p>Today we'll discuss how YAMLScript is designed to be future proof.</p>
<p>I've been programming for quite a long time now.
I've learned that no matter how good I think an idea it today, I'll almost
certainly think of a better way to do it in the future.</p>
<p>This means I'll almost certainly want to make big changes to YAMLScript long
after it's in use in the real world.</p>
<p>I also believe that it is really important for things like APIs and progamming
languages to be stable and backwards compatible, basically forever.</p>
<p>If I could always have the freedom to make big changes to YAMLScript, but never
break backwards compatibility, then I could have my cake and eat it too.
And I think I can!</p>
<h3>The YAMLScript API Version</h3>
<p>I call <code>v0</code> the YAMLScript API version.
YAMLScript v0 isn't done yet, but it should be in the next couple months.
At that point I'll release it as a stable version of the API version <code>0</code>.</p>
<p>So you've seen that to make a <code>.ys</code> file executable, you need to add a special
starter tag to the top of the file:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token punctuation">---</span> <span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello!"</span></code></pre>
<p>Or you can write it with the shebang line:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment">#!/usr/bin/env ys-0</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello!"</span></code></pre>
<p>Leaving off that <code>0</code> here will make things not work as you intended.</p>
<p>You might also have noticed that when you install the <code>ys</code> binary CLI is is a
symlink to <code>ys-0.1.26</code>.
And there is another symlink called <code>ys-0</code> that points to <code>ys-0.1.26</code>.</p>
<p>This is all by design.</p>
<p>The leading <code>0</code> in <code>!yamlscript/v0</code> and in <code>bin/ys-0</code> and also in <code>0.1.26</code> is
the YAMLScript API version.</p>
<p>When YAMLScript v0 is declared stable, there will never be changes that break
backwards compatibility with the <code>v0</code> API version.</p>
<p>That means you can write YAMLScript programs today, and they will continue to
work forever, even if you upgrade to a new version of YAMLScript.</p>
<h3>New Versions of YAMLScript</h3>
<p>At some point after YAMLScript v0 is released as stable, I'll start working on
YAMLScript v1.</p>
<p>I can make any changes I want in YAMLScript v1, even ones that break backwards
compatibility with YAMLScript v0.
That's because I set up the rules such that you need to declare the version when
you write a YAMLScript program.</p>
<h3>Conclusion</h3>
<p>This doesn't mean that I don't think extremely carefully about every change I
make to YAMLScript.
But it does mean that I don't have to worry about everything being perfect
before I release stable v0.</p>
<p>That's exciting as I strive to make YAMLScript a great language today and a
better language in the future.</p>
<p>I hope that also encorages you write more YAMLScript today, knowing that it will
continue to work in the future.</p>
<p>That wraps up Day 12.
And that also means we're half way through the Advent Calendar.
I hope you're enjoying it as much as I am, and I hope the best is yet to come!</p>
<p>Tune in tomorrow for Day 13 of the YAMLScript Advent Calendar.</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>History Lesson</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-13/"/>
      <updated>2023-12-13T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-13/</id>
      <content type="html">
        <![CDATA[
      <p>Santa is Legend.
Legends have histories.
The histories of Santa are many and varied, some going back to the 4th century
AD.</p>
<p>YAMLScript's history is much shorter, but it's still a history.
Today I'd like to tell you a little bit about it.</p>
<h3>Welcome to Day 13 of the YAMLScript Advent Calendar!</h3>
<p>In the summer of 2022 I was gathering information about a computer system that I
was learning about.
I was putting the information into a YAML file.
At first I thought to myself, this YAML file could essentially be a
configuration file for running the system.
Then I thought, what if I could run the system by just &quot;running&quot; the YAML file?</p>
<p>Hmmmm... YAMLScript!
For me a project can only be started when it has a name.
I had the name, I loved the name, I loved the idea, I started the project!</p>
<p>I put together a prototype as a Perl module and published it to CPAN.
I knew that conceptually YAMLScript would be a Lisp, but to be honest I barely
knew what a Lisp was.</p>
<h3>One True YAML</h3>
<p>Earlier in the year I had come to the conclusion that the YAML spec and all of
the YAML implementations were too hard to fix.
I had spent the second half of 2021 trying to fix YAML, with a <a href="https://yaml.org/spec/1.2.2/ext/team/">core group</a> of five people, and it slowly became
obvious that it was a lost cause.
It was just too much work to get everyone to agree on anything, let alone
everything.</p>
<p>A possibly better solution was to create a new YAML framework (based on the
current YAML 1.2 spec) and publish it in 42 different languages.</p>
<p>At least this way there would be a set of quality YAML implementations that were
the same in every language.
The main problem with this idea was simply learning (and remembering!) how to
publish a library in 42 different languages!</p>
<p>I decided to write a meta publishing framework that would allow me to publish
to any language using the same simple commands.
I called this framework <a href="https://github.com/ingydotnet/pst">PST - Package Super Tool</a>.</p>
<p>In doing that I had to pick 42 languages and start learning a bit about each of
them.
At some point I came across Clojure and thought it was interesting.</p>
<h3>Make a Lisp</h3>
<p>Around the start of 2023 I started thinking about YAMLScript again.
My fledgling language with just a toy implementation in Perl.
I knew YAMLScript was going to be a Lisp, but I didn't know much about Lisps.
I asked the internet how to make a Lisp and it told me to read <a href="https://github.com/kanaka/mal/blob/master/process/guide.md">Make a Lisp</a>!</p>
<p>Make a Lisp (Mal) is a project that walks you through making a baby
Clojure-inspired Lisp implementation in the programming language of your choice.
It has eleven chapters, each with a set of tests that you must pass before you
can move on to the next chapter.
At the end you have a working Lisp implementation and you have to use it to run
the Mal implementation written in Mal and make sure it passes all the tests!</p>
<p>I decided to do Mal in Perl (even though there was already a Perl
implementation).
There are nearly 100 implementations of Mal in over 70 different languages.
It took me about 2 weeks to get through the whole thing.
By the end I really felt like I knew what a Lisp was, how Lisps worked and how
to make one.</p>
<p>When I finish the Mal course I decided to do it again but this time in
YAMLScript, a language that didn't exist yet.
This was really easy and fun.
I just ported the Mal in Mal code to a YAML form that I found pleasing and
acceptable as a programming language; essentially making up YAMLScript as I went
along.</p>
<p>I also wanted to go much further with the Perl implementation.
I decided I would create a full implementation of Clojure on Perl based off of
my Mal in Perl code.
I call this project <a href="https://github.com/lingy-lang/lingy">Lingy</a> (currently
<a href="https://metacpan.org/dist/Lingy">available on CPAN</a>).
This is when I started learning Clojure. (Spring 2023).</p>
<h3>TPRC 2023</h3>
<p>I was also helping to organize the <a href="tprc.to">TPRC 2023</a> (Perl and Raku)
conference.
I decided I would give a talk called <a href="https://www.youtube.com/watch?v=9OcFh-HaCyI">Lingy and YAMLScript</a>.
I had to get a working Lingy and a working YAMLScript implementation in Perl by
the end of June.</p>
<p>After I gave the talk I noticed it was getting a lot of attention.
A lot more views on youtube than any other talk at the conference.
I realized this was happening because the words &quot;Clojure&quot; and &quot;Java&quot; were in the
talk description.</p>
<h3>The Clojure Community</h3>
<p>A lovely man named Peter Strömberg reached out to me and asked if I would be
interested in joining the <a href="https://clojurians.slack.com/">Clojure Community Slack</a>.
Peter is the author of <a href="https://calva.io/">Calva</a>, a Clojure IDE for VS Code,
one of the best ways to write and work with Clojure.
I joined right away and he pointed me in all the right directions and got me
talking to all the right people.</p>
<p>I soon learned about <a href="https://www.graalvm.org/">GraalVM</a> and <a href="https://github.com/babashka/sci">SCI</a> written by Michiel Borkent, a man to whom I owe
much credit for helping me with many deep technical issues I encountered.
Michiel is the author of <a href="https://babashka.org/">Babashka</a>, a popular way to do
shell scripting in Clojure.
SCI is the Clojure runtime engine that Babashka uses and that YAMLScript now
uses as well!</p>
<p>All the pieces started falling into place, and I got a clear vision of what
YAMLScript should become... AND how relatively easy it would be to make it
happen thanks to the Clojure ecosystem.
I started rewriting the YAMLScript compiler and runtime in Clojure and
rebuilding it into what it is today.</p>
<h3>December 1st, 2023</h3>
<p>At some point in the Fall, I decided that I would start blogging about
YAMLScript every day in December 2023, in the Programming Project Advent
Calendar style.</p>
<p>I thought I would easily get everything done by Dec 1st but to be honest, even
as I write this now, there is still so much to do.
Some days I really want to write about a particular topic, but the code isn't
quite ready yet.</p>
<p>But all that said, it's all working out pretty dang well.
I'm loving this language and project!</p>
<p>I have the highest hopes of hopes for YAMLScript in 2024.</p>
<p>There's a lot more details I could add here but it's getting late and I need to
get some sleep.</p>
<h3>Join me again tomorrow for Day 14 of the YAMLScript Advent Calendar!</h3>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Stocking Stuffers</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-14/"/>
      <updated>2023-12-14T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-14/</id>
      <content type="html">
        <![CDATA[
      <p>It's always nice to get a little something extra in your stocking whilst waiting
for the big guy to show up on the big day.</p>
<p>Learning eveything you need to know about YAMLScript in 24 days is a tall order.
I still have a quite a bit to learn about it myself! :-)</p>
<p>It helps to learn the small stuff first.</p>
<h3>Welcome to Day 14 of YAMLScript Advent 2023!</h3>
<p>Today we'll look at some of the little things that make YAMLScript a joy to work
with.
We'll go over some of the basic syntax, semantics, features and commands of
YAMLScript.</p>
<p>What if...
What if?
What <code>if</code>!</p>
<p>Let's start out by looking at some of the various ways you can write the
ubiquituous <code>if</code> statement in YAMLScript.</p>
<p>To set the tone here, let's code an <code>if</code> in another simple language, Python,
since it can often be used as pseudocode:</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">if</span> a <span class="token operator">></span> b<span class="token punctuation">:</span><br>  <span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token string">" is greater than "</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><br><span class="token keyword">else</span><span class="token punctuation">:</span><br>  <span class="token keyword">print</span><span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token string">" is greater than or equal to "</span> <span class="token operator">+</span> a<span class="token punctuation">)</span></code></pre>
<p>Abstractly we are saying that if some condition is true, then do one thing,
otherwise do another thing.</p>
<p>Since YAMLScript compiles to Clojure, it's important to understand how Clojure
does <code>if</code>.
Let's look at the same code in Clojure.</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">></span> a b<span class="token punctuation">)</span><br>  <span class="token punctuation">(</span><span class="token keyword">println</span> <span class="token punctuation">(</span><span class="token keyword">str</span> a <span class="token string">" is greater than "</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><br>  <span class="token punctuation">(</span><span class="token keyword">println</span> <span class="token punctuation">(</span><span class="token keyword">str</span> b <span class="token string">" is greater than or equal to "</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>The Clojure code has an <code>if</code> command followed by:</p>
<ul>
<li>a condition form</li>
<li>a form to run if the condition is true</li>
<li>a form to run if the condition is false (optional)</li>
</ul>
<p>This is how all <code>if</code> statements look in Clojure.</p>
<p>There are many ways to do the same thing in YAMLScript.
Here's a one good way to do it:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">if (a > b)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"$a is greater than $b"</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"$b is greater than or equal to $a"</span></code></pre>
<blockquote>
<p>All the YAMLScript examples in this post use code-mode which requires the
<code>!yamlscript/v0</code> tag at the top of the file.
We'll leave it out of the rest of the examples for brevity.</p>
</blockquote>
<p>Let's see what happens when we compile that YAMLScript program:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> if.ys<br><span class="token punctuation">(</span>if<br> <span class="token punctuation">(</span><span class="token operator">></span> a b<span class="token punctuation">)</span><br> <span class="token punctuation">(</span>say <span class="token punctuation">(</span>str a <span class="token string">" is greater than "</span> b<span class="token punctuation">))</span><br> <span class="token punctuation">(</span>say <span class="token punctuation">(</span>str b <span class="token string">" is greater than or equal to "</span> a<span class="token punctuation">))</span><span class="token punctuation">)</span></code></pre>
<p>We get the exact same Clojure code as above! (in a slightly different format)
Note that <code>say</code> is an alternate way to write <code>println</code> in YAMLScript, but you
can use <code>println</code> if you prefer to type more.</p>
<p>The <code>if</code> command is an interesting YAML mapping.
The key has both the <code>if</code> command symbol and the condition form in it.
The value is another YAML mapping with two pairs: one for the &quot;then&quot; form and
one for the &quot;else&quot; form.</p>
<blockquote>
<p>Notice that both pairs have the same key, <code>say</code>.
Duplicate keys aren't allowed in YAML, but they are allowed in YAMLScript
code-mode.
That's because the YAMLScript compiler (a fancy YAML loader) isn't loading the
mapping into a data structure, but rather into an AST.
For the AST, the &quot;duplicate keys&quot; are no problem, because they're not actually
being used as mapping keys.
By contrast, in YAMLScript data-mode, duplicate keys are not allowed because
they are actually being used as mapping keys (like normal YAML).</p>
</blockquote>
<p>YAMLScript code-mode does everything using only YAML block mappings or scalars.
Using sequences or flow nodes is not allowed in code-mode.</p>
<details><summary><strong style="color:green">Quick YAML Jargon Review</strong></summary>
<hr>
<ul>
<li>node - a mapping, sequence or scalar</li>
<li>collection - a mapping or sequence data structure</li>
<li>mapping - a key/value data structure; aka hash, dictionary, object,</li>
<li>sequence - an ordered list of values; aka array, list, vector</li>
<li>scalar - a single value; aka string, number, boolean, null</li>
<li>block - the normal YAML indented style (with <code>-</code> before each sequence node)</li>
<li>flow - the JSON looking style with braces and brackets</li>
<li>plain scalar - a scalar that is not quoted</li>
<li>double quoted scalar - a scalar that is quoted with double quotes</li>
<li>single quoted scalar - a scalar that is quoted with single quotes</li>
<li>literal scalar - a scalar that is quoted with <code>|</code></li>
<li>folded scalar - a scalar that is quoted with <code>&gt;</code></li>
<li>pair - a key/value pair in a mapping</li>
<li>key - the first part of a pair or lefthand side</li>
<li>value - the second part of a pair or righthand side</li>
</ul>
<blockquote>
<p>YAML block mapping values can span multiple lines, and can start after the
line with the key and the <code>:</code> separator.</p>
</blockquote>
<hr>
</details>
<p>Let's write the <code>if</code> statement using YAML scalars instead of a mapping:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">if (a > b)</span><span class="token punctuation">:</span><br>  say("$a is greater than $b")<br>  say("$b is greater than or equal to $a")</code></pre>
<p>If you <code>ys --compile</code> this you get the exact same thing as the previous compile.
In this case the value of the top YAML mapping is just a scalar.
Even though it is 2 lines of code, it represents a a single long line containing
two function calls, one for &quot;then&quot; and one for &quot;else&quot;.</p>
<p>So that's 2 ways to write the <code>if</code> statement in YAMLScript.
The two best ways.
There are several other ways to do it that are less readable but still valid
syntax.
And there's nothing special about this being an <code>if</code> statement; the same rules
apply to all YAMLScript commands in general.</p>
<h3>General Syntax Rules</h3>
<p>By default in code-mode, a mapping is a set of pairs where each pair compiles to
a form:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">a</span><span class="token punctuation">:</span> b c d<br><span class="token key atrule">a b</span><span class="token punctuation">:</span> c d<br><span class="token key atrule">a b c</span><span class="token punctuation">:</span> d<br><span class="token key atrule">a b c d</span><span class="token punctuation">:</span><br><span class="token key atrule">=></span><span class="token punctuation">:</span> (a b c d)<br><span class="token key atrule">=></span><span class="token punctuation">:</span> a(b c d)<br><span class="token key atrule">a</span><span class="token punctuation">:</span><br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> b<br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> c<br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> d<br><span class="token key atrule">a b</span><span class="token punctuation">:</span><br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> c<br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> d</code></pre>
<blockquote>
<p><em><strong>This is important to understand!</strong></em></p>
</blockquote>
<p>All the pairs above compile to the same Clojure form: <code>(a b c d)</code>, which is
calling a function <code>a</code> with 3 arguments: <code>b</code>, <code>c</code> and <code>d</code>.</p>
<p>The <code>=&gt;</code> symbol is a special YAMLScript key symbol that can be used when you
only care about using a scalar in that spot.
Since YAMLScript always needs to be valid YAML, this can often be useful.</p>
<p>So now you can see what I was talking about with all the ways to write an <code>if</code>
statement.
Only the <code>a b: c d</code> forms look normal to most programmers.</p>
<h3>YAMLScript Loops</h3>
<p>Let's look at another common control structure: looping.</p>
<p>There are a lot of ways to do loops in Clojure (thus YAMLScript).
They have lots of subtle differences and properties.
We'll just cover one or two here for now.
(We're not even halfway through December yet!)</p>
<p>Here's a simple <code>for</code> loop in Python that prints the numbers 0 through 4:</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>  <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span></code></pre>
<p>Here's the same loop in Clojure:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">for</span> <span class="token punctuation">[</span>i <span class="token punctuation">(</span><span class="token keyword">range</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">println</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>So in YAMLScript we can do this:</p>
<pre class="language-yaml"><code class="language-yaml">for <span class="token punctuation">[</span>i range(5)<span class="token punctuation">]</span><span class="token punctuation">:</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span> i</code></pre>
<p>When we compile this we get:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> for.ys<br><span class="token punctuation">(</span>for <span class="token punctuation">[</span>i <span class="token punctuation">(</span>range <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">(</span>say i<span class="token punctuation">))</span></code></pre>
<p>Let's run it:</p>
<pre class="language-bash"><code class="language-bash">$ ys for.ys<br>$</code></pre>
<p>Nothing happened!</p>
<p>This has to do with some of the more advanced understanding of Clojure.
Specifically laziness and evaluation.</p>
<p>To be honest, the Clojure code I wrote above would not print anything depending
on how you ran it.
If you ran it in the Clojure REPL or as a one liner it would print the numbers.
If you ran it as a program it would not print anything.</p>
<p>To make things work as expected in the REPL Clojure forces the lazy structures
to be evaluated.</p>
<p>Clojure also has a <code>doall</code> function that forces evaluation.
Let's use that in our YAMLScript program:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">doall</span><span class="token punctuation">:</span><br>  for <span class="token punctuation">[</span>i range(5)<span class="token punctuation">]</span><span class="token punctuation">:</span><br>    <span class="token key atrule">say</span><span class="token punctuation">:</span> i</code></pre>
<p>Now when we compile and run it we get:</p>
<pre class="language-bash"><code class="language-bash">$ ys for.ys<br><span class="token number">0</span><br><span class="token number">1</span><br><span class="token number">2</span><br><span class="token number">3</span><br><span class="token number">4</span></code></pre>
<p>Success!
But at what cost?
That's a lot of code to print 5 numbers.</p>
<p>YAMLScript has a nicer way to do this.
It has an <code>each</code> command that calls <code>doall</code> and <code>for</code> for you:</p>
<pre class="language-yaml"><code class="language-yaml">each <span class="token punctuation">[</span>i range(5)<span class="token punctuation">]</span><span class="token punctuation">:</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span> i</code></pre>
<p>or:</p>
<pre class="language-yaml"><code class="language-yaml">each <span class="token punctuation">[</span>i range(5)<span class="token punctuation">]</span><span class="token punctuation">:</span> say(i)</code></pre>
<p>or:</p>
<pre class="language-yaml"><code class="language-yaml">each <span class="token punctuation">[</span>i (0..4)<span class="token punctuation">]</span><span class="token punctuation">:</span> say(i)</code></pre>
<p>Doesn't it seem strange to you that <code>(range 5)</code> really means 0 to 4?
There are technical reasons for this, but it's not very intuitive.</p>
<p>YAMLScript's <code>..</code> operator does what you told it to.
It really just compiles to <code>(ys.std/rng 0 4)</code> which is a standard YAMLScript
function that returns a range from 0 to 4.</p>
<p>It also works in reverse:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-e</span> <span class="token string">'each [i (4..0)]: say(i)'</span><br><span class="token number">4</span><br><span class="token number">3</span><br><span class="token number">2</span><br><span class="token number">1</span><br><span class="token number">0</span></code></pre>
<p>To do that in Clojure you'd have to write:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">doall</span><br>  <span class="token punctuation">(</span><span class="token keyword">for</span> <span class="token punctuation">[</span>i <span class="token punctuation">(</span><span class="token keyword">range</span> <span class="token number">4</span> -<span class="token number">1</span> -<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><br>    <span class="token punctuation">(</span><span class="token keyword">println</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Sheesh!</p>
<hr>
<p>I know that was only 2 or 3 things in your stocking, but they were quite a lot
to chew on.
Maybe we'll have to stuff your stocking a couple more times this month!</p>
<p>See you tomorrow for Day 15 of YAMLScript Advent 2023!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Naughty is Nice!</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-15/"/>
      <updated>2023-12-15T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-15/</id>
      <content type="html">
        <![CDATA[
      <p>As the architect of a major world holiday, Santa Claus has hard design choices
to make.
What is Suki going to get this year?
He keeps it simple with the standard Naughty-Or-Nice algorithm.</p>
<p>As architects of an aspiring new programming language, the YAMLScript folks have
design choices to make as well!</p>
<p>Naughty-Or-Nice should not be discounted but what about Naughty-And-Nice?
Naughty-Xor-Nice???</p>
<p>My personal favorite?</p>
<p><strong>Naughty-<em>Is</em>-Nice!!</strong></p>
<h3>Welcome to Day 15 of the YAMLScript Advent 2023!</h3>
<p>Today I want to carry on a bit about what I think about whilst designing
YAMLScript syntax, semantics and features.</p>
<p>The unwavering rule here is that YS needs to be written as valid YAML, and it
needs to become valid Clojure.</p>
<p>Those two things don't look much alike.
However, remember that JSON is a subset of YAML and JSON does look a little bit
more like a Lisp (Clojure is a Lisp).
YAML's data model is a superset of JSON's data model.
So there are pathways and connections to be made between YAMLScript and Clojure.</p>
<p>Given that, my next move could have been to make YAMLScript be as close to
Clojure as possible (while still satifying those constraints).
I did try that for about 7 minutes...
The results were just not &quot;feel good&quot;.</p>
<p>Time for Plan B.</p>
<h3>mal.ys</h3>
<p>I mentioned this in my recent <a href="/blog/advent-2023/dec-13/">History Lesson</a>...
I had just finished my Perl implementation of <a href="https://github.com/kanaka/mal">Make a Lisp</a> (mal) and I decided to try to make a YAMLScript
version next even though there was no YAMLScript yet.</p>
<p>Take a look at the implementation of <a href="https://github.com/kanaka/mal/blob/master/impls/mal/stepA_mal.mal">Mal in Mal</a>.</p>
<p>As I said before when you complete the exercise of writing a version of Mal in
the programming language of your choice, your final goal is to pass the Mal test
suite by running the Mal implementation of Mal using your newly created Mal
implementation.</p>
<p>I'll admit that even now, that is a bit mind bending!</p>
<p>I decided to port the Mal in Mal implementation (a Lisp) to YAMLScript.
I revised it over and over until I liked how it looked and felt.
Certainly I had to think about how my new creation would scale to other
YAMLScript programming problems.</p>
<p>Here's what I came up with on March 12th, 2023: <a href="https://github.com/ingydotnet/mal/blob/yamlscript/impls/yamlscript/src/yamlscript.ys">yamlscript.ys</a>.</p>
<p>This code hurts my eyes now.
YAMLScript has come a long way since then.</p>
<p>The point here is that my modus operandi remained the same.
Write programs in YAMLScript (often by porting them from existing Clojure
programs) and make sure they don't suck.
Keep refining the language until it feels right from all angles.</p>
<h3>Breaking the Rules</h3>
<p>Clojure and Lisps in general have very simple syntax rules.
Nested parens with a function name first, followed by arguments.
When things don't feel right in certain cases, Lisps have their coveted macros
to rearrange the things in parens to look nicer and work as intended.</p>
<p>Lispers take pride in this simplicity and uniformity.
They tend to look down on their bespoken cousins like Perl, Python and Ruby;
even though those languages give much credit to Lisp for their dynamic natures.</p>
<p>I'm new to Lisp, but as the author of a new programming language written
entirely in a Lisp, I can honestly say that I enjoy it.</p>
<p>That said, I embrace diversity and I enjoy many different styles of programming.
I'm also not afraid to break a few rules when it makes sense.</p>
<p>I guess if there's one technology that I know and am most known for, it's YAML.
I'd like to think that I know what YAML users like and what things they desire
that YAML doesn't provide.</p>
<p>I should say &quot;didn't provide&quot;, because YAMLScript is going to provide almost
anything they could want.</p>
<p>If I were to list the top 3 things that YAML users want:</p>
<ul>
<li>Composability via file inclusion</li>
<li>String interpolation (aka templating)</li>
<li>Simple composition and transformation functions:
<ul>
<li>Map merging</li>
<li>Sequence concatenation</li>
<li>String manipulation</li>
<li>etc.</li>
</ul>
</li>
</ul>
<p>Technologies that have made major use of YAML, like Kubernetes, Ansible and
OpenAPI, have all had to invent their own ways to provide these features.</p>
<p>With YAMLScript, all the things they've done and more are available everywhere
and work the same for everyone.
And all without breaking the things those technologies already do.</p>
<p>I suppose this is all to say that in general YAMLScript will follow Clojure's
lead when its awesome, but will also look for cleaner ways to do things when it
feels needed.</p>
<p>Maybe you think I'm being Naughty.
I am, but… <strong>Naughty is Nice!</strong></p>
<h3>The Naughty List (aka The Nice List :- )</h3>
<p>say what you want…</p>
<p>No, literally…</p>
<p><code>say</code> it!</p>
<p>In Clojure you use <code>println</code> to print a string with a newline added to the end.
In Python it's <code>print</code>.
Ruby <code>puts</code> it out there.
Perl people <code>say</code> things.</p>
<p>I've always been a fan of doing more with less.
Clojure code overall makes it easy to accomplish big things with less code.
But from the word by word perspective, Clojure is a bit long-winded at times.</p>
<p>YAMLScript has a <code>say</code> function in the standard library that does the same thing
as <code>println</code> in Clojure (but with 4 less letters).
But I didn't take <code>println</code> away from you either.
That's your choice.</p>
<p>YS is about choices.
It embraces the <a href="https://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it">TMTOWTDI</a> philosophy.
You saw yesterday how many different ways there are to call functions in
YAMLScript.
I tend to respect function names whose length is inversely proportional to how
often they are used.</p>
<p>Another good example is Clojure's <code>*command-line-args*</code> dynamic variable.
YS calls it <code>ARGV</code>, a shorter name that is seen in other languages.</p>
<hr>
<p>I'm here, Doc!</p>
<p>One thing that YAML has that Clojure doesn't is &quot;heredocs&quot;.
A heredoc is a way to write a multiline string without having to escape any of
the characters in it.
That means you can write almost any string in your program to look exactly like
it would in a text file or printed out.</p>
<p>Ruby has heredocs because it stole them from Perl who in turn stole them from
Shell.
YAML has literal scalars which are even better than heredocs because they have
no ending marker.
You can embed any text content simply by indenting it appropriately.
YAML has this awesome feature because I loved it in Perl and wanted it in YAML!
True story.</p>
<p>YAMLScript extends YAML's literal scalars by adding interpolation to them.
Using the <code>$some-var</code> or <code>$(some-expression)</code> inline syntax, YAMLScript will
eval and insert the values just like you'd expect.</p>
<p>This makes things like templating and testing multi-line output a breeze.
In fact, the YAMLScript test suite (testing YAMLScript inputs, Clojure outputs,
and intermediary stage forms) is based on <a href="https://github.com/yaml/yamlscript/blob/main/core/test/compiler-stack.yaml">YAML Literals</a>.</p>
<hr>
<p>YeS, we can!</p>
<p>We talked about YAMLScript's YeS Expression Syntax a few days ago.
One thing Lisps can't do is have real infix math expressions like:
<code>(1 + 2 * 3)</code>.
Macros can reorder things but the macro name has to be first.
Thus you could do <code>(infix 1 + 2 * 3)</code> but at that point you've already lost.</p>
<p>YAMLScript tries to support as much infix expressions as it can while still
keeping things sane, readable and predictable.
You can write <code>1 + 2</code> to mean <code>(+ 1 2)</code> and <code>1 + 2 + 3</code> to mean <code>(+ 1 2 3)</code>.
But you can't write <code>1 + 2 * 3</code> because that involves precedence, and that's
where things get messy.</p>
<p>In a day or two I'll show you YS's path lookup syntax which looks like:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">val =</span><span class="token punctuation">:</span> obj.foo.3."bar baz".map(inc)</code></pre>
<p>This a is very readable, obvious and powerful way to chain lookups and function
calls together.</p>
<p>But it's really just using the same infix syntax as above with the YAMLScript
<code>.</code>  chaining operator!</p>
<hr>
<p>How do you usually structure your programs?</p>
<p>I'm a top-down kind of guy.
I like to start with the main entry point function calling other functions and
then define those functions (which use other functions to be defined later).</p>
<p>Clojure is a bottom-up language by nature.
You can't call a function until it's defined.
Well, you can, but you have to use the <code>declare</code> function to do it.
The Clojure people I've interacted so far tend to avoid <code>declare</code> and just go
bottom-up.</p>
<p>YAMLScript wants you to be you!</p>
<p>You can write things in any order you want to.</p>
<p>A big advantage of compiling to an existing language is that you are free to
generate uglier output code (that is rarely seen) to support prettier input code
(that you have to look at all the time).</p>
<p>In this case, the YS compiler scans the AST near the end of the compilation and
finds all the functions that were called before they were defined.
It then inserts a <code>declare</code> expression for them at the top of the output code.</p>
<p>Problem solved!</p>
<blockquote>
<p>If you are interested in why Clojure's author Rich Hickey chose to make
Clojure &quot;bottom-up&quot;, read about it <a href="https://gist.github.com/reborg/dc8b0c96c397a56668905e2767fd697f#why-clojure-compiler-is-single-pass-arent-many-possible-optimizations-lost-this-way">here</a>.
Then read the rest of that page.
It's full of great insights into the design of Clojure and programming in
general.</p>
</blockquote>
<hr>
<p>When I started designing the YAML language in 2001 the main goals were:</p>
<ul>
<li>Make something awesome (that my Mom could use)</li>
<li>More content, less markup</li>
<li>See/share data the same in any programming language</li>
</ul>
<p>YAMLScript's primary audience is people who already use YAML and wish it could
do more.
Clojure and Lisp have so much to offer other programming languages.
It's like a deep well of awesome that YAMLScript users can tap into when they
are ready.
But if they just want to <code>load</code> and <code>merge</code> some YAML files, like they saw their
friends doing, they can stop there.</p>
<p>I hope that gives you a taste of the kinds of things I think about when I'm
designing YAMLScript.
You can't please everyone, but if you give people choices, the only people that
get upset are the ones who don't like choices. :- )</p>
<p>See you tomorrow? That's Day 16 of the YAMLScript Advent 2023!!!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Let Lambda Come Over</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-16/"/>
      <updated>2023-12-16T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-16/</id>
      <content type="html">
        <![CDATA[
      <p>We know the names of Santa's reindeer: Dasher, Dancer, Prancer, Vixen, Comet,
Cupid, Donner, Blitzen and Rudolph.
And his elves: Alabaster Snowball, Bushy Evergreen, Pepper Minstix, Shinny
Upatree, Sugarplum Mary, Wunorse Openslae, and the head elf, Bernard.</p>
<p>But we don't know the names of Santa's lambda reindeer and elves.
Why would we?
They are anonymous!
They're also the hardest working of the bunch.</p>
<h3>Welcome to Day 16 of the YAMLScript Advent Calendar</h3>
<p>Today we're going to talk about YS lambdas and their frontman named &quot;let&quot;.</p>
<p>It's a kinda of a big deal in your programming journey when you realize the
power of <em>NOT</em> naming things, especially functions.
Next you learn about functions that take functions and turn them into other
functions and your head explodes.
(Not literally because then you are dead and can't enjoy the power of lambdas).</p>
<p>A lambda is a general term for an anonymous function, ie one that is not named.
In Clojure you create can create them in two different ways.
Here's a simple lambda that squares a number:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token comment">;; Using the fn keyword</span><br><span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">*</span> x x<span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token comment">;; Using the #() reader macro</span><br><span class="token operator">#</span><span class="token punctuation">(</span><span class="token keyword">*</span> % %<span class="token punctuation">)</span></code></pre>
<p>Note: Clojure just calls them &quot;anonymous functions&quot;.</p>
<p>Here's both of those in YAMLScript:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># Using the fn keyword</span><br>fn <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">:</span> (x * x)<br><span class="token comment"># Using the #() reader macro</span><br>\(% * %)</code></pre>
<p>The latter method is shorter but the former is more flexible.</p>
<p>Typically you use lambdas to return closures, which are functions that have
access to the variables in the scope where they were created.</p>
<p>Here's a function the returns a function that adds a number to another number:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn adder(x)</span><span class="token punctuation">:</span> \(% + x)<br><span class="token key atrule">add-5 =</span><span class="token punctuation">:</span> adder(5)<br><span class="token key atrule">add-5</span><span class="token punctuation">:</span> <span class="token number">10</span>           <span class="token comment"># => 15</span></code></pre>
<p>In the <code>adder</code> function, the <code>x</code> variable gets created in the scope of the
function and is not available outside of it.
But we returned a function that &quot;closed over&quot; it so that it could be used by
the returned function later on.</p>
<h2>let in the lexicals!</h2>
<p>In the <code>adder</code> function, the <code>x</code> variable was a parameter to the function and
created a lexical variable whose scope was the function body.
How do we create more lexical variables in to use in a function?</p>
<p>In Python you we get the lexicals <code>x</code>, <code>y</code> and <code>z</code> by defining them in the
function body:</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span><br>    y <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><br>    z <span class="token operator">=</span> y <span class="token operator">/</span> <span class="token number">2</span><br>    <span class="token keyword">return</span> z</code></pre>
<p>Pretty clean and simple.</p>
<p>In Clojure we use the <code>let</code> keyword to create more lexical variables:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> foo <span class="token punctuation">[</span>x<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>y <span class="token punctuation">(</span><span class="token keyword">+</span> x <span class="token number">1</span><span class="token punctuation">)</span><br>        z <span class="token punctuation">(</span><span class="token keyword">/</span> y <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><br>    z<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>The <code>let</code> keyword takes a vector (array in <code>[]</code>) of bindings and then a body
of code to execute.
The binding vector contains one or more pairs of a name (symbol) and an
expression that evaluates to a value.</p>
<p>The Clojure code looks a little more complicated than the Python code.
That's the price for needing to write everything the same way with
parenthesized lists.</p>
<p>Let's see how YAMLScript does it:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn foo(x)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">y =</span><span class="token punctuation">:</span> x + 1<br>  <span class="token key atrule">z =</span><span class="token punctuation">:</span> y / 2<br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> z</code></pre>
<p>How can that be the same as the Clojure code?!?!
There's no <code>let</code> keyword.
Let's try compiling it and see what happens:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-c</span> let.ys<br><span class="token punctuation">(</span>defn foo <span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token punctuation">(</span>let <span class="token punctuation">[</span>y <span class="token punctuation">(</span>_+ x <span class="token number">1</span><span class="token punctuation">)</span> z <span class="token punctuation">(</span>/ y <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> z<span class="token punctuation">))</span></code></pre>
<p>Well look at that!
It generated the <code>let</code> keyword for us.</p>
<p>The <code>a =: b</code> YS syntax has super powers.
When used at th top level in a program it simply creates a <code>def</code> expression like
<code>(def a b)</code>, but when used inside another YS mapping it turns into a <code>let</code>!
Not only that, but when their are multiple <code>x := y</code> expressions in a row, they
are all put into the same <code>let</code> binding vector, just like you'd do if you wrote
the Clojure code by hand.</p>
<p>The big win here is that the code you write looks clean like the Python code,
but works perfectly as Clojure code.
It's one of my favorite features of YAMLScript.
The need for lexical variables is constant and this makes it painless.</p>
<h3>LoL!!!</h3>
<p>Let and Lambdas are 2 of the most important features for Lisp (thus Clojure)
programmers.
There's a famous book called &quot;Let Over Lambda&quot; that is a must read for any
serious Lisp programmer.
Note: I haven't read it yet, but I am serious, therefore it's a must!</p>
<p>Here's a great snippet from the book:</p>
<blockquote>
<p>Sometimes it's called a closure, other times a saved lexical environment.
Or, as some of us like to say, let over lambda.
Whatever terminology you use, mastering this concept of a closure is the first
step to becoming a professional lisp programmer.
In fact, this skill is vital for the proper use of many modern programming
languages, even ones that don't explicitly contain let or lambda, such as Perl
or Javascript.</p>
</blockquote>
<p>Let over Lambda (LoL!) is built around this simple Lisp idiom:</p>
<pre class="language-lisp"><code class="language-lisp"><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token car">x</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>  <span class="token punctuation">(</span><span class="token lambda"><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token arguments"></span><span class="token punctuation">)</span></span> x<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>But there' a little more to it than that.
In most Lisps the <code>x</code> value is mutable.
That means the lambda can change the value of <code>x</code> when it is called.
This is a very powerful feature because it allows you to create functions that
can hold state.
You can use this to create iterators, generators, and even object oriented
systems.</p>
<p>But in Clojure all values are immutable.
This is foundational to making Clojure a functional and thread safe language.
But Clojure is also famous for being a <strong>practical</strong> (functional and thread
safe) language.
It has a kind of value that <em>is</em> mutable.
These are called atoms.</p>
<p>Let's make the quintessential LoL example, a counter, in Clojure:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> new-counter <span class="token punctuation">[</span>n<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token punctuation">(</span><span class="token function">atom</span> n<span class="token punctuation">)</span><span class="token punctuation">]</span><br>    <span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token function">swap!</span> x inc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token keyword">def</span> counter <span class="token punctuation">(</span><span class="token function">new-counter</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><span class="token punctuation">(</span><span class="token keyword">println</span> <span class="token punctuation">(</span><span class="token function">counter</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">#</span> => <span class="token number">11</span><br><span class="token punctuation">(</span><span class="token keyword">println</span> <span class="token punctuation">(</span><span class="token function">counter</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">#</span> => <span class="token number">12</span><br><span class="token punctuation">(</span><span class="token keyword">println</span> <span class="token punctuation">(</span><span class="token function">counter</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">#</span> => <span class="token number">13</span></code></pre>
<p>Writing this in YAMLScript is a simple port:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">defn new-counter(n)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">x =</span><span class="token punctuation">:</span> atom(n)<br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> \(swap<span class="token tag">!</span> x inc)<br><span class="token key atrule">counter =</span><span class="token punctuation">:</span> new<span class="token punctuation">-</span>counter(10)<br><span class="token key atrule">say</span><span class="token punctuation">:</span> counter() <span class="token comment"># => 11</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> counter() <span class="token comment"># => 12</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> counter() <span class="token comment"># => 13</span></code></pre>
<p>Someone told me the other day that YAMLScript was a &quot;lol language&quot;.
This must be what they meant.</p>
<p>The lols continue tomorrow, on Day 17 of the YAMLScript Advent Calendar!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Rosetta Code</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-17/"/>
      <updated>2023-12-17T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-17/</id>
      <content type="html">
        <![CDATA[
      <p>How does Santa read all the signs in all the languages of the world?
That's a lot of languages to know on top of all the other things he has to do.
Luckily he has his trusty polyglot elf, Rosetta, at his side.
Bet you didn't know that!</p>
<h3>Welcome to Day 17 of the YAMLScript Advent Calendar</h3>
<p>A cool guy named Mike Mol made a website called <a href="https://rosettacode.org/wiki/Rosetta_Code">Rosetta Code</a> for programmers who want to
learn all the programming languages of the world!</p>
<p>It's a wiki that has well over 1000 programming tasks and almost 1000
programming languages.
The idea is for people to contribute solutions to the tasks in as many
languages as they can.</p>
<p>I've been a fan of Rosetta Code for years.
Here's one of my all time favorite programs from the site:
<a href="https://rosettacode.org/wiki/FizzBuzz/EsoLang#SNUSP">FizzBuzz in SNUSP</a>!!</p>
<p>One thing people like to use Rosetta Code for is to show off a new language.
YAMLScript is a new language, and I've put a few solutions up there myself:</p>
<ul>
<li><a href="https://rosettacode.org/wiki/99_Bottles_of_Beer#YAMLScript">99 Bottles of Beer</a></li>
<li><a href="https://rosettacode.org/wiki/FizzBuzz#YAMLScript">FizzBuzz</a></li>
<li><a href="https://rosettacode.org/wiki/Hello_world/Text#YAMLScript">Hello world/Text</a></li>
<li><a href="https://rosettacode.org/wiki/Factorial#YAMLScript">Factorial</a></li>
<li><a href="https://rosettacode.org/wiki/Fibonacci_sequence#YAMLScript">Fibonacci sequence</a></li>
</ul>
<p>Adding solutions to Rosetta Code is a one of the best ways I've found to figure
out what YAMLScript needs to do and what it needs to do better.</p>
<h3>Rosetta Code Data</h3>
<p>The Rosetta Code website is a great resource, but it's a bit clunky to use.
It would be really cool if all the code examples were available in a nice
Git repository.</p>
<p>Well, it turns out that they are!
You can clone over 100,000 code examples in a few seconds by running this
command:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">git</span> clone https://github.com/acmeism/RosettaCodeData<br>$ <span class="token builtin class-name">cd</span> RosettaCodeData<br>$ <span class="token function">ls</span> <span class="token parameter variable">-l</span> Lang/YAMLScript/<br>total <span class="token number">8</span><br>00-<span class="token environment constant">LANG</span>.txt<br>00-META.yaml<br><span class="token number">99</span>-bottles-of-beer -<span class="token operator">></span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/Task/99-bottles-of-beer/YAMLScript/<br>Factorial -<span class="token operator">></span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/Task/Factorial/YAMLScript/<br>Fibonacci-sequence -<span class="token operator">></span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/Task/Fibonacci-sequence/YAMLScript/<br>FizzBuzz -<span class="token operator">></span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/Task/FizzBuzz/YAMLScript/<br>Hello-world-Text -<span class="token operator">></span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span>/Task/Hello-world-Text/YAMLScript/</code></pre>
<p>The Rosetta Code Data Project is something I wrote almost 15 years ago.
This last summer I was able to make it a lot easier to update.</p>
<p>Let's try out the FizzBuzz example:</p>
<pre class="language-bash"><code class="language-bash">$ ys Task/FizzBuzz/YAMLScript/fizzbuzz.ys <span class="token number">16</span><br><span class="token number">1</span><br><span class="token number">2</span><br>Fizz<br><span class="token number">4</span><br>Buzz<br>Fizz<br><span class="token number">7</span><br><span class="token number">8</span><br>Fizz<br>Buzz<br><span class="token number">11</span><br>Fizz<br><span class="token number">13</span><br><span class="token number">14</span><br>FizzBuzz<br><span class="token number">16</span></code></pre>
<p>Pretty cool, huh?</p>
<h3>RC Needs More YS!</h3>
<p>Let's try adding a new YAMLScript solution to Rosetta Code.</p>
<p>The first thing to do is to find a task that doesn't have a YAMLScript solution
yet.
You can find all the tasks listed <a href="https://rosettacode.org/wiki/Category:Programming_Tasks">here</a>.</p>
<p>Let's take the first one: <a href="https://rosettacode.org/wiki/100_doors">100 doors</a>.</p>
<p>What I like to do next is cheat!
Clojure has solved most of the tasks on Rosetta Code, and YAMLScript is another
way to write Clojure, so let's just pick a Clojure solution and translate it to
YAMLScript.</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">defn</span> doors <span class="token punctuation">[</span><span class="token punctuation">]</span><br>	<span class="token punctuation">(</span><span class="token keyword">reduce</span> <span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token punctuation">[</span>doors idx<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">assoc</span> doors idx <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>	        <span class="token punctuation">(</span><span class="token keyword">into</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">repeat</span> <span class="token number">100</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>	        <span class="token punctuation">(</span><span class="token keyword">map</span> <span class="token operator">#</span><span class="token punctuation">(</span><span class="token keyword">dec</span> <span class="token punctuation">(</span><span class="token keyword">*</span> % %<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">range</span> <span class="token number">1</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token punctuation">(</span><span class="token keyword">defn</span> open-doors <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">for</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>d n<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">map</span> vector <span class="token punctuation">(</span><span class="token function">doors</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">iterate</span> inc <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token symbol">:when</span> d<span class="token punctuation">]</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token punctuation">(</span><span class="token keyword">defn</span> print-open-doors <span class="token punctuation">[</span><span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">println</span><br>    <span class="token string">"Open doors after 100 passes:"</span><br>    <span class="token punctuation">(</span><span class="token keyword">apply</span> str <span class="token punctuation">(</span><span class="token function">interpose</span> <span class="token string">", "</span> <span class="token punctuation">(</span><span class="token function">open-doors</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br><br><span class="token punctuation">(</span><span class="token function">print-open-doors</span><span class="token punctuation">)</span></code></pre>
<p>Here's a quick translation to YAMLScript:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><br><span class="token key atrule">defn doors()</span><span class="token punctuation">:</span><br>  <span class="token key atrule">reduce</span><span class="token punctuation">:</span><br>    fn <span class="token punctuation">[</span>doors idx<span class="token punctuation">]</span><span class="token punctuation">:</span> assoc(doors idx true)<br>    into <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span> repeat(100 false)<br>    <span class="token key atrule">map \(dec (% * %))</span><span class="token punctuation">:</span> (1 .. 10)<br><br><span class="token key atrule">defn open-doors()</span><span class="token punctuation">:</span><br>  <span class="token key atrule">for</span><span class="token punctuation">:</span> .<span class="token punctuation">[</span><span class="token punctuation">[</span>d n<span class="token punctuation">]</span> map(vector doors() iterate(inc 1)) <span class="token punctuation">:</span>when d<span class="token punctuation">]</span> n<br><br><span class="token key atrule">defn print-open-doors()</span><span class="token punctuation">:</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span><br>    "Open doors after 100 passes<span class="token punctuation">:</span><br>    $(apply str interpose(\"<span class="token punctuation">,</span> \" open<span class="token punctuation">-</span>doors()))"<br><br><span class="token key atrule">=></span><span class="token punctuation">:</span> print<span class="token punctuation">-</span>open<span class="token punctuation">-</span>doors()</code></pre>
<p>Let's see if it works:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token number">100</span>-doors.ys<br>Open doors after <span class="token number">100</span> passes: <span class="token number">1</span>, <span class="token number">4</span>, <span class="token number">9</span>, <span class="token number">16</span>, <span class="token number">25</span>, <span class="token number">36</span>, <span class="token number">49</span>, <span class="token number">64</span>, <span class="token number">81</span>, <span class="token number">100</span></code></pre>
<p>Great! Now let's clean it up a bit:</p>
<p>I'm just going to rename the <code>print-open-doors</code> function to <code>main</code> and move it
to the top of the file.
The <code>main</code> function (if defined) is called automatically when the script is run.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><br><span class="token key atrule">defn main()</span><span class="token punctuation">:</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span><br>    "Open doors after 100 passes<span class="token punctuation">:</span><br>    $(apply str interpose(\"<span class="token punctuation">,</span> \" open<span class="token punctuation">-</span>doors()))"<br><br><span class="token key atrule">defn open-doors()</span><span class="token punctuation">:</span><br>  <span class="token key atrule">for</span><span class="token punctuation">:</span> .<span class="token punctuation">[</span><span class="token punctuation">[</span>d n<span class="token punctuation">]</span> map(vector doors() iterate(inc 1)) <span class="token punctuation">:</span>when d<span class="token punctuation">]</span> n<br><br><span class="token key atrule">defn doors()</span><span class="token punctuation">:</span><br>  <span class="token key atrule">reduce</span><span class="token punctuation">:</span><br>    fn <span class="token punctuation">[</span>doors idx<span class="token punctuation">]</span><span class="token punctuation">:</span> assoc(doors idx true)<br>    into <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span> repeat(100 false)<br>    <span class="token key atrule">map \(dec (% * %))</span><span class="token punctuation">:</span> 1..10</code></pre>
<p>I also ordered the functions top-down in the order they are called since we know
that YAMLScript will auto-declare them in the generated Clojure code.</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">time</span> ys <span class="token number">100</span>-doors.ys<br>Open doors after <span class="token number">100</span> passes: <span class="token number">1</span>, <span class="token number">4</span>, <span class="token number">9</span>, <span class="token number">16</span>, <span class="token number">25</span>, <span class="token number">36</span>, <span class="token number">49</span>, <span class="token number">64</span>, <span class="token number">81</span>, <span class="token number">100</span><br><br>real    0m0.041s</code></pre>
<p>Still works!
Pretty fast too!
Let's add it to Rosetta Code!</p>
<p>To do this you need to create an account on the site, login, and then click the
&quot;Edit&quot; tab on the task page.
It's a pretty terrible plain text editor, but scroll way down to where
the YAMLScript solutions should go and add this:</p>
<pre class="language-text"><code class="language-text">=={&lcub;header|YAMLScript}}==<br>&lt;syntaxhighlight lang="yaml"><br>!yamlscript/v0<br><br>defn main():<br>  say:<br>    "Open doors after 100 passes:<br>    $(apply str interpose(\", \" open-doors()))"<br><br>defn open-doors():<br>  for: .[[d n] map(vector doors() iterate(inc 1)) :when d] n<br><br>defn doors():<br>  reduce:<br>    fn [doors idx]: assoc(doors idx true)<br>    into []: repeat(100 false)<br>    map \(dec (% * %)): 1..10<br>&lt;/syntaxhighlight><br>{&lcub;out}}<br>&lt;pre><br>$ ys 100-doors.ys<br>Open doors after 100 passes: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100<br>&lt;/pre></code></pre>
<p>Click &quot;Save changes&quot; and you're done!</p>
<ul>
<li><a href="https://rosettacode.org/wiki/100_doors#YAMLScript">https://rosettacode.org/wiki/100_doors#YAMLScript</a></li>
<li><a href="https://github.com/acmeism/RosettaCodeData/blob/main/Task/100-doors/YAMLScript/100-doors.ys">https://github.com/acmeism/RosettaCodeData/blob/main/Task/100-doors/YAMLScript/100-doors.ys</a>
<ul>
<li>I updated the repo (not automatic yet)</li>
</ul>
</li>
</ul>
<p><strong>We did it!</strong></p>
<hr>
<p>Don't wait for me to add more YAMLScript solutions to Rosetta Code.
You can do it yourself!
If you do, send me (<code>@ingydotnet</code>) a DM on the <a href="https://discord.com/channels/1011262808001880065/">Rosetta Code Discord</a> server and I'll update the
Rosetta Code Data Project repo with your solutions.</p>
<p>If you had never heard of Rosetta Code before, I hope you'll find it as
interesting as I do.</p>
<p>Check back tomorrow for Day 18 of the YAMLScript Advent Calendar!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Santa&#39;s in d&#39;buggy</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-18/"/>
      <updated>2023-12-18T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-18/</id>
      <content type="html">
        <![CDATA[
      <p>With one week to go, Santa's gotta get his sleigh in top shape.
Can't have any breakdowns on the big night.
His sleigh might look like a simple wooden buggy, but it's more temperamental
and buggy than a 2023 Tesla!</p>
<p>But this is Santa we're talking about.
He's done this a few times, so he knows how to get the bugs out.</p>
<h3>Welcome to Day 18 of the YAMLScript Advent Calendar</h3>
<p>Today we're going to look at a few ways to debug YAMLScript programs.
We'll also cover some of the common mistakes that you might make when writing
YAMLScript code.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># hello.ys</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello, world!"</span></code></pre>
<p>Let's run this very simple program:</p>
<pre class="language-bash"><code class="language-bash">$ ys hello.ys<br>$</code></pre>
<p>Hmmm. Nothing happened. What's wrong?</p>
<p>This first thing I do when my YAMLScript program doesn't work is see what the
Clojure code that it compiled to looks like.
We didn't get a compile error there when we ran <code>ys</code>, so let's look at the
code we were running:</p>
<pre class="language-bash"><code class="language-bash">$ ys hello.ys <span class="token parameter variable">-c</span><br><span class="token punctuation">{</span><span class="token string">"say"</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">}</span></code></pre>
<p>Oh snap! We forgot to start the program with <code>!yamlscript/v0</code>.
The program started of in <code>bare</code> mode, which is just a YAML mapping.</p>
<p>We also could have run the program with <code>--print</code> to see what it evaluated to:</p>
<pre class="language-bash"><code class="language-bash">$ ys hello.ys <span class="token parameter variable">-p</span><br><span class="token punctuation">{</span><span class="token string">"say"</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">}</span></code></pre>
<p>Same thing. Let's fix the program now:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"Hello, world!"</span></code></pre>
<p>now:</p>
<pre class="language-bash"><code class="language-bash">$ ys hello.ys<br>Hello, world<span class="token operator">!</span></code></pre>
<p>That's better.</p>
<hr>
<p>Let's write a program to dynamically generate a list of numbers:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># map.ys</span><br><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">map inc</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>1 2 3<span class="token punctuation">]</span></code></pre>
<p>This program doesn't <code>say</code> anything.
That's because we are using it to generate data, so we'll <code>--load</code> it:</p>
<pre class="language-bash"><code class="language-bash">$ ys map.ys <span class="token parameter variable">-l</span><br>Error: java.lang.Exception: Sequences <span class="token punctuation">(</span>block and flow<span class="token punctuation">)</span> not allowed <span class="token keyword">in</span> code mode<span class="token punctuation">{</span>:eval <span class="token punctuation">[</span><span class="token punctuation">]</span>, :debug-stage <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>
<p>That's scary!
And what's up with Java?!
I don't think it even compiled.</p>
<p>When this happens, I like to debug the 7 layers of YAMLScript compilation, with
the <code>--debug-stage=all</code> option, aka <code>-xall</code>:</p>
<pre class="language-bash"><code class="language-bash">$ ys map.ys <span class="token parameter variable">-xall</span></code></pre>
<pre class="language-txt"><code class="language-txt">$ ys map.ys -l -xall<br>*** parse output ***<br>({:+ "+MAP", :! "yamlscript/v0"}<br> {:+ "=VAL", := "map inc"}<br> {:+ "+SEQ", :flow true}<br> {:+ "=VAL", := "1 2 3"}<br> {:+ "-SEQ"}<br> {:+ "-MAP"})<br><br>*** compose output ***<br>{:! "yamlscript/v0", :% [{:= "map inc"} {:-- [{:= "1 2 3"}]}]}<br><br>Error: java.lang.Exception: Sequences (block and flow) not allowed in code mode{:eval [], :debug-stage {"parse" true, "compose" true, "resolve" true, "build" true, "transform" true, "construct" true, "print" true}, :load true}</code></pre>
<p>The 7 stages of YAMLScript compilation are: <code>parse</code>, <code>compose</code>, <code>resolve</code>,
<code>build</code>, <code>transform</code>, <code>construct</code>, and <code>print</code>.
It looks like we are getting an error in the <code>resolve</code> stage.</p>
<p>The <code>-xall</code> option means the same thing as <code>-xparse -xcompose -xresolve -xbuild -xtransform -xconstruct -xprint</code>.</p>
<p>So we parsed the YAML input into pieces and then composed a tree out of them.
In the resolve stage we look at each node of the tree and figure out what it
means semantically.</p>
<p>YAMLScript doesn't allow sequences in code mode. And it doesn't allow any flow
style collections <code>[] {}</code> in code mode either.
But we wrote <code>[1 2 3]</code>, not <code>[1, 2, 3]</code>.
To YAML, <code>[1 2 3]</code> is valid but it means <code>[&quot;1 2 3&quot;]</code>.
We really meant this list to be a YAMLScript ysexpr vector not a YAML sequence.</p>
<p>We wanted YAML to see the RHS as a scalar value, not a sequence.
YAML plain (unquoted) scalars can't begin with certain characters, like <code>[</code>,
<code>{</code>, <code>*</code>, <code>&amp;</code>, <code>!</code>, <code>|</code>, <code>&gt;</code>, <code>%</code>, <code>@</code>, <code>#</code> etc because they are YAML syntax.
In YAMLScript when we want a ysexpr string that starts with one of these
characters, we can escape it with a dot <code>.</code>.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">map inc</span><span class="token punctuation">:</span> .<span class="token punctuation">[</span>1 2 3<span class="token punctuation">]</span></code></pre>
<p>And let's just check the resolve stage this time:</p>
<pre class="language-bash"><code class="language-bash">$ ys map.ys <span class="token parameter variable">-l</span> <span class="token parameter variable">-xresolve</span></code></pre>
<pre class="language-txt"><code class="language-txt">$ ys map.ys -l -xresolve<br>*** resolve output ***<br>{:ysm [{:ysx "map inc"} {:ysx "[1 2 3]"}]}<br><br>[2,3,4]</code></pre>
<p>It resolved! And it worked! We got our list of numbers.</p>
<blockquote>
<p>Note: The error message indicated a <code>java.lang.Exception</code>.
Remember that YAMLScript is Clojure and Clojure is Java.
The JVM is compiled out of the picture in YAMLScript, but the error message
still comes from Java stuff.</p>
</blockquote>
<hr>
<p>Here's a little program to calculate the factorial of a number:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># factorial.ys</span><br><span class="token tag">!</span><span class="token comment">#/usr/bin/env ys-0</span><br><br><span class="token key atrule">defn main(n)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span> factorial(n)<br><br><span class="token key atrule">defn factorial(x)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">apply *</span><span class="token punctuation">:</span> 2..x</code></pre>
<p>Let's see how it works:</p>
<pre class="language-txt"><code class="language-txt">$ ys factorial.ys<br>Error: Wrong number of args (0) passed to: sci.impl.fns/fun/arity-1--3508<br><br>$ ys factorial.ys 10<br>3628800<br>$ ys factorial.ys 20<br>2432902008176640000<br>$ ys factorial.ys 30<br>Error: long overflow</code></pre>
<p>Two of the four runs we got an error.
Hopefully the errors are pretty obvious.
The first time we forgot the number it wanted.
The second time we tried to calculate a number that was too big for a 64 bit
integer.</p>
<p>This was a very small program, but when things blow up, it's nice to have a
stack trace to see exactly where the error happened and what code path it took
to get there.
Especially when many library files are involved.</p>
<p>You can see the stack trace on any error by using the <code>--stack-trace</code> option aka
<code>-X</code>:</p>
<pre class="language-txt"><code class="language-txt">$ ys factorial.ys 30 -X<br>Error: {:stack-trace true,<br> :cause "long overflow",<br> :file nil,<br> :line nil,<br> :column nil,<br> :trace<br> [[clojure.lang.Numbers multiply "Numbers.java" 1971]<br>  [clojure.lang.Numbers$LongOps multiply "Numbers.java" 503]<br>  [clojure.lang.Numbers multiply "Numbers.java" 175]<br>  [clojure.core$_STAR_ invokeStatic "core.clj" 1018]<br>  [clojure.core$_STAR_ invoke "core.clj" 1010]<br>  [clojure.lang.LongRange$LongChunk reduce "LongRange.java" 316]<br>  [clojure.core$reduce1 invokeStatic "core.clj" 944]<br>  [clojure.core$_STAR_ invokeStatic "core.clj" 1020]<br>  [clojure.core$_STAR_ doInvoke "core.clj" 1010]<br>  [clojure.lang.RestFn applyTo "RestFn.java" 142]<br>  [clojure.core$apply invokeStatic "core.clj" 667]<br>  [clojure.core$apply invoke "core.clj" 662]<br>  [sci.lang.Var invoke "lang.cljc" 202]<br>  [sci.impl.analyzer$return_call$reify__4621 eval "analyzer.cljc" 1422]<br>  [sci.impl.fns$fun$arity_1__3508 invoke "fns.cljc" 107]<br>  [sci.lang.Var invoke "lang.cljc" 200]<br>  [sci.impl.analyzer$return_call$reify__4617 eval "analyzer.cljc" 1422]<br>  [sci.impl.analyzer$return_call$reify__4617 eval "analyzer.cljc" 1422]<br>  [sci.impl.fns$fun$arity_1__3508 invoke "fns.cljc" 107]<br>  [clojure.lang.AFn applyToHelper "AFn.java" 154]<br>  [clojure.lang.AFn applyTo "AFn.java" 144]<br>  [clojure.core$apply invokeStatic "core.clj" 667]<br>  [clojure.core$apply invoke "core.clj" 662]<br>  [sci.lang.Var invoke "lang.cljc" 202]<br>  [sci.impl.analyzer$return_call$reify__4621 eval "analyzer.cljc" 1422]<br>  [sci.impl.interpreter$eval_form invokeStatic "interpreter.cljc" 40]<br>  [sci.impl.interpreter$eval_string_STAR_<br>   invokeStatic<br>   "interpreter.cljc"<br>   66]<br>  [sci.impl.interpreter$eval_string_STAR_ invoke "interpreter.cljc" 57]<br>  [sci.impl.interpreter$eval_string_STAR_<br>   invokeStatic<br>   "interpreter.cljc"<br>   59]<br>  [sci.impl.interpreter$eval_string invokeStatic "interpreter.cljc" 77]<br>  [sci.core$eval_string invokeStatic "core.cljc" 225]<br>  [yamlscript.runtime$eval_string invokeStatic "runtime.clj" 114]<br>  [yamlscript.cli$do_run invokeStatic "cli.clj" 221]<br>  [yamlscript.cli$do_default invokeStatic "cli.clj" 284]<br>  [yamlscript.cli$_main invokeStatic "cli.clj" 381]<br>  [yamlscript.cli$_main doInvoke "cli.clj" 370]<br>  [clojure.lang.RestFn applyTo "RestFn.java" 137]<br>  [yamlscript.cli main nil -1]<br>  [java.lang.invoke.LambdaForm$DMH/sa346b79c<br>   invokeStaticInit<br>   "LambdaForm$DMH"<br>   -1]]}</code></pre>
<p>Well... You asked for it. :- )</p>
<hr>
<p>Print debugging is a great way to debug programs.
YAMLScript provides some help here with it's <code>www</code>, <code>xxx</code>, <code>yyy</code>, and <code>zzz</code>
standard library functions.
Conceptually these come from an old Perl module I wrote years ago called
<a href="https://metacpan.org/pod/XXX">XXX</a>.</p>
<ul>
<li><code>www</code> warns (prints to stderr) it's argument and returns it.</li>
<li><code>xxx</code> dies (prints and then terminates) it's argument.</li>
<li><code>yyy</code> prints it's argument as YAML and returns it.</li>
<li><code>zzz</code> is like <code>xxx</code> but it prints the stack trace too.</li>
</ul>
<p>Here's a contrived example that passes data through a pipeline of functions:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># pipeline.ys</span><br><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">->> (1..10)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">map</span><span class="token punctuation">:</span> inc<br>  <span class="token key atrule">filter</span><span class="token punctuation">:</span> \(= 0 (mod % 2))  <span class="token comment"># odd?</span><br>  <span class="token key atrule">reduce</span><span class="token punctuation">:</span> +<br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> say</code></pre>
<p>Check it:</p>
<pre class="language-txt"><code class="language-txt">$ ys pipeline.ys<br>30</code></pre>
<p>The <code>-&gt;&gt;</code> function is Clojure's threading macro.
It lets you pass a value through a pipeline of transformation functions without
having to reverse nest them in a ton of parentheses.
It's quite nice and handy.</p>
<p>Often times when I'm writing a pipeline like this, I want to see what the data
looks like after a particular transformation or maybe after several of them.
I almost always us <code>www</code> for this.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><span class="token key atrule">->> (1..10)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">www</span><span class="token punctuation">:</span> <span class="token string">"before map"</span><br>  <span class="token key atrule">map</span><span class="token punctuation">:</span> inc<br>  <span class="token key atrule">www</span><span class="token punctuation">:</span> <span class="token string">"after map"</span><br>  <span class="token key atrule">filter</span><span class="token punctuation">:</span> \(= 0 (mod % 2))  <span class="token comment"># odd?</span><br>  <span class="token key atrule">www</span><span class="token punctuation">:</span> <span class="token string">"after filter"</span><br>  <span class="token key atrule">reduce</span><span class="token punctuation">:</span> +<br>  <span class="token key atrule">www</span><span class="token punctuation">:</span> <span class="token string">"after reduce"</span><br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> say<br>  <span class="token key atrule">=></span><span class="token punctuation">:</span> www</code></pre>
<p>The <code>www</code> function can actually take multiple arguments.
It prints them all and returns the last one.
The <code>-&gt;&gt;</code> threading macro adds its value as the last argument to each function.
So the way we did it here we are adding a label to each debugging section.</p>
<p>I used <code>=&gt;: www</code> to show how to call it with no extra label argument.
Remember that <code>=&gt;:</code> is the YAMLScript way to write a mapping pair when you only
need one thing (the <code>www</code> function in this case).</p>
<pre class="language-txt"><code class="language-txt">$ ys pipeline.ys<br>---<br>("before map" (1 2 3 4 5 6 7 8 9 10))<br>...<br>---<br>("after map" (2 3 4 5 6 7 8 9 10 11))<br>...<br>---<br>("after filter" (2 4 6 8 10))<br>...<br>---<br>("after reduce" 30)<br>...<br>30<br>---<br>nil<br>...</code></pre>
<p>Each www call wraps the output with a <code>---</code> and a <code>...</code> so you can see where
the output starts and ends.</p>
<hr>
<p>I hope you enjoyed this little tour of YAMLScript debugging.
There are many more ways to debug YAMLScript programs.
Likely many than I've even thought of yet.</p>
<p>See you tomorrow for Day 19 of the YAMLScript Advent Calendar.</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Reindeer All The Way Down</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-19/"/>
      <updated>2023-12-19T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-19/</id>
      <content type="html">
        <![CDATA[
      <p>Santa is in charge of Christmas.
He's the one who makes sure that all the children get presents.
But who is in charge of getting Santa his presents?
That's where the reindeer come in.
They are the ones who make sure that Santa gets his presents.
But who is in charge of getting the reindeer their presents?
More reindeer!
But who is in charge of getting the reindeer's reindeer their presents?
More reindeer!
It's reindeer all the way down.</p>
<h3>Welcome to Day 19 of the YAMLScript Advent Calendar</h3>
<p>YAMLScript is a new programming language that is based on Clojure.
It's written in Clojure and compiles to Clojure.
In effect YAMLScript is Clojure.
So if YAMLScript is written in Clojure, why not just use YAMLScript to write
YAMLScript?</p>
<p>Isn't there a chicken and egg problem here?
Sure, but that's easy to solve.</p>
<p>Once you have a stable version of YAMLScript, you can rewrite YAMLScript in
YAMLScript.
You just need to use a previously compiled version of YAMLScript to compile
the new YAMLScript-in-YAMLScript with.</p>
<p>This is called self-hosting and it's a common practice in the programming
language world.
Clojure itself is written in Clojure.
Not all of it.
It's also written in Java, since it runs on the JVM.
But all the core libraries are written in Clojure.</p>
<p>YAMLScript isn't quite ready to be self-hosted yet.
But I was able to convert the <code>ys::std</code> library to YAMLScript and then build
YAMLScript with it!</p>
<p>Have a look at this <a href="https://gist.github.com/ingydotnet/480d7243a797c9323b973cf5c5dea933">gist</a>.</p>
<p>It has 3 files:</p>
<ul>
<li><a href="https://gist.github.com/ingydotnet/480d7243a797c9323b973cf5c5dea933#file-orig-std-clj">orig-std.clj</a>
— The original Clojure version of <code>ys::std</code> as of today.</li>
<li><a href="https://gist.github.com/ingydotnet/480d7243a797c9323b973cf5c5dea933#file-std-clj">std.clj</a>
— The compiled version of YAMLScript port of <code>ys::std</code>.</li>
<li><a href="https://gist.github.com/ingydotnet/480d7243a797c9323b973cf5c5dea933#file-std-ys">std.ys</a>
— The YAMLScript port of <code>ys::std</code>.</li>
</ul>
<p>I don't know about you but I find the YAMLScript version much easier to read
than the Clojure version.</p>
<p>However since there's still a lot of work left to do on YAMLScript, before the
first stable release, some of the YAMLScript code is a bit ugly.</p>
<p>Let's look at a few ugly forms and think about how to make them better.</p>
<p>Let's start with the <code>ns</code> declaration at the top of the file:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">ns ys::std</span><span class="token punctuation">:</span><br>  (<span class="token punctuation">:</span>require<br>   <span class="token punctuation">[</span>yamlscript<span class="token punctuation">:</span><span class="token punctuation">:</span>debug<span class="token punctuation">]</span><br>   <span class="token punctuation">[</span>clojure<span class="token punctuation">:</span><span class="token punctuation">:</span>pprint<span class="token punctuation">]</span><br>   <span class="token punctuation">[</span>clojure<span class="token punctuation">:</span><span class="token punctuation">:</span>string<span class="token punctuation">]</span>)<br>  (<span class="token punctuation">:</span>refer<span class="token punctuation">-</span>clojure <span class="token punctuation">:</span>exclude <span class="token punctuation">[</span>print<span class="token punctuation">]</span>)</code></pre>
<p>Soon we'll have a YAMLScript macro system for making certain calls look better
than they do with the base syntax.
The future <code>ns</code> declaration might look like this:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">ns ys::std</span><span class="token punctuation">:</span><br>  <span class="token key atrule">require</span><span class="token punctuation">:</span><br>    <span class="token key atrule">yamlscript::debug</span><span class="token punctuation">:</span><br>    <span class="token key atrule">clojure::pprint</span><span class="token punctuation">:</span> pp<br>    <span class="token key atrule">clojure::string</span><span class="token punctuation">:</span><br>  <span class="token key atrule">refer-clojure</span><span class="token punctuation">:</span><br>    <span class="token key atrule">exclude</span><span class="token punctuation">:</span> print</code></pre>
<p>That looks pretty nice!</p>
<p>How about this ugly multi-arity defn:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn toMap</span><span class="token punctuation">:</span><br>  .<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span> .<span class="token punctuation">{</span><span class="token punctuation">}</span><br>  .<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">:</span><br>    <span class="token key atrule">apply</span><span class="token punctuation">:</span> hash<span class="token punctuation">-</span>map x<br>  .<span class="token punctuation">[</span>k v &amp; xs<span class="token punctuation">]</span><span class="token punctuation">:</span><br>    <span class="token key atrule">apply</span><span class="token punctuation">:</span> hash<span class="token punctuation">-</span>map k v xs</code></pre>
<p>Here we needed to dot-escape the <code>[]</code> keys.
I'd rather see like:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">defn toMap</span><span class="token punctuation">:</span><br>  <span class="token key atrule">()</span><span class="token punctuation">:</span> hash<span class="token punctuation">-</span>map()<br>  <span class="token key atrule">(x)</span><span class="token punctuation">:</span><br>    <span class="token key atrule">apply</span><span class="token punctuation">:</span> hash<span class="token punctuation">-</span>map x<br>  <span class="token key atrule">(k v &amp; xs)</span><span class="token punctuation">:</span><br>    <span class="token key atrule">apply</span><span class="token punctuation">:</span> hash<span class="token punctuation">-</span>map k v xs</code></pre>
<p>Parentheses are just normal characters in YAML so we don't need to escape them.
And we already use parens in <code>defn foo(bar): baz</code> so it's consistent.</p>
<p>One of the more problematic forms in this file is the macro definition:</p>
<pre class="language-yaml"><code class="language-yaml">defmacro each <span class="token punctuation">[</span>bindings &amp; body<span class="token punctuation">]</span><span class="token punctuation">:</span><br>  .`(do<br>      (doall<br>        (for <span class="token punctuation">[</span>~@bindings<span class="token punctuation">]</span> (do ~@body)))<br>      nil)</code></pre>
<p>I pretty much had to leave the original Clojure syntax alone here.
The backtick is a reserved character in YAML so we had to dot-escape it.</p>
<p>There's actually quite a few problems that macros cause for YAMLScript.
I won't bore you with the details.
We'll figure out a good way to code macros in YAMLScript but I can't say that I
have it figured out yet.</p>
<p>At this point I'd say that about 80% of Clojure code ports nicely to YAMLScript.
The other 20% is a bit of a struggle.
But that's stuff I want to improve before the first stable release.</p>
<hr>
<p>I hope you enjoyed today's post.
It was a little shorter than usual.
But YAMLScript is keeping me very busy and I was a little short on time today.</p>
<p>I have something really special planned for tomorrow.
But I need to make it work first!
Fingers crossed.</p>
<p>Come back tomorrow for Day 20 of the YAMLScript Advent Calendar.</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Godspeed</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-20/"/>
      <updated>2023-12-20T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-20/</id>
      <content type="html">
        <![CDATA[
      <p>I wonder if Santa has a Hemi?
Supercharged, Turbocharged?
Maybe a Nitro Burning Funny Sleigh?
Dude's got to get around the world in one night.
Godspeed, my festive friend!</p>
<h3>Welcome to Day 20 of the YAMLScript Advent Blog!</h3>
<p>Are YAMLScript programs compiled or interpreted?
The answer is yes.</p>
<p>Clojure (thus YAMLScript) is a very dynamic language.
Clojure code gets compiled to Java bytecode just in time.
The JVM compiles the bytecode to machine code just in time.
Libraries that Clojure uses are compiled ahead of time.
The whole YAMLScript runtime was compiled by GraalVM native-image into a native
binary so there is no JVM involved for us in the end.</p>
<p>It's all pretty complicated.</p>
<p>But I was talking about YAMLScript programs being run by the YAMLScript CLI
<code>ys</code>.
You can think of <code>ys</code> as an interpreter like Python, Perl, Ruby or Java.
Sure, those languages <em>compile</em> to an intermediate AST/opcode-tree to be faster,
but the programs are still interpreted (not binary compiled).</p>
<p>What if you could compile your YAMLScript program to a native binary?
Like an ELF file on Linux or a Mach-O file on macOS.</p>
<blockquote>
<p>Can you guess why I like Linux better this time of year? :- )</p>
</blockquote>
<p><strong>As of today, you can natively compile YAMLScript programs!!</strong></p>
<p>Merry, Merry!</p>
<p>Let's check it out.
Remember our favorite drinking song from Day 9?
Here it is again:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment">#!/usr/bin/env ys-0</span><br><span class="token comment"># 99-bottles.ys</span><br><br>defn main(&amp;<span class="token punctuation">[</span>number<span class="token punctuation">]</span>)<span class="token punctuation">:</span><br>  each <span class="token punctuation">[</span>n ((number <span class="token punctuation">|</span><span class="token punctuation">|</span> 99) .. 1)<span class="token punctuation">]</span><span class="token punctuation">:</span><br>    <span class="token key atrule">say</span><span class="token punctuation">:</span><br>      <span class="token key atrule">paragraph</span><span class="token punctuation">:</span> n<br><br><span class="token key atrule">defn paragraph(num)</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string"><br>  $(bottles num) of beer on the wall,<br>  $(bottles num) of beer.<br>  Take one down, pass it around.<br>  $(bottles (num - 1)) of beer on the wall.</span><br><br><span class="token key atrule">defn bottles(n)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">cond</span><span class="token punctuation">:</span><br>    (n == 0) "No more bottles"<br>    (n == 1) "1 bottle"<br>    <span class="token punctuation">:</span>else    str(n " bottles")</code></pre>
<p>Let's see how long it takes to drink 3 bottles:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">time</span> ys <span class="token number">99</span>-bottles.ys <span class="token number">3</span><br><span class="token number">3</span> bottles of beer on the wall,<br><span class="token number">3</span> bottles of beer.<br>Take one down, pass it around.<br><span class="token number">2</span> bottles of beer on the wall.<br><br><span class="token number">2</span> bottles of beer on the wall,<br><span class="token number">2</span> bottles of beer.<br>Take one down, pass it around.<br><span class="token number">1</span> bottle of beer on the wall.<br><br><span class="token number">1</span> bottle of beer on the wall,<br><span class="token number">1</span> bottle of beer.<br>Take one down, pass it around.<br>No <span class="token function">more</span> bottles of beer on the wall.<br><br>real    0m0.075s</code></pre>
<p>75 milliseconds. Not bad.
Let's see if we can drink a little faster, shall we?</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--native</span> <span class="token number">99</span>-bottles.ys<br>* Compiling YAMLScript <span class="token string">'99-bottles.ys'</span> to <span class="token string">'99-bottles'</span> executable<br>* Setting up build <span class="token function">env</span> <span class="token keyword">in</span> <span class="token string">'/tmp/tmp.wpt7O1KsWg'</span><br>* This may take a few minutes<span class="token punctuation">..</span>.<br><span class="token punctuation">[</span><span class="token number">1</span>/8<span class="token punctuation">]</span> Initializing              <span class="token punctuation">(</span><span class="token number">5</span>.0s @ <span class="token number">0</span>.08GB<span class="token punctuation">)</span><br><span class="token punctuation">[</span><span class="token number">2</span>/8<span class="token punctuation">]</span> Performing analysis               <span class="token punctuation">(</span><span class="token number">20</span>.7s @ <span class="token number">0</span>.35GB<span class="token punctuation">)</span><br><span class="token punctuation">[</span><span class="token number">3</span>/8<span class="token punctuation">]</span> Building universe         <span class="token punctuation">(</span><span class="token number">3</span>.3s @ <span class="token number">0</span>.35GB<span class="token punctuation">)</span><br><span class="token punctuation">[</span><span class="token number">4</span>/8<span class="token punctuation">]</span> Parsing methods           <span class="token punctuation">(</span><span class="token number">2</span>.3s @ <span class="token number">0</span>.61GB<span class="token punctuation">)</span><br><span class="token punctuation">[</span><span class="token number">5</span>/8<span class="token punctuation">]</span> Inlining methods          <span class="token punctuation">(</span><span class="token number">2</span>.0s @ <span class="token number">0</span>.44GB<span class="token punctuation">)</span><br><span class="token punctuation">[</span><span class="token number">6</span>/8<span class="token punctuation">]</span> Compiling methods         <span class="token punctuation">(</span><span class="token number">22</span>.2s @ <span class="token number">0</span>.42GB<span class="token punctuation">)</span><br><span class="token punctuation">[</span><span class="token number">7</span>/8<span class="token punctuation">]</span> Layouting methods         <span class="token punctuation">(</span><span class="token number">1</span>.7s @ <span class="token number">0</span>.44GB<span class="token punctuation">)</span><br><span class="token punctuation">[</span><span class="token number">8</span>/8<span class="token punctuation">]</span> Creating image            <span class="token punctuation">(</span><span class="token number">2</span>.3s @ <span class="token number">0</span>.51GB<span class="token punctuation">)</span><br>* Compiled YAMLScript <span class="token string">'99-bottles.ys'</span> to <span class="token string">'99-bottles'</span> executable<br>$ <span class="token function">ls</span> <span class="token parameter variable">-lh</span> <span class="token number">99</span>-bottles*<br>-rwxr-xr-x <span class="token number">1</span> ingy ingy 13M Dec <span class="token number">19</span> <span class="token number">18</span>:14 <span class="token number">99</span>-bottles*<br>-rwxr-xr-x <span class="token number">1</span> ingy ingy <span class="token number">468</span> Dec <span class="token number">19</span> <span class="token number">18</span>:10 <span class="token number">99</span>-bottles.ys*</code></pre>
<p>It appears that we have birthed a new beer singer!
What goes better with beer than race cars?</p>
<details><summary><strong>Answer</strong></summary>
<p>Almost anything.</p>
</details><p></p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">time</span> ./99-bottles <span class="token number">3</span><br><span class="token number">3</span> bottles of beer on the wall,<br><span class="token number">3</span> bottles of beer.<br>Take one down, pass it around.<br><span class="token number">2</span> bottles of beer on the wall.<br><br><span class="token number">2</span> bottles of beer on the wall,<br><span class="token number">2</span> bottles of beer.<br>Take one down, pass it around.<br><span class="token number">1</span> bottle of beer on the wall.<br><br><span class="token number">1</span> bottle of beer on the wall,<br><span class="token number">1</span> bottle of beer.<br>Take one down, pass it around.<br>No <span class="token function">more</span> bottles of beer on the wall.<br><br>real    0m0.016s</code></pre>
<p>Woah! 16 milliseconds! Now we're drinking with gas!
Errr... never mind.</p>
<p>You may have noticed that the native binary is 13 megabytes.
That's because it contains the entire YAMLScript runtime.
Hopefully we can get that down to a smaller size in the future.</p>
<p>Also did you notice that it took an annoying amount of time to compile?</p>
<p>Let's time native compiling a minimal program:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">time</span> ys <span class="token parameter variable">-Ce</span> <span class="token string">'say: "Hello, world!"'</span><br>* Compiling YAMLScript <span class="token string">'-e'</span> to <span class="token string">'./EVAL'</span> executable<br>* Setting up build <span class="token function">env</span> <span class="token keyword">in</span> <span class="token string">'/tmp/tmp.mahWVLE9gi'</span><br>Could not <span class="token function">find</span> main <span class="token keyword">function</span> <span class="token keyword">in</span> <span class="token string">'-e'</span><br><br>real    0m0.103s</code></pre>
<p>I forgot to mention.
In order to <code>--native</code> compile a YAMLScript program, it must have a <code>main</code>
function.
That's an easy fix:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">time</span> ys <span class="token parameter variable">-Ce</span> <span class="token string">'defn main(): say("Hello, world!")'</span><br>* Compiling YAMLScript <span class="token string">'-e'</span> to <span class="token string">'./EVAL'</span> executable<br>* Setting up build <span class="token function">env</span> <span class="token keyword">in</span> <span class="token string">'/tmp/tmp.1zpmh6L1jM'</span><br>* This may take a few minutes<span class="token punctuation">..</span>.<br><span class="token punctuation">[</span><span class="token number">1</span>/8<span class="token punctuation">]</span> Initializing              <span class="token punctuation">(</span><span class="token number">4</span>.4s @ <span class="token number">0</span>.17GB<span class="token punctuation">)</span><br><span class="token punctuation">[</span><span class="token number">2</span>/8<span class="token punctuation">]</span> Performing analysis               <span class="token punctuation">(</span><span class="token number">17</span>.4s @ <span class="token number">0</span>.30GB<span class="token punctuation">)</span><br><span class="token punctuation">[</span><span class="token number">3</span>/8<span class="token punctuation">]</span> Building universe         <span class="token punctuation">(</span><span class="token number">2</span>.4s @ <span class="token number">0</span>.53GB<span class="token punctuation">)</span><br><span class="token punctuation">[</span><span class="token number">4</span>/8<span class="token punctuation">]</span> Parsing methods           <span class="token punctuation">(</span><span class="token number">2</span>.4s @ <span class="token number">0</span>.49GB<span class="token punctuation">)</span><br><span class="token punctuation">[</span><span class="token number">5</span>/8<span class="token punctuation">]</span> Inlining methods          <span class="token punctuation">(</span><span class="token number">1</span>.4s @ <span class="token number">0</span>.63GB<span class="token punctuation">)</span><br><span class="token punctuation">[</span><span class="token number">6</span>/8<span class="token punctuation">]</span> Compiling methods         <span class="token punctuation">(</span><span class="token number">20</span>.4s @ <span class="token number">0</span>.42GB<span class="token punctuation">)</span><br><span class="token punctuation">[</span><span class="token number">7</span>/8<span class="token punctuation">]</span> Layouting methods         <span class="token punctuation">(</span><span class="token number">1</span>.6s @ <span class="token number">0</span>.46GB<span class="token punctuation">)</span><br><span class="token punctuation">[</span><span class="token number">8</span>/8<span class="token punctuation">]</span> Creating image            <span class="token punctuation">(</span><span class="token number">2</span>.5s @ <span class="token number">0</span>.40GB<span class="token punctuation">)</span><br>* Compiled YAMLScript <span class="token string">'-e'</span> to <span class="token string">'./EVAL'</span> executable<br><br>real    0m59.855s</code></pre>
<p>Isn't that pretty cool?
You can native compile a <code>-e</code> one liner!</p>
<p>Since the output file needs a name, <code>ys</code> uses <code>./EVAL</code> when you use <code>-e</code>.
You can use the <code>-o</code> option to to name the file explicitly.
Otherwise it defaults to the name of the YAMLScript file with the <code>.ys</code>
extension removed.</p>
<p>The bad news is that it took almost a minute to compile.
Currently that's the price you pay for a one-liner race car!</p>
<p>Let's see if this little guy has the juice:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">time</span> ./EVAL<br>Hello, world<span class="token operator">!</span><br><br>real    0m0.010s</code></pre>
<p><strong>Godspeed, you little global greeter!</strong></p>
<hr>
<p>YAMLScript's <code>--native</code> compiler is based on GraalVM's <code>native-image</code> tool.
The same process that is used to compile the <code>ys</code> CLI binary.</p>
<p>I wish it were faster, but at least now we can be fast while developing our
YAMLScript programs and then compile them to native binaries when we are ready
to ship them.</p>
<p>Let's look at where YAMLScript is at now from a high level view:</p>
<ul>
<li>We have a new language that feels clean like Python</li>
<li>It is actually a functional language adding reliability</li>
<li>It's really Clojure so very complete and powerful</li>
<li>It's embeddable in YAML so you can enhance existing YAML files</li>
<li>It's a better YAML loader for plain old YAML with no magics</li>
<li>It's quite fast when run with the YAMLScript CLI <code>ys</code></li>
<li>It's even faster when compiled to a native binary</li>
</ul>
<p>I think we have a winner here!</p>
<p>There's still a long way to go on many fronts, but all of the above is true
today.
Full disclosure: I only came up the the <code>--native</code> idea 2 days ago.</p>
<p>Climb aboard and let's fly this baby to the moon!</p>
<p>Come back tomorrow for Day 21 of the YAMLScript Advent Blog!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>YAML, Python and the Holy Graal</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-21/"/>
      <updated>2023-12-21T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-21/</id>
      <content type="html">
        <![CDATA[
      <p>Which has a greater airspeed velocity... an unladen swallow or Santa's sleigh?</p>
<p>Well, that depends... are we talking about an African or European swallow?</p>
<p> </p>
<details><summary><strong style="color:red">Huh?</strong></summary>
&nbsp;
<iframe width="560" height="315"
  src="https://www.youtube.com/embed/uio1J2PKzLI?si=QA1x920QfN1GlkRs"
  title="YouTube video player"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
  allowfullscreen></iframe>
</details>
<h3>Welcome to Day 21 of the YAMLScript Advent Blog!</h3>
<p>So far we've been using the YAMLScript CLI <code>ys</code> to run (or load) our YAMLScript
programs.
YAML users are used to using a YAML framework module inside their programs.
For example, in Python you might do:</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">import</span> yaml<br><br>yaml_text <span class="token operator">=</span> <span class="token triple-quoted-string string">"""<br>- 40<br>- 50<br>- 60<br>"""</span><br><br>data <span class="token operator">=</span> yaml<span class="token punctuation">.</span>safe_load<span class="token punctuation">(</span>yaml_text<span class="token punctuation">)</span><br><br><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><br><span class="token comment"># => [40, 50, 60]</span></code></pre>
<p>Wouldn't it be nice if we could do the same thing in YAMLScript?
As of today, we can!</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">import</span> yamlscript<br><br>yaml_text <span class="token operator">=</span> <span class="token triple-quoted-string string">"""<br>- 40<br>- 50<br>- 60<br>"""</span><br><br>data <span class="token operator">=</span> yamlscript<span class="token punctuation">.</span>load<span class="token punctuation">(</span>yaml_text<span class="token punctuation">)</span><br><br><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><br><span class="token comment"># => [40, 50, 60]</span></code></pre>
<p>The only thing that changed was the name of the module.</p>
<p>But this module has super powers.</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">import</span> yamlscript<br><br>yaml_text <span class="token operator">=</span> <span class="token triple-quoted-string string">"""<br>!yamlscript/v0<br>mapv \(% * 10): 4..6<br>"""</span><br><br>data <span class="token operator">=</span> yamlscript<span class="token punctuation">.</span>load<span class="token punctuation">(</span>yaml_text<span class="token punctuation">)</span><br><br><span class="token keyword">print</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><br><span class="token comment"># => [40, 50, 60]</span></code></pre>
<p>We can use YAMLScript functions in our YAML text to generate or manipulate data.</p>
<p>That example was a bit contrived, but I just wanted to show how easy it is to
load plain old YAML or super powered YAML with the new <code>yamlscript</code> Python
module.</p>
<p>Here's an example that might be more exciting.</p>
<p>Say we have this normal YAML file with some data in it:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># db.yaml</span><br><span class="token key atrule">cars</span><span class="token punctuation">:</span><br><span class="token punctuation">-</span> <span class="token key atrule">make</span><span class="token punctuation">:</span> Ford<br>  <span class="token key atrule">model</span><span class="token punctuation">:</span> Mustang<br>  <span class="token key atrule">year</span><span class="token punctuation">:</span> <span class="token number">1967</span><br>  <span class="token key atrule">color</span><span class="token punctuation">:</span> red<br><span class="token punctuation">-</span> <span class="token key atrule">make</span><span class="token punctuation">:</span> Dodge<br>  <span class="token key atrule">model</span><span class="token punctuation">:</span> Charger<br>  <span class="token key atrule">year</span><span class="token punctuation">:</span> <span class="token number">1969</span><br>  <span class="token key atrule">color</span><span class="token punctuation">:</span> orange<br><span class="token punctuation">-</span> <span class="token key atrule">make</span><span class="token punctuation">:</span> Chevrolet<br>  <span class="token key atrule">model</span><span class="token punctuation">:</span> Camaro<br>  <span class="token key atrule">year</span><span class="token punctuation">:</span> <span class="token number">1969</span><br>  <span class="token key atrule">color</span><span class="token punctuation">:</span> blue</code></pre>
<p>We could have another YAML file that uses YAMLScript:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># racers.yaml</span><br><span class="token tag">!yamlscript/v0</span><br><br><span class="token key atrule">db =</span><span class="token punctuation">:</span> load("db.yaml")<br><br><span class="token key atrule">=></span><span class="token punctuation">:</span> <span class="token tag">!</span><br><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Ingy döt Net<br>  <span class="token key atrule">car</span><span class="token punctuation">:</span> <span class="token tag">!</span> db.cars.0<br><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Santa Claus<br>  <span class="token key atrule">car</span><span class="token punctuation">:</span> <span class="token tag">!</span> db.cars.1<br><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Sir Lancelot<br>  <span class="token key atrule">car</span><span class="token punctuation">:</span> <span class="token tag">!</span> db.cars.2</code></pre>
<p>Then we could load the data into Python and print it out:</p>
<pre class="language-python"><code class="language-python"><span class="token comment"># race-report.py</span><br><span class="token keyword">import</span> yaml<span class="token punctuation">,</span> yamlscript<br><br>data <span class="token operator">=</span> yamlscript<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'racers.yaml'</span><span class="token punctuation">)</span><br><br><span class="token keyword">print</span><span class="token punctuation">(</span>yaml<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>And we get:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">car</span><span class="token punctuation">:</span><br>    <span class="token key atrule">color</span><span class="token punctuation">:</span> red<br>    <span class="token key atrule">make</span><span class="token punctuation">:</span> Ford<br>    <span class="token key atrule">model</span><span class="token punctuation">:</span> Mustang<br>    <span class="token key atrule">year</span><span class="token punctuation">:</span> <span class="token number">1967</span><br>  <span class="token key atrule">name</span><span class="token punctuation">:</span> Ingy dot Net<br><span class="token punctuation">-</span> <span class="token key atrule">car</span><span class="token punctuation">:</span><br>    <span class="token key atrule">color</span><span class="token punctuation">:</span> orange<br>    <span class="token key atrule">make</span><span class="token punctuation">:</span> Dodge<br>    <span class="token key atrule">model</span><span class="token punctuation">:</span> Charger<br>    <span class="token key atrule">year</span><span class="token punctuation">:</span> <span class="token number">1969</span><br>  <span class="token key atrule">name</span><span class="token punctuation">:</span> Santa Claus<br><span class="token punctuation">-</span> <span class="token key atrule">car</span><span class="token punctuation">:</span><br>    <span class="token key atrule">color</span><span class="token punctuation">:</span> blue<br>    <span class="token key atrule">make</span><span class="token punctuation">:</span> Chevrolet<br>    <span class="token key atrule">model</span><span class="token punctuation">:</span> Camaro<br>    <span class="token key atrule">year</span><span class="token punctuation">:</span> <span class="token number">1969</span><br>  <span class="token key atrule">name</span><span class="token punctuation">:</span> Sir Lancelot</code></pre>
<p>Pretty cool, huh?</p>
<p>There's no end to the things you can do with this.</p>
<p>Today we're showing off the <a href="https://pypi.org/project/yamlscript/">Python YAMLScript module</a> but soon this module will be available in
every language that has a need for it.</p>
<h3>Installing the <code>yamlscript</code> Python Module</h3>
<p>Normally to install a Python module you would do:</p>
<pre class="language-sh"><code class="language-sh">pip <span class="token function">install</span> a-python-module</code></pre>
<p>With YAMLScript, you do the same:</p>
<pre class="language-sh"><code class="language-sh">pip <span class="token function">install</span> yamlscript</code></pre>
<p>But you also need to install the <code>libyamlscript</code> shared library.</p>
<p>You can do that with:</p>
<pre class="language-sh"><code class="language-sh"><span class="token function">curl</span> https://yamlscript.org/install <span class="token operator">|</span> <span class="token function">bash</span></code></pre>
<p>That will install the latest version of <code>libyamlscript</code> for your platform in
<code>/usr/local/lib</code>.
You'll need to have root access to do this.</p>
<p>If you want to install it somewhere else, you can set the <code>PREFIX</code> option:</p>
<pre class="language-sh"><code class="language-sh"><span class="token function">curl</span> https://yamlscript.org/install <span class="token operator">|</span> <span class="token assign-left variable">PREFIX</span><span class="token operator">=~</span>/ys <span class="token function">bash</span></code></pre>
<p>But then you'll need to set the <code>LD_LIBRARY_PATH</code> environment variable to point
to it:</p>
<pre class="language-sh"><code class="language-sh"><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=~</span>/ys/lib</code></pre>
<p>Eventually we may package the yamlscript.py module with wheels (binary assets)
for libyamlscript, but for now you'll need to install it yourself.</p>
<p>If you're a polyglot like me, at least you only have to install it once. :- )</p>
<h3>The Holy Graal</h3>
<p>This magic is all possible because of the <a href="https://www.graalvm.org/">GraalVM</a>
project.
Not only does GraalVM's <code>native-image</code> tool compile to binary executables, it
also can compile to shared libraries.</p>
<p>YAMLScript generates and publishes the <code>libyamlscript</code> shared library and then
offers binding modules for it in many languages.</p>
<hr>
<p>I hope you are starting to see the power of YAMLScript.
Not only as a new programming language, but also as a new way to work with YAML
files that you already have.</p>
<p>Join me tomorrow for Day 22 of the YAMLScript Advent Blog!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Flip Flops</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-22/"/>
      <updated>2023-12-22T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-22/</id>
      <content type="html">
        <![CDATA[
      <p>Can you imagine Santa walking around in flip flops?
I've never been up to the North Pole, but I'm pretty sure there's no beaches.
I always pictured Santa wearing moon boots around the workshop.</p>
<p>YAMLScript on the other hand, is all about flip flops!</p>
<h3>Welcome to Day 22 of the YAMLScript Advent Blog!</h3>
<p>Remember way back in <a href="../dec-06/">Day 6</a> when we talked about the 3 different
YAMLScript modes?
They were <strong>bare</strong>, <strong>data</strong> and <strong>code</strong>.
The bare mode was what you got then you ran (or loaded) a YAMLScript program
with no <code>!yamlscript/v0</code> tag at the top.
It just meant that you were effectively stuck in data mode, with no possibility
of executing any code.</p>
<p>There's actually comfort in <strong>bare</strong> mode.
You are using YAMLScript to process your data because it is one of the best
YAML loaders available, but you don't have to worry about any code being
run accidentally.</p>
<p>Today's post is about the other two modes.
Either you are writing a program (thus starting in <strong>code</strong> mode) or you are
doing cool stuff with your data files (thus starting in <strong>data</strong> mode).</p>
<p>In either case you are going to want to switch modes at various places in your
YAMLScript.
We learned before that you could switch modes by using the <code>!</code> tag.
This is the smallest possible tag and we use it for the most common need.</p>
<p>Here's an example of using YAMLScript to generate data to be loaded.
We'll start in code mode by using <code>!yamlscript/v0</code>:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><br><span class="token key atrule">vars =</span><span class="token punctuation">:</span> <span class="token tag">!</span><br>  <span class="token key atrule">colors</span><span class="token punctuation">:</span><br>  <span class="token punctuation">-</span> red<br>  <span class="token punctuation">-</span> <span class="token tag">!</span> ("gre" + "en")<br>  <span class="token punctuation">-</span> blue<br>  <span class="token key atrule">numbers</span><span class="token punctuation">:</span> <span class="token tag">!</span><br>    <span class="token key atrule">vec</span><span class="token punctuation">:</span><br>      <span class="token key atrule">map \(% * 10)</span><span class="token punctuation">:</span> <span class="token tag">!</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><br>  <span class="token key atrule">awesome</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token key atrule">yaml</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token punctuation">,</span> <span class="token key atrule">xml</span><span class="token punctuation">:</span> <span class="token tag">!</span> (1 <span class="token punctuation">></span> 2) <span class="token punctuation">}</span><br><br><span class="token key atrule">=></span><span class="token punctuation">:</span> <span class="token tag">!</span><br><span class="token punctuation">-</span> <span class="token tag">!</span> <span class="token string">"$(vars.colors.1) with envy"</span><br><span class="token punctuation">-</span> <span class="token tag">!</span> <span class="token string">"Four score and $(vars.numbers.1) years ago"</span><br><span class="token punctuation">-</span> <span class="token tag">!</span> <span class="token string">"Santa wears flip flops. $(vars.awesome.yaml) or $(vars.awesome.xml)?"</span></code></pre>
<p>That's more bangs than a fireworks show in a barbershop!</p>
<p>This was just a crazy way to get the following data:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token punctuation">-</span> green with envy<br><span class="token punctuation">-</span> Four score and 20 years ago<br><span class="token punctuation">-</span> Santa wears flip flops. true or false<span class="token punctuation">?</span></code></pre>
<p>Every time you see a <code>!</code> tag, it means that we are switching modes from <code>code</code>
to <code>data</code> or vice versa.</p>
<p>Let's walk through it:</p>
<ul>
<li><code>!yamlscript/v0</code> - This tag starts the program in <code>code</code> mode. If we wanted to
start in <code>data</code> mode, we would use <code>!yamlscript/v0/data</code>.</li>
<li><code>vars =: !</code> - We are setting the value of a variable named <code>vars</code> to the some
data we want to write in plain old YAML. Before we can do that, we need to
switch to <code>data</code> mode.</li>
<li><code>! (&quot;gre&quot; + &quot;en&quot;)</code> - This is a YAMLScript expression that evaluates to the
string <code>green</code>. To let YAMLScript know that we want to evaluate this
expression, we switch back to <code>code</code> mode.</li>
<li><code>numbers: !</code> - Even though we just switched to <code>code</code> mode,
in the previous point, it was only for that scalar / expression.
We need to do it again since the mapping we are in is in data mode.</li>
</ul>
<p>And so on.
Note that when we switch modes we do it only for that node, not for the whole
rest of the document.</p>
<h3>A Better Flip Flop Syntax</h3>
<p>The <code>!</code> tag is ok for switching modes, but even though it's one character, I
find it a bit noisy.
Here's another way to switch modes:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token tag">!yamlscript/v0</span><br><br>vars =<span class="token punctuation">:</span><span class="token punctuation">:</span><br>  <span class="token key atrule">colors</span><span class="token punctuation">:</span><br>  <span class="token punctuation">-</span> red<br>  <span class="token punctuation">-</span> <span class="token tag">!</span> ("gre" + "en")<br>  <span class="token punctuation">-</span> blue<br>  numbers<span class="token punctuation">:</span><span class="token punctuation">:</span><br>    <span class="token key atrule">vec</span><span class="token punctuation">:</span><br>      map \(% * 10)<span class="token punctuation">:</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><br>  <span class="token key atrule">awesome</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token key atrule">yaml</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token punctuation">,</span> xml<span class="token punctuation">:</span><span class="token punctuation">:</span> (1 <span class="token punctuation">></span> 2) <span class="token punctuation">}</span><br><br>=<span class="token punctuation">></span><span class="token punctuation">:</span><span class="token punctuation">:</span><br><span class="token punctuation">-</span> <span class="token tag">!</span> <span class="token string">"$(vars.colors.1) with envy"</span><br><span class="token punctuation">-</span> <span class="token tag">!</span> <span class="token string">"Four score and $(vars.numbers.1) years ago"</span><br><span class="token punctuation">-</span> <span class="token tag">!</span> <span class="token string">"Santa wears flip flops. $(vars.awesome.yaml) or $(vars.awesome.xml)?"</span></code></pre>
<p>When a <code>!</code> tag follows a <code>:</code> key/value separator, we can use a <code>::</code> instead to
mean the same thing.</p>
<p>There are still bangs in there because they didn't follow a <code>:</code>.</p>
<hr>
<p>I find the <code>::</code> syntax to be a bit more readable.</p>
<p>Note that this isn't a special new YAML syntax.
It's simply an unquoted key that ends with a colon.</p>
<p>This trick works from both code and data modes.
It does not work from bare mode.
You'll just have a mapping key that ends with a colon.</p>
<p>It might seem like using the <code>!</code> or <code>::</code> as a toggle could get confusing
because you need to keep track of which mode you are in.</p>
<p>But typically it's pretty obvious for a person reading the YAML.
Machines need to be more exact.</p>
<p>I suspect that I'll introduce the <code>!code</code> and <code>!data</code> tags in the future, for
when you feel the need to be explicit.</p>
<hr>
<p>That was a quick post but also an important one for learning how to write
better YAMLScript.</p>
<p>See you tomorrow for Day 23 of the YAMLScript Advent Blog!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Perl to Rust</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-23/"/>
      <updated>2023-12-23T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-23/</id>
      <content type="html">
        <![CDATA[
      <p>When Santa is doing his job in the Luxembourg area, I've always wondered how he
gets from Perl to Rust.</p>
<p>Maybe he takes <a href="https://oylenshpeegul.gitlab.io/from-perl-to-rust/introduction.html">this route</a>!</p>
<h3>Welcome to Day 23 of the YAMLScript Advent Blog!</h3>
<p>A couple of days ago we showed you how to use YAMLScript from Python.</p>
<p>One language binding down, forty-one to go!</p>
<p>Today we'll show you how to use YAMLScript with 3 new programming language
bindings: <strong>Perl</strong>, <strong>Rust</strong> and <strong>Raku</strong> (aka Perl 6).</p>
<p>YAMLScript gets by with a little help from its friends:</p>
<ul>
<li><a href="https://github.com/tony-o">@tony-o</a> - Raku binding</li>
<li><a href="https://github.com/ethiraric">@ethiraric</a> - Rust binding</li>
<li><a href="https://github.com/jjatria">@jjatria</a> - Perl binding</li>
<li><a href="https://github.com/vendethiel">@vendethiel</a> - Polyglot extraordinaire</li>
</ul>
<p>These guys are awesome!</p>
<h3>I Heard a Rumor!</h3>
<p>Let's make up a little YAMLScript program that we can run from all the new
YAMLScript bindings:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token comment"># hearsay.ys</span><br><br><span class="token comment"># ys --load hearsay.ys | jq -r .</span><br><br><span class="token tag">!yamlscript/v0</span><br><br>hackers =<span class="token punctuation">:</span><span class="token punctuation">:</span><br><span class="token punctuation">-</span> ethiraric<br><span class="token punctuation">-</span> ingydotnet<br><span class="token punctuation">-</span> jjatria<br><span class="token punctuation">-</span> tony<span class="token punctuation">-</span>o<br><br>languages =<span class="token punctuation">:</span><span class="token punctuation">:</span><br><span class="token punctuation">-</span> Perl<br><span class="token punctuation">-</span> Python<br><span class="token punctuation">-</span> Raku<br><span class="token punctuation">-</span> Rust<br><br><span class="token key atrule">=></span><span class="token punctuation">:</span> "I heard that @$rand<span class="token punctuation">-</span>nth(hackers) uses YAMLScript<br>    in their $rand<span class="token punctuation">-</span>nth(languages) code<span class="token tag">!</span>"<br></code></pre>
<p>Now run (actually &quot;load&quot;) this a few times using the YAMLScript <code>ys --load</code>
command:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">--load</span> hearsay.ys <span class="token operator">|</span> jq <span class="token parameter variable">-r</span> <span class="token builtin class-name">.</span><br>I heard that @tony-o uses YAMLScript <span class="token keyword">in</span> their Rust code<span class="token operator">!</span><br>$ ys <span class="token parameter variable">--load</span> hearsay.ys <span class="token operator">|</span> jq <span class="token parameter variable">-r</span> <span class="token builtin class-name">.</span><br>I heard that @ethiraric uses YAMLScript <span class="token keyword">in</span> their Python code<span class="token operator">!</span><br>$ ys <span class="token parameter variable">--load</span> hearsay.ys <span class="token operator">|</span> jq <span class="token parameter variable">-r</span> <span class="token builtin class-name">.</span><br>I heard that @jjatria uses YAMLScript <span class="token keyword">in</span> their Rust code<span class="token operator">!</span><br>$ ys <span class="token parameter variable">--load</span> hearsay.ys <span class="token operator">|</span> jq <span class="token parameter variable">-r</span> <span class="token builtin class-name">.</span><br>I heard that @ingydotnet uses YAMLScript <span class="token keyword">in</span> their Perl code<span class="token operator">!</span><br>$ ys <span class="token parameter variable">--load</span> hearsay.ys <span class="token operator">|</span> jq <span class="token parameter variable">-r</span> <span class="token builtin class-name">.</span><br>I heard that @vendethiel uses YAMLScript <span class="token keyword">in</span> their Raku code<span class="token operator">!</span><br>$</code></pre>
<p>Works like a charm!</p>
<p><strong>Now let's load this program from each of the new language bindings!</strong></p>
<h3>Perl</h3>
<p>I've been programming Perl for a very long time.
25 years actually.
I've published over 200 Perl modules on CPAN.
My first one was called <a href="https://metacpan.org/pod/Inline::C">Inline::C</a> which makes it trivial to write C bindings
in Perl.</p>
<p>That's exactly what I needed to get done today to write this blog post about it.
Ironically, I've forgotten how to use Inline::C, so I asked an AI to do it for
me.
It gave me something reasonable looking, but I couldn't get it working.</p>
<p>But the best part of Perl is its community!
My good Perl friend <a href="https://metacpan.org/author/OALDERS">Olaf</a> told me to seek
out a Perl programmer named <a href="https://metacpan.org/author/JJATRIA">JJ</a>.
I did and he was happy to help.
He got it done in no time, and now I'm writing about it!!!</p>
<p>JJ used the newer Perl FFI binding framework called <a href="https://metacpan.org/pod/FFI::Platypus">FFI::Platypus</a>.</p>
<p>Let's use the new CPAN module YAMLScript to run our <code>hearsay.ys</code> program:</p>
<pre class="language-perl"><code class="language-perl"><span class="token comment"># hearsay.pl</span><br><span class="token keyword">use</span> <span class="token v-string string">v5.16.0</span><span class="token punctuation">;</span><br><span class="token keyword">use</span> YAMLScript<span class="token punctuation">;</span><br><span class="token keyword">use</span> Slurp<span class="token punctuation">;</span><br><span class="token keyword">my</span> <span class="token variable">$program</span> <span class="token operator">=</span> slurp <span class="token string">'hearsay.ys'</span><span class="token punctuation">;</span><br><span class="token keyword">say</span> YAMLScript<span class="token operator">-></span>new<span class="token operator">-></span>load<span class="token punctuation">(</span><span class="token variable">$program</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br></code></pre>
<pre class="language-bash"><code class="language-bash">$ perl hearsay.pl<br>I heard that @ethiraric uses YAMLScript <span class="token keyword">in</span> their Rust code<span class="token operator">!</span><br>$ perl hearsay.pl<br>I heard that @ingydotnet uses YAMLScript <span class="token keyword">in</span> their Python code<span class="token operator">!</span></code></pre>
<p>Just like the Python binding, the Perl module has a <code>load</code> method that takes a
YAMLScript program as a string and returns the result as a Perl data structure.</p>
<p>Install YAMLScript with:</p>
<pre class="language-bash"><code class="language-bash">$ cpanm YAMLScript</code></pre>
<p>Also like the Python binding, the Perl module (and all the other bindings)
currently requires that you install <code>libyamlscript.so</code> yourself.</p>
<p>You can do this easily with:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">curl</span> https://yamlscript.org/install <span class="token operator">|</span> <span class="token function">bash</span></code></pre>
<p>Remember that this installs to <code>/usr/local/lib</code> by default, so you'll need to
run this as root.
(Or use the PREFIX option and set <code>LD_LIBRARY_PATH</code> yourself.)</p>
<h3>Rust</h3>
<p>@ethiraric is a Rust programmer who dropped by the <a href="https://matrix.to/#/#chat:yaml.io">YAML matrix chat</a> a couple of weeks ago looking to improve
Rust's YAML support.
I told him about YAMLScript and suggested he write a Rust binding for it since
it's just one FFI call.</p>
<p>He did and today we get to show it off.</p>
<p>Rust needs a bit more setup than Perl, but it's still pretty easy.</p>
<p>First run <code>cargo new hearsay</code> to create a new Rust project.
Then edit <code>hearsay/Cargo.toml</code> to look like this:</p>
<pre class="language-toml"><code class="language-toml"><span class="token punctuation">[</span><span class="token table class-name">package</span><span class="token punctuation">]</span><br><span class="token key property">name</span> <span class="token punctuation">=</span> <span class="token string">"hearsay"</span><br><span class="token key property">version</span> <span class="token punctuation">=</span> <span class="token string">"0.1.0"</span><br><span class="token key property">edition</span> <span class="token punctuation">=</span> <span class="token string">"2021"</span><br><span class="token punctuation">[</span><span class="token table class-name">dependencies</span><span class="token punctuation">]</span><br><span class="token key property">yamlscript</span> <span class="token punctuation">=</span> <span class="token string">"0.1.2"</span></code></pre>
<p>Then edit <code>hearsay/src/main.rs</code> to look like this:</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> input <span class="token operator">=</span> <span class="token namespace">std<span class="token punctuation">::</span>fs<span class="token punctuation">::</span></span><span class="token function">read_to_string</span><span class="token punctuation">(</span><span class="token string">"hearsay.ys"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> output <span class="token operator">=</span> <span class="token namespace">yamlscript<span class="token punctuation">::</span></span><span class="token function">load</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>input<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{output}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>Now run <code>cargo run</code> and you should see something like this:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">cargo</span> run<br>    Finished dev <span class="token punctuation">[</span>unoptimized + debuginfo<span class="token punctuation">]</span> target<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">0</span>.01s<br>     Running <span class="token variable"><span class="token variable">`</span>target/debug/hearsay<span class="token variable">`</span></span><br><span class="token punctuation">{</span><span class="token string">"data"</span><span class="token builtin class-name">:</span><span class="token string">"I heard that @ethiraric uses YAMLScript in their Python code!"</span><span class="token punctuation">}</span></code></pre>
<p>That's not quite right, but that's where things are at this moment.
The <code>load</code> function is returning a JSON string, but it should be returning a
Rust data structure for whatever was under the <code>&quot;data&quot;</code> JSON key.
I'm sure @ethiraric will fix it soon!!!</p>
<p>It's actually fortunate that the Rust binding is not working yet, because it
shows us <em>how</em> libyamlscript actually works.</p>
<p>The libyamlscript library currently has a single function that takes a
YAMLScript string and returns a JSON string.
Internally it compiles the YAMLScript to Clojure and evaluates the code using
SCI.
Then it converts the result to JSON and returns it.
If the evaluation fails it returns JSON with all the error information under an
<code>&quot;error&quot;</code> key.
If successful, it returns JSON with all the result information under a <code>&quot;data&quot;</code>
key.</p>
<p>The above call was successful, so that's why we see our expected result under
the <code>&quot;data&quot;</code> key.</p>
<h3>Raku</h3>
<p>Raku is the new name for Perl 6.
It's a completely different language than Perl 5, but it's still a lot like
Perl.</p>
<p>@tony-o is a Raku programmer and my personal friend IRL for many years now.
He really loves YAMLScript and wants to work on the language as a whole.
Writing a Raku binding was a perfect way to get him started.</p>
<p>You can install the Raku binding with:</p>
<pre class="language-bash"><code class="language-bash">$ zef <span class="token function">install</span> YAMLScript</code></pre>
<p>Here's the example Raku program:</p>
<pre class="language-perl"><code class="language-perl"><span class="token keyword">use</span> YAMLScript<span class="token punctuation">;</span><br><span class="token keyword">my</span> <span class="token variable">$program</span> <span class="token operator">=</span> slurp <span class="token string">'hearsay.ys'</span><span class="token punctuation">;</span><br><span class="token keyword">my</span> YAMLScript <span class="token variable">$ys</span> <span class="token operator">.=</span> new<span class="token punctuation">;</span><br><span class="token keyword">say</span> <span class="token variable">$ys</span><span class="token operator">.</span>load<span class="token punctuation">(</span><span class="token variable">$program</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br></code></pre>
<p>Then you can run our hearsay program like this:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span>/usr/local/lib raku hearsay.raku<br>I heard that @tony-o uses YAMLScript <span class="token keyword">in</span> their Python code<span class="token operator">!</span></code></pre>
<p>The Raku effort was a two person job.
A big shout out to @vendethiel for helping @tony-o get the Raku binding working
right.</p>
<p>Ven, as we call him, is someone I've known of and highly respected for many
years.
He was a major contributor to both CoffeeScript and Raku which have permanent
places in my heart.
He's Polyglot to the core and possibly more <a href="https://acmeism.org">Acmeist</a> than
Ingy!</p>
<p>But my biggest thanks to Ven is for being my daily sounding board and
protaganist for YAMLScript.
He encourages my good ideas even when they are ambitious and crazy sounding.
Every time he's disagreed with me, he's been right...
Even if it sometimes takes me a while to see it.</p>
<p>Everyone in this penuiltimate advent blog post is a hero to me and definitely on
Santa's nice list!!! (as far as I'm concerned)</p>
<p>Please do join me tomorrow for the final post of the YAMLScript Advent Blog
2023!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Wrapped and Ready</title>
      <link href="https://yamlscript.org/posts/advent-2023/dec-24/"/>
      <updated>2023-12-24T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/dec-24/</id>
      <content type="html">
        <![CDATA[
      <p>The Elves have everything wrapped up.</p>
<p>Literally!</p>
<p>Tonight's the big night.</p>
<p>It's Time to Deliver!</p>
<h3>Welcome to Day 24 of the YAMLScript Advent Calendar</h3>
<p>It's also time to wrap up this year's YAMLScript advent holiday season.
Let's put a bow on it and deliver it to the world.</p>
<p>First we should take a moment to reflect on what we've learned this month.
We can also take a look forward to what's coming up in the New Year.</p>
<h3>The 50,000 Foot View</h3>
<p>We'll start with a high level look at the landscape YAMLScript promises to be.</p>
<ul>
<li>YAMLScript is new programming language</li>
<li>You write YAMLScript in YAML
<ul>
<li>JSON is also YAML</li>
<li>All JSON and most YAML is valid YAMLScript</li>
</ul>
</li>
<li>YAMLScript compiles to Clojure
<ul>
<li>Clojure is a Lisp and a Functional Programming (FP) language</li>
<li>YAMLScript a functional language with a Lisp model</li>
<li>YAMLScript ia a complete language (since Clojure is)</li>
</ul>
</li>
<li>YAMLScript's engine is a native binary executable
<ul>
<li>No JVM involved; no slow startup</li>
<li>YAMLScript starts fast and runs fast</li>
<li>YAMLScript programs can compile to binary executables</li>
</ul>
</li>
<li>YAMLScript has a clean syntax that feels Pythonic
<ul>
<li>YeS-Expressions offer infix operators and prefix function calls</li>
<li>Can also be written in a full-Lisp style</li>
<li>Or full-non-Lisp or anywhere in between</li>
<li>There are many ways to write the same expression in YS</li>
</ul>
</li>
<li>YAMLScript embeds cleanly into existing YAML files
<ul>
<li>Good for simplifying and enhancing existing YAML files</li>
<li>Include parts of other YAML files into any part of a YAML file</li>
<li>Map, filter and transform YAML data to more YAML data</li>
</ul>
</li>
<li>YAMLScript can use libraries written in Clojure or YAMLScript
<ul>
<li>Lots of existing Clojure libraries will work with YAMLScript</li>
<li>YAMLScript libraries can be written in YAMLScript</li>
<li>YAMLScript can be used as a scripting language</li>
</ul>
</li>
<li>YAMLScript provides the <code>ys</code> command line tool
<ul>
<li>Compile YAMLScript files to Clojure code</li>
<li>Compile YAMLScript files to native binary executables</li>
<li>Convert between YAML, JSON and EDN</li>
<li>Eval YAMLScript expressions from the command line</li>
</ul>
</li>
<li>YAMLScript provides the <code>libyamlscript</code> shared library
<ul>
<li>Bindable to most programming languages</li>
<li>Growing number of languages have YS binding modules</li>
<li>Load plain old YAML files more correctly</li>
<li>Load YAML files with embedded transformation code</li>
<li>Run subtasks written in YAMLScript from another language</li>
</ul>
</li>
</ul>
<h3>The State of the YAMLScript</h3>
<p>YAMLScript is a year and a half old from inception, but it really found its
direction in July 2023.</p>
<p>It is now a working programming language with:</p>
<ul>
<li>A compiler</li>
<li>A mature runtime</li>
<li>A mature standard library</li>
<li>Binding modules in several programming languages</li>
<li>Regular binary releases for Linux, Mac (x64 and ARM)</li>
<li>Simple one-line installer commands</li>
<li>Example programs on Rosetta Code</li>
</ul>
<p>Many things remain to be done:</p>
<ul>
<li>Windows support</li>
<li>Finish the v0 compiler</li>
<li>YAMLScript v0 specification</li>
<li>Test suite with complete coverage</li>
<li>User documentation and tutorials</li>
<li>Binding modules for most modern programming languages</li>
<li>A YAMLScript module registry</li>
</ul>
<p>to name a few.</p>
<h3>What Lies Ahead</h3>
<p>The complete scope and trajectory of YAMLScript is unknown.
I'm confident that it will be used in ways I can't even imagine.</p>
<p>This notion is built into the design of YAMLScript.
Stating the explicit API version (<code>v0</code>) is a mandatory part of the writing and
using YAMLScript code.
Version 1 can completely break away from version 0, and no existing code will
be affected.</p>
<p>I already have exciting plans queued up for the next year:</p>
<ul>
<li>IDE support (Calva + source maps)</li>
<li>The YAMLScript Macro System</li>
<li>nREPL server support</li>
<li>Top notch error messages</li>
<li>Cross language shared library auto-binding</li>
<li>Use case tutorials and examples
<ul>
<li>Simplifying massive YAML deployment files</li>
<li>Using YAMLScript for better CI/CD workflows</li>
<li>Task automation with YAMLScript</li>
</ul>
</li>
</ul>
<h3>The End of an Advent</h3>
<p>I hope you've enjoyed this year's YAMLScript Advent Blog.
I enjoyed writing it but I'm relieved that it's finally over.
It's one thing to write a blog post every day and another to be working around
the clock trying to implement everything you're writing about.</p>
<p>Those things I've listed above deserve more explanation.
Perhaps they each deserve their own blog post!
I look forward to telling you about each of them in detail.
But...</p>
<p>I'm going to take the rest of the year off from blogging about YAMLScript.
I'll keep working on the language itself because that's just pure fun for me.
(Usually.)</p>
<p>I'll be back in January and I'll try to put out a blog post every week or two.
From now on I don't have to blog about things that I just barely got working
after burning the midnight oil.</p>
<p>I'm so excited about this language!!!</p>
<p>I knew that doing this advent calendar was going to be a huge challenge, but I
also knew that it was just the thing to drive YAMLScript forward.
The alternative was to wait a full year for Advent 2024.
Thank goodness for my ADD. (Advent Driven Development)</p>
<p>Happy Holidays to you and yours.</p>
<p>I'll see you in the future.</p>
<p>Don't forget your sunglasses.</p>
<p>The future is bright!!!</p>
<p>— Ingy döt Net and the YAMLScript Elves</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>2023 Advent Index</title>
      <link href="https://yamlscript.org/posts/advent-2023/index/"/>
      <updated>2023-12-25T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/advent-2023/index/</id>
      <content type="html">
        <![CDATA[
      <h3>Welcome to the 2023 YAMLScript Advent Blog!</h3>
<p>&nbsp;</p>
<h3><a href="/posts/advent-2023/dec-24">Dec 24 - Wrapped and Ready</a></h3>
<h3><a href="/posts/advent-2023/dec-23">Dec 23 - Perl to Rust</a></h3>
<h3><a href="/posts/advent-2023/dec-22">Dec 22 - Flip Flops</a></h3>
<h3><a href="/posts/advent-2023/dec-21">Dec 21 - YAML, Python and the Holy Graal</a></h3>
<h3><a href="/posts/advent-2023/dec-20">Dec 20 - Godspeed</a></h3>
<h3><a href="/posts/advent-2023/dec-19">Dec 19 - Reindeer All The Way Down</a></h3>
<h3><a href="/posts/advent-2023/dec-18">Dec 18 - Santa's in d-buggy</a></h3>
<h3><a href="/posts/advent-2023/dec-17">Dec 17 - Rosetta Code</a></h3>
<h3><a href="/posts/advent-2023/dec-16">Dec 16 - Let Lambda Come Over</a></h3>
<h3><a href="/posts/advent-2023/dec-15">Dec 15 - Naughty is Nice!</a></h3>
<h3><a href="/posts/advent-2023/dec-14">Dec 14 - Stocking Stuffers</a></h3>
<h3><a href="/posts/advent-2023/dec-13">Dec 13 - History Lesson</a></h3>
<h3><a href="/posts/advent-2023/dec-12">Dec 12 - Future Proof</a></h3>
<h3><a href="/posts/advent-2023/dec-11">Dec 11 - The YeS Express</a></h3>
<h3><a href="/posts/advent-2023/dec-10">Dec 10 - States and Ladders</a></h3>
<h3><a href="/posts/advent-2023/dec-09">Dec 9 - Coding with Style</a></h3>
<h3><a href="/posts/advent-2023/dec-08">Dec 8 - Going to the Library</a></h3>
<h3><a href="/posts/advent-2023/dec-07">Dec 7 - Sharpen Your Tools</a></h3>
<h3><a href="/posts/advent-2023/dec-06">Dec 6 - Modes of Transportation</a></h3>
<h3><a href="/posts/advent-2023/dec-05">Dec 5 - Unwrapping Gifts</a></h3>
<h3><a href="/posts/advent-2023/dec-04">Dec 4 - Santa's Big Secret</a></h3>
<h3><a href="/posts/advent-2023/dec-03">Dec 3 - Load em Up!</a></h3>
<h3><a href="/posts/advent-2023/dec-02">Dec 2 - Twas a Bit</a></h3>
<h3><a href="/posts/advent-2023/dec-01">Dec 1 - YAMLScript Advent 2023</a></h3>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>YAMLScript Firsts</title>
      <link href="https://yamlscript.org/posts/mar-14-2024/"/>
      <updated>2024-03-14T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/mar-14-2024/</id>
      <content type="html">
        <![CDATA[
      <h3>Remember Your First Time?</h3>
<p>Do you remember the first time you wrote a program in a new language?
For YAMLScript, mine was yesterday!</p>
<p>This is my first post of 2024.
I've been working on YAMLScript non-stop since the last <a href="/posts/advent-2023/index/">YAMLScript Advent
2023</a> post.
Too busy to write a blog post, I guess.</p>
<p>Yesterday something awesome happened.</p>
<p>Putting out a YAMLScript release is a complicated process.
It takes me about an hour to do it.
Of course I plan to automate it fully but I just haven't had the tuits.</p>
<p>For the last several releases, I've had a text file that listed all the steps so
that I wouldn't forget anything.
Yesterday I automated that list...</p>
<p>...you guessed it...</p>
<p>...in YAMLScript!</p>
<h3>The 10 Step Program</h3>
<p>Of course I have been writing test programs in YAMLScript for a while now.
This was the first time that I wrote a YAMLScript program that actually does
something I need to do on a regular basis.</p>
<p>Without further ado, here is the <a href="https://github.com/yaml/yamlscript/blob/29996dd705/util/release-yamlscript">YAMLScript Release Automation Program</a>.</p>
<p>It's a 10 step program that does everything I used to do manually.
I think it turned out pretty nice.</p>
<p>Judge for yourself but let me tell you a bit about it first.</p>
<ul>
<li>There are 10 steps to perform.</li>
<li>If a step fails you can run it again.</li>
<li>You can indicate which steps to start and end at.</li>
<li>Reports information about each step as it goes.</li>
<li>Has a verbose mode that shows you what it has done to various files.</li>
<li>Has a dry-run mode that shows you what it would do without doing anything.</li>
<li>Validates its inputs and tries to doublecheck its work.</li>
<li>Everything is broken up into short and simple functions.</li>
<li>Execution starts with the main function at the top.</li>
<li>Shells out to common CLI commands to get things done.</li>
<li>Uses multiline literal scalars with interpolation to make changelog entries.</li>
<li>Fairly well documented internally with comments.</li>
</ul>
<p>It's pretty much like a shell script, but written in YAMLScript.
Given that YAMLScript is a functional language with immutable data, perhaps it's
more reliable than a shell script.
Time will tell.</p>
<p>I also added a Makefile rule to run the program.
It supports several variables to control the program and writes the output to
stdout and a log file.</p>
<p>Here's the output from a dry-run:</p>
<pre class="language-bash"><code class="language-bash">$ <span class="token function">make</span> release-yamlscript <span class="token assign-left variable">o</span><span class="token operator">=</span><span class="token number">0.1</span>.42 <span class="token assign-left variable">n</span><span class="token operator">=</span><span class="token number">0.1</span>.43 <span class="token assign-left variable">v</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">d</span><span class="token operator">=</span><span class="token number">1</span><br>./util/release-yamlscript <span class="token number">0.1</span>.42 <span class="token number">0.1</span>.43  <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">|</span> <span class="token function">tee</span> <span class="token parameter variable">-a</span> release-0.1.43.log<br><br>Releasing YAMLScript v0.1.43 at Thu Mar <span class="token number">14</span> 07:28:19 AM PDT <span class="token number">2024</span><br><br><br>Step <span class="token number">1</span><span class="token punctuation">)</span> Update <span class="token string">'.version.sh'</span> <span class="token function">file</span><br>+ <span class="token function">git</span> <span class="token parameter variable">-P</span> <span class="token function">diff</span> .version.sh<br><br>Step <span class="token number">2</span><span class="token punctuation">)</span> Run <span class="token string">'make bump'</span><br>+ <span class="token function">make</span> bump<br>+ <span class="token function">git</span> <span class="token parameter variable">-P</span> <span class="token function">diff</span><br><br>Step <span class="token number">3</span><span class="token punctuation">)</span> Update the <span class="token string">'Changes'</span> <span class="token function">file</span><br>+ <span class="token function">grep</span> <span class="token parameter variable">-F</span> <span class="token parameter variable">-B999</span> <span class="token string">'0.1.42'</span> Changes<br><br>Step <span class="token number">4</span><span class="token punctuation">)</span> Update the Change Log files <span class="token keyword">for</span> the binding modules<br><br>Step <span class="token number">5</span><span class="token punctuation">)</span> Commit the release changes to <span class="token function">git</span><br>+ <span class="token function">git</span> commit <span class="token parameter variable">-a</span> <span class="token parameter variable">-m</span> <span class="token string">'release: 0.1.43'</span><br><br>Step <span class="token number">6</span><span class="token punctuation">)</span> Add <span class="token function">git</span> tag <span class="token keyword">for</span> the new version<br>+ <span class="token function">git</span> tag <span class="token number">0.1</span>.43<br><br>Step <span class="token number">7</span><span class="token punctuation">)</span> Push the <span class="token function">git</span> commit and tag<br>+ <span class="token function">git</span> push<br>+ <span class="token function">git</span> push <span class="token parameter variable">--tags</span><br><br>Step <span class="token number">8</span><span class="token punctuation">)</span> Run <span class="token string">'make release'</span><br>+ <span class="token function">make</span> release<br><br>Step <span class="token number">9</span><span class="token punctuation">)</span> Run <span class="token string">'make release'</span> <span class="token keyword">for</span> each language binding library<br>+ <span class="token function">make</span> <span class="token parameter variable">-C</span> clojure release<br>+ <span class="token function">make</span> <span class="token parameter variable">-C</span> <span class="token function">java</span> release<br>+ <span class="token function">make</span> <span class="token parameter variable">-C</span> nodejs release<br>+ <span class="token function">make</span> <span class="token parameter variable">-C</span> perl release<br>+ <span class="token function">make</span> <span class="token parameter variable">-C</span> perl-alien release<br>+ <span class="token function">make</span> <span class="token parameter variable">-C</span> python release<br>+ <span class="token function">make</span> <span class="token parameter variable">-C</span> raku release<br>+ <span class="token function">make</span> <span class="token parameter variable">-C</span> ruby release<br>+ <span class="token function">make</span> <span class="token parameter variable">-C</span> rust release<br>+ <span class="token function">git</span> <span class="token parameter variable">-P</span> <span class="token function">diff</span><br><br>Step <span class="token number">10</span><span class="token punctuation">)</span> Publish the yamlscript.org website<br>+ <span class="token function">make</span> <span class="token parameter variable">-C</span> www realclean publish</code></pre>
<p>Maybe it's time for you to write your first YAMLScript program!</p>
<p>If you do, drop me a line and tell me how it went.
YS is still a young language and I'm always looking for feedback.</p>
<h3>Other Firsts</h3>
<p>Last Monday someone published the <a href="https://thenewstack.io/with-yamlscript-yaml-becomes-a-proper-programming-language/">first article about YAMLScript</a>.</p>
<p>It was based on YAML core team member <a href="https://github.com/perlpunk">Tina Müller</a>'s <a href="https://fosdem.org/2024/schedule/event/fosdem-2024-2046-do-you-know-yaml-/">recent talk about YAML</a> at the <a href="https://fosdem.org/2024/">FOSDEM 2024</a> which had a section about
YAMLScript.</p>
<p>The article was accurate and well researched which is a rare thing for YAML in
my experience.</p>
<p>Also last week I gave the first 2024 public talk about YAMLScript at the
<a href="https://www.meetup.com/seajure/events/299251467/">Seajure Meetup</a> in Seattle.
Seajure is a Seattle based Clojure meetup that I started attending last year.
The talk was well received and I got some good feedback.
The video should be available soon.</p>
<p>Next month YAMLScript will be presented at its <a href="https://ossna2024.sched.com/event/1aBPY">first conference talk of 2024</a> at
the <a href="https://events.linuxfoundation.org/open-source-summit-north-america/">Linux Foundation's Open Source Summit North America</a>.
I hope to see you there!</p>
<h3>Future Firsts</h3>
<p>There's a few big things in the works for YAMLScript this year worth mentioning:</p>
<ul>
<li>A YAML Schema DSL that will be used to validate YAMLScript evaluation results.</li>
<li>Compiler source maps for IDE integration and better error messages.</li>
<li>YAMLScript User Documentation (finally).</li>
</ul>
<p>I'll be back here next week to tell you about all the things that have happened
with YAMLScript in the last 3 months.
So much good stuff.
Stay tuned!</p>
<p>YS We Can! — Ingy döt Net</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>YAMLScript Spring Update</title>
      <link href="https://yamlscript.org/posts/apr-16-2024/"/>
      <updated>2024-04-16T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/apr-16-2024/</id>
      <content type="html">
        <![CDATA[
      <p>It's been a while since I let you know what's been happening with YAMLScript.
I've been busy working on it every day this year and I have a lot to tell you
about!</p>
<h3>YAMLScript Activity in 2024</h3>
<p>Let me start by telling you about some of the events that have happened in the
YAMLScript world recently.</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=GajOBwBcFyA">Seajure Talk</a> -
I gave a talk at the Seajure (Seattle Clojure) Meetup in March.</li>
<li><a href="https://thenewstack.io/with-yamlscript-yaml-becomes-a-proper-programming-language/">YAMLScript Article</a> -
The New Stack published an article about YAMLScript in March</li>
<li><a href="https://www.therepl.net/episodes/52/">YAMLScript Podcast</a> -
I was interviewed on the &quot;The REPL&quot; by Daniel Compton in April.</li>
</ul>
<p>Finally I'm presenting a talk about <a href="https://sched.co/1aBPY">YAMLScript at the Open Source Summit North
America</a> this Thursday, April 18th.
Super excited about that!</p>
<h3>YAMLScript Progress Since the Advent Series</h3>
<p>I blogged about YAMLScript every day in December 2023.
That was something.
We were madly trying to implement all the stuff I was talking about.
I may have told a few small lies along the way, but I'm happy to say that
everything I talked about is now implemented and working.</p>
<p>And of course we've added a lot more since then.</p>
<p>Let's talk about some of the highlights.</p>
<h3>More YAMLScript Language Binding Libraries</h3>
<p>We've added 4 new binding libraries for YAMLScript in 2024, bringing the total
to 8:
<a href="https://clojars.org/org.yamlscript/clj-yamlscript">Clojure</a> (new),
<a href="https://clojars.org/org.yamlscript/yamlscript">Java</a> (new),
<a href="https://www.npmjs.com/package/@yaml/yamlscript">NodeJS</a> (new),
<a href="https://metacpan.org/dist/YAMLScript/view/lib/YAMLScript.pod">Perl</a>,
<a href="https://pypi.org/project/yamlscript/">Python</a>,
<a href="https://raku.land/zef:ingy/YAMLScript">Raku</a>,
<a href="https://rubygems.org/search?query=yamlscript">Ruby</a> (new) and
<a href="https://crates.io/crates/yamlscript">Rust</a>.</p>
<p>The idea is to eventually have binding libraries for every language where YAML
is currently used.
I expect more to come soon.
If you see a missing language that you want (and you are handy with FFI), please
consider writing a binding library for it and submitting a PR to the <a href="https://github.com/yaml/yamlscript">YAMLScript
Mono Repository</a>.</p>
<p>All the libraries are a small amount of code and are easy to write.</p>
<p>If you need help, please stop by the <a href="https://matrix.to/#/#chat-yamlscript:yaml.io">YAMLScript Matrix Chat Room</a> and we'll get you what you need.</p>
<h3>New Dot Chaining Operator</h3>
<p>In Clojure you can write:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">take</span> <span class="token number">5</span><br>  <span class="token punctuation">(</span><span class="token function">shuffle</span><br>    <span class="token punctuation">(</span><span class="token keyword">filter</span> even?<br>      <span class="token punctuation">(</span><span class="token keyword">range</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<blockquote>
<p>Evaluates to something like: <code>[94 36 4 70 74]</code></p>
</blockquote>
<p>Often people like to use Clojure's threading macro (<code>-&gt;</code>) to make this more
readable:</p>
<pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">->></span> <span class="token punctuation">(</span><span class="token keyword">range</span> <span class="token number">100</span><span class="token punctuation">)</span><br>     <span class="token punctuation">(</span><span class="token keyword">filter</span> even?<span class="token punctuation">)</span><br>     <span class="token punctuation">(</span><span class="token function">shuffle</span><span class="token punctuation">)</span><br>     <span class="token punctuation">(</span><span class="token keyword">take</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Let's look at the same thing in YAMLScript in various styles.</p>
<p>Basic block style:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">take 5</span><span class="token punctuation">:</span><br>  <span class="token key atrule">shuffle</span><span class="token punctuation">:</span><br>    <span class="token key atrule">filter even?</span><span class="token punctuation">:</span><br>      <span class="token key atrule">range</span><span class="token punctuation">:</span> <span class="token number">100</span></code></pre>
<p><a href="https://yamlscript.org/doc/yes/">Yes Expression style</a>:</p>
<pre class="language-yaml"><code class="language-yaml">take(5<br>  shuffle(<br>    filter(even<span class="token punctuation">?</span><br>      range(100))))</code></pre>
<p>Clojure threading style:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">->> range(100)</span><span class="token punctuation">:</span><br>  filter(even<span class="token punctuation">?</span>)<br>  shuffle<br>  take(5)</code></pre>
<p>And now with the new dot chaining operator:</p>
<pre class="language-yaml"><code class="language-yaml">range(100)<br>  .filter(even<span class="token punctuation">?</span> _)<br>  .shuffle()<br>  .take(5 _)</code></pre>
<p>Or all on one line:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">$ ys -e 'say</span><span class="token punctuation">:</span> range(100).filter(even<span class="token punctuation">?</span> _).shuffle().take(5 _)'</code></pre>
<h4>More about the Dot Chaining Operator</h4>
<p>Above we used the dot operator to chain function calls together.
But it's even more useful than that.</p>
<p>Consider:</p>
<pre class="language-yaml"><code class="language-yaml">a.b.3.c().d(e).f(g _).$h</code></pre>
<p>If <code>a</code> is a mapping, the <code>&quot;b&quot;</code> (or <code>:b</code> or <code>'b</code>) key is looked up.<br>
<code>3</code> is the 4th element of the list that <code>b</code> resolves to.<br>
<code>c</code> is called as a function with the result of <code>3</code> as an argument.<br>
<code>d</code> is called as a function with the result of <code>c</code> and <code>e</code> as arguments.<br>
<code>f</code> is called as a function with <code>g</code> and the result of <code>d</code> as arguments.<br>
Finally the key in variable <code>h</code> is looked up in the result of <code>f</code>.</p>
<p>One common idiom is looking up environment variables.
For example: <code>ENV.HOME</code> or <code>ENV.USER.str/upper-case()</code>.</p>
<h3>New Operators and Syntax</h3>
<p>In the last section we saw the new chaining operator: <code>.</code>.</p>
<p>The interesting thing to note here is that <code>.</code> already had a meaning in Clojure.
It's the namespace separator, as in <code>clojure.core/println</code>.</p>
<p>YAMLScript uses <code>::</code> for that separator instead, so we'd say
<code>clojure::core/println</code>.</p>
<p>In a similar switch-up, we added the <code>%</code> and <code>%%</code> operators.
<code>(a % b)</code> compiles to the Clojure code <code>(rem a b)</code>, and <code>(a %% b)</code> compiles to
<code>(mod a b)</code>; 2 slightly different math functions.</p>
<p>In Clojure, <code>%</code> was already a shorthand for the <code>%1</code> argument in anonymous
functions.</p>
<p>In YAMLScript, you'll need to use <code>%1</code> for that:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">square =</span><span class="token punctuation">:</span> \(%1 * %1)</code></pre>
<p>Next we added <code>**</code> for exponentiation.
So <code>2 ** 3</code> compiles to <code>(pow 2 3)</code>.
We also added <code>pow</code> to the <code>ys::std</code> YAMLScript standard library, so you can say
<code>pow(2 3)</code> instead of <code>Math/pow(2 3)</code>.
More about the standard library in a bit.</p>
<p>We added the Perl style regex operator <code>=~</code> and regex literal <code>/.../</code>.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">if (peanut-butter =~ /chocolate/)</span><span class="token punctuation">:</span><br>  <span class="token key atrule">say</span><span class="token punctuation">:</span> <span class="token string">"You've got chocolate in my peanut butter!"</span></code></pre>
<p>You might have noticed that YAMLScript uses <code>\( ... )</code> for anonymous functions,
where Clojure uses <code>#( ... )</code>.
Things starting with <code>#</code> are comments in YAML, so that's problematic.</p>
<p>We decided the <code>\</code> would be a general purpose escape character, but Clojure
already uses <code>\</code> for escaping character literals.</p>
<p>YAMLScript now uses <code>\\</code> for that purpose: <code>str(\\a \\b \\c)</code> would evaluate to
<code>&quot;abc&quot;</code>.</p>
<p>In Clojure you see <code>'foo</code> used extensively for quoting symbols.
In YAML, single quotes are used for string literals, and I felt it was important
to keep that distinction.</p>
<p>Luckily in Clojure you can use <code>(quote foo)</code> for the same thing.
In YAMLScript you can use <code>quote(foo)</code>.
We added the shorthand <code>q(foo)</code> as well as <code>\'foo</code> for quoting.</p>
<p>Finally, we added <code>foo*</code> splatting.</p>
<p>It is common in Clojure to use <code>apply</code> to call a function with a list of
arguments: <code>(apply f [1 2 3])</code> is the same as <code>(f 1 2 3)</code>.
So if <code>xs</code> is a sequence of numbers, you'd say <code>(apply f xs)</code>.</p>
<p>In YAMLScript you can say <code>f(xs*)</code> instead.</p>
<p>But it gets better.
You can you use <code>xs*</code> anywhere in a list of arguments: <code>f(1 xs* 3 ys* 5)</code>.</p>
<h3>Standard Global Variables</h3>
<p>Clojure has dynamic variables like <code>*out*</code> and <code>*command-line-args*</code>.</p>
<p>YAMLScript now has a few of these, but we decided to use symbols with <code>ALL-CAPS</code>
instead of <code>*earmuffs*</code> for these. We also made them shorter in some cases.</p>
<ul>
<li><code>ARGV</code> - Command line arguments</li>
<li><code>ARGS</code> - Like <code>ARGV</code> but numbers are converted to numeric values</li>
<li><code>ENV</code> - Environment variable mapping</li>
<li><code>CWD</code> - Current working directory</li>
<li><code>FILE</code> - Path to the current file being processed</li>
<li><code>INC</code> - The YAMLScript module include path</li>
<li><code>VERSIONS</code> - Mapping of versions of key components in YAMLScript</li>
</ul>
<p>We'll be adding more of these as needed.</p>
<h3>The <code>ys::std</code> YAMLScript Standard Library</h3>
<p>We added many libraries that are automatically available in every YAMLScript
program:</p>
<ul>
<li><code>ys::std</code> - The standard library (also available <code>std</code>)</li>
<li><code>clojure::str</code> - available as <code>str</code></li>
<li><code>clojure::math</code> - available as <code>math</code></li>
<li><code>clojure::tools::cli</code> - available as <code>cli</code></li>
<li><code>babashka::fs</code> - avaiable as <code>fs</code></li>
<li><code>babashka::http</code> - available as <code>http</code></li>
</ul>
<p>and more.</p>
<p>The <code>ys::std</code> library is the most important one.
We can see all the functions available in it by running:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-e</span> <span class="token string">'say: q(std).ns-publics().keys().sort().vec()'</span> <span class="token operator">|</span> zprint <span class="token string">'{:width 40}'</span><br><span class="token punctuation">[</span><span class="token variable">$$</span> *_ +++ +++* +_ <span class="token operator">=</span>-- _<span class="token operator">&amp;</span> _* _** _T __<br> _dot abspath <span class="token function">curl</span> cwd die <span class="token function">dirname</span> each<br> err <span class="token builtin class-name">exec</span> <span class="token function">join</span> new num omap out pow pp<br> pretty print process q rng say <span class="token function">sh</span> shell<br> <span class="token function">sleep</span> throw toBool toFloat toInt toMap<br> toStr use-pod warn www xxx yyy zzz<span class="token punctuation">]</span></code></pre>
<p>You might note that the <code>print</code> function is part of <code>clojure::core</code> and
YAMLScript offers all of that by default.
In a few places we decided to replace Clojure functions with our own versions.
But we also added a <code>ys::clj</code> library that has all the Clojure functions in it.</p>
<p>So if you really need <code>clojure::core/print</code>, you can say <code>clj/print</code>.</p>
<p>Here are the functions in <code>ys::clj</code>:</p>
<pre class="language-bash"><code class="language-bash">$ ys <span class="token parameter variable">-e</span> <span class="token string">'say: q(clj).ns-publics().keys().sort().vec()'</span> <span class="token operator">|</span> zprint <span class="token string">'{:width 40}'</span><br><span class="token punctuation">[</span>compile load load-file num print use<span class="token punctuation">]</span></code></pre>
<p>Not too many.</p>
<p>We'll look at <code>use</code> in the next section.</p>
<h3>Including YAMLScript Libraries and Modules</h3>
<p>I'll start by saying we made the <code>require</code> function nice to use in YAMLScript.</p>
<p>The best way to describe it is to show you the actual test case for it:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> Various require transformations in one pair<br>  <span class="token key atrule">yamlscript</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string"><br>    !yamlscript/v0<br>    require:<br>      foo::aaa: => fa<br>      foo::bbb: one<br>      foo::ccc: one two<br>      foo::ddd:<br>        => fd<br>        one two<br>      foo::eee:<br>      foo::fff: :all</span><br>  <span class="token key atrule">clojure</span><span class="token punctuation">:</span> <span class="token punctuation">|</span><span class="token scalar string"><br>    (require<br>      '[foo.aaa :as fa]<br>      '[foo.bbb :refer [one]]<br>      '[foo.ccc :refer [one two]]<br>      '[foo.ddd :as fd :refer [one two]]<br>      'foo.eee<br>      '[foo.fff :refer :all])</span></code></pre>
<p>That's how we write tests for the YAMLScript compiler.</p>
<p>I think it explains how <code>require</code> works in YAMLScript pretty well.</p>
<p>The <code>require</code> function is used for including Clojure libraries.
We've also added support for writing libraries in YAMLScript itself.
We'll call them &quot;modules&quot; to distinguish them from Clojure libraries.</p>
<p>To use a module in YAMLScript, you use the <code>use</code> function.</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">use</span><span class="token punctuation">:</span> <span class="token string">'my-module'</span></code></pre>
<p>This will look for a file called <code>my-module.ys</code> in the <code>INC</code> path.</p>
<p>The <code>INC</code> path is a list of directories that YAMLScript will look in for and it
defaults to the current directory.
You can override the <code>INC</code> path by setting the <code>YSPATH</code> environment variable.</p>
<p>YAMLScript also added support for <a href="https://book.babashka.org/#pods">Babashka Pods</a>.
You can use a pod in YAMLScript like this:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">use-pod</span><span class="token punctuation">:</span> "org.babashka/go<span class="token punctuation">-</span>sqlite3" "0.1.0"</code></pre>
<h3>Multi-doc and Anchor / Alias Support</h3>
<p>This is the last topic for today, but it's a big one.</p>
<p>Anchors and aliases are an important feature of YAML.
They let you mark a node with a name and then refer to that node by name later.</p>
<p>Until now, YAMLScript has not supported anchors and aliases.
Supporting them is critical because YAMLScript should be able to load all
existing YAML config files, and config files often use anchors and aliases.</p>
<p>Well not only did we add support, we took them to the next level!</p>
<p>YAML has the concept of multiple documents in a single file.
Unfortunately, this is not very useful in the real world; at least not for
config files.
One problem is that YAML doesn't allow you to make an anchor in one document and
use an alias to it in another document.</p>
<p>YAMLScript makes great use of multi-doc combined with anchors and aliases.</p>
<p>Here's an example YAMLScript file <code>file.ys</code> that is part of my
<a href="https://sched.co/1aBPY">upcoming talk at Open Source Summit North America on Thursday</a>:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token punctuation">---</span> <span class="token tag">!yamlscript/v0/</span><br><br><span class="token punctuation">-</span> <span class="token important">&amp;data</span> <span class="token tag">!</span><br>  <span class="token key atrule">yaml/load</span><span class="token punctuation">:</span> slurp('data.yaml')<br><br><span class="token punctuation">-</span> <span class="token important">&amp;map1</span><br>  <span class="token key atrule">key</span><span class="token punctuation">:</span> value<br><br><span class="token punctuation">-</span> <span class="token important">&amp;seq1</span><br>  <span class="token punctuation">-</span> one<br>  <span class="token punctuation">-</span> two<br><br><span class="token punctuation">-</span> <span class="token important">&amp;dogs</span> <span class="token tag">!</span><br>  <span class="token key atrule">yaml/load</span><span class="token punctuation">:</span><br>    curl<span class="token punctuation">:</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//yamlscript.org/dogs.yaml<br><br><span class="token punctuation">---</span> <span class="token tag">!yamlscript/v0/</span><br><br><span class="token key atrule">some</span><span class="token punctuation">:</span> plain data string<br><span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">42</span><br><br>sentence<span class="token punctuation">:</span><span class="token punctuation">:</span><br>  "$(<span class="token important">*data.name)</span> likes<br>  $(<span class="token important">*data.langs.rand-nth())</span><span class="token tag">!</span><span class="token tag">!</span><span class="token tag">!</span>"<br>2 dogs<span class="token punctuation">:</span><span class="token punctuation">:</span> .<span class="token important">*dogs.big.shuffle().take(2</span> _)<br><br><span class="token key atrule">sequence</span><span class="token punctuation">:</span> <span class="token tag">!concat*:</span><br><span class="token punctuation">-</span> <span class="token important">*seq1</span><br><span class="token punctuation">-</span> <span class="token punctuation">[</span>three<span class="token punctuation">,</span> four<span class="token punctuation">]</span><br><span class="token key atrule">mapping</span><span class="token punctuation">:</span> <span class="token tag">!merge*:</span><br><span class="token punctuation">-</span> <span class="token key atrule">this</span><span class="token punctuation">:</span> that<br><span class="token punctuation">-</span> <span class="token important">*map1</span></code></pre>
<p>The <code>data.yaml</code> file that gets loaded looks like this:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> Ingy<br><span class="token key atrule">langs</span><span class="token punctuation">:</span><br><span class="token punctuation">-</span> Bash<br><span class="token punctuation">-</span> Clojure<br><span class="token punctuation">-</span> CoffeeScript<br><span class="token punctuation">-</span> Perl<br><span class="token punctuation">-</span> YAMLScript</code></pre>
<p>When you run <code>ys -Y file.ys</code> you get:</p>
<pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">some</span><span class="token punctuation">:</span> plain data string<br><span class="token key atrule">number</span><span class="token punctuation">:</span> <span class="token number">42</span><br><span class="token key atrule">sentence</span><span class="token punctuation">:</span> Ingy likes CoffeeScript<span class="token tag">!</span><span class="token tag">!</span><span class="token tag">!</span><br><span class="token key atrule">2 dogs</span><span class="token punctuation">:</span><br><span class="token punctuation">-</span> Saint Bernard<br><span class="token punctuation">-</span> Great Dane<br><span class="token key atrule">sequence</span><span class="token punctuation">:</span><br><span class="token punctuation">-</span> one<br><span class="token punctuation">-</span> two<br><span class="token punctuation">-</span> three<br><span class="token punctuation">-</span> four<br><span class="token key atrule">mapping</span><span class="token punctuation">:</span><br>  <span class="token key atrule">this</span><span class="token punctuation">:</span> that<br>  <span class="token key atrule">key</span><span class="token punctuation">:</span> value</code></pre>
<p>I'll let you figure out what's happening here.
It should be fairly obvious and I think it's all pretty cool.</p>
<h3>Moving Forward</h3>
<p>That was a lot of information, I know.
I haven't really found the time to blog about these changes on a regular basis.</p>
<p>Hopefully I'll be able to do that more in the future.</p>
<p>Cheers!</p>

    ]]>
      </content>
    </entry>
  
    
    <entry>
      <title>Dr. StrangeYAML or How I Learned to Stop Worrying and Love the LLM</title>
      <link href="https://yamlscript.org/posts/jun-20-2024/"/>
      <updated>2024-06-20T00:00:00Z</updated>
      <id>https://yamlscript.org/posts/jun-20-2024/</id>
      <content type="html">
        <![CDATA[
      <blockquote>
<p>Well now, what happened is, uh, one of our data scientists, uh, well, he went
a little funny in the head.
You know.
Just a little funny.
And uh, he went and did a silly thing.</p>
<p>Well, I'll tell you what he did.
He started chatting with computers... in YAML.</p>
<p>Well, let me finish, Elon.</p>
<p>Let me <em>finish</em>, Elon.</p>
<p>Well, listen, how do you think <em>I</em> feel about it?</p>
</blockquote>
<p>A couple weeks ago my old friend <a href="https://github.com/prescod">Paul Prescod</a>
asked me if there was a simple subset of YAML that could be used to communicate
with <a href="https://en.wikipedia.org/wiki/Large_language_model">LLM</a>s.</p>
<p>I was a bit aghast at the notion for 2 reasons.</p>
<p>The first was that simplifying YAML is a bit like simplifying a black hole.
(GitHub Copilot wrote that line for me but I like it.)
It's just not something you (ergo I) want to do.</p>
<p>The second reason was that surely something simpler like JSON would be a better
choice for this kind of thing.</p>
<p>But then I thought &quot;Black holes? Meh.&quot;, so I listened to Paul's idea.</p>
<p>His notion was that LLMs only have 3 major, text-based, structured data formats
to train on: XML, JSON, and YAML.
The internet is crammed full of these files.
He said it turns out that YAML is the most efficient when combined with current
LLM tokenization techniques.</p>
<p>It seems he may be right:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=zduSFxRajkE&amp;t=7756s">OpenAI co-founder Andrej Karpathy on YAML vs JSON for LLMs</a></li>
<li><a href="https://betterprogramming.pub/yaml-vs-json-which-is-more-efficient-for-language-models-5bc11dd0f6df">YAML vs. JSON: Which Is More Efficient for Language Models?</a></li>
</ul>
<p>Why is this important?
The only thing that people really seem to care about:</p>
<p>Money.</p>
<p>LLM pricing models are based on token usage.</p>
<p><strong>DO THE MATH.</strong></p>
<p>Over the next few weeks Paul and I are planning to experiment in depth and
hopefully either prove or disprove that this is a good idea.</p>
<h2>Can <a href="https://yamlscript.org">YAMLScript</a> Help with This?</h2>
<pre class="language-text"><code class="language-text">$ yamllm 'Be Dr Strangelove discovering YAMLScript (https://yamlscript.org)'<br><br>llama3-70b-8192:<br>(Maniacal laughter) Ahahahahah! Oh, the beauty of it! The sheer genius!<br>YAMLScript, you say? (Strokes chin) I must admit, I am intrigued. A language<br>that combines the simplicity of YAML with the power of a scripting language?<br>(Giggles) It's like a Strangelovian dream come true!<br><br>(Reading from the YAMLScript website) "YAMLScript is a scripting language that<br>allows you to write scripts in YAML, with a syntax similar to Ansible<br>playbooks." Ah, yes! The elegance of YAML, married to the flexibility of a<br>scripting language. It's like a match made in heaven! (Chuckles) And the best<br>part? It's designed for automation, just like my beloved Doomsday Device!<br><br>(Excitedly) Oh, the possibilities! With YAMLScript, I can automate the<br>deployment of my Doomsday Device, ensuring that the world is destroyed in a most<br>efficient and elegant manner! (Maniacal laughter) And the syntax, oh the syntax!<br>So simple, so intuitive. Even a General Turgidson could understand it!<br>(Chuckles)<br><br>(Reading further) "YAMLScript has built-in support for popular automation tools<br>like Ansible, SaltStack, and Puppet." Ah, yes! The trifecta of automation! With<br>YAMLScript, I can orchestrate the destruction of the world with ease!<br>(Diabolical laughter)<br><br>(Strokes chin thoughtfully) But, I must admit, there is one drawback. It's not<br>as... flashy as my beloved COBOL. (Smirks) But, I suppose, in the world of<br>automation, simplicity and elegance can be just as deadly as a well-placed COBOL<br>program.<br><br>(Concludes) Ah, YAMLScript, you are a worthy addition to my arsenal of doomsday<br>devices! Together, we shall bring about a new era of automated destruction!<br>(Maniacal laughter)</code></pre>
<p>One of the emerging features in <a href="https://github.com/yaml/yamlscript">YAMLScript implementation</a> design is the ability to
script its internals with YAML itself!
Think about that.
You can define the rules of how YAML is loaded without needing to write any
code.</p>
<p>For example, if you wanted the YAML files for your application to not contain
anchors or aliases (just like GitHub Actions' YAML loader does), that's just a
line or 2 of YAML.</p>
<p>Maybe you like the &quot;Norway Problem&quot; so much that you want to treat your users to
the &quot;Slovenia Problem&quot;!
The Norway Problem (fixed in 2009 in the YAML 1.2 spec) is where the plain
scalar <code>no</code> (also the Norway country code) is interpreted as the boolean
<code>false</code> in YAML 1.1.
With just a dash of YAML you can tell YAMLScript to treat <code>si</code> as the boolean
<code>true</code>!</p>
<p>So back to Paul's query.
Yes, by using (a future version of) YAMLScript as your YAML loader, it would be
easy for any application to define a subset of YAML that is more suitable for
their LLM needs.
And since the subset is defined in YAML, it can be easily shared and understood.</p>
<p>Importantly, at no point is there the risk of a subset becoming invalid YAML.
There's a limit to this fine tuning of YAML behavior; it all has to play within
the rules of YAMLScript (which itself has to play within the rules of YAML).</p>
<h2>How I learned to stop paying for ChatGPT and love the YAMLLM</h2>
<p>YAMLScript is turning out to be my favorite programming language.</p>
<p>Up until a couple weeks ago my only interaction with LLMs was using GitHub's
Copilot to help me write blog posts like this one, and paying $20usd/month for a
ChatGPT subscription I almost never used.</p>
<p>When Paul and I started talking, I decided to write some programs to play around
with various (free) LLM APIs like <a href="https://ollama.com/">Ollama</a> and <a href="https://groq.com/">Groq</a>.
Of course I used YAMLScript to write the programs.
You saw this program in action above with the <code>yamllm</code> command asking
<a href="https://www.imdb.com/title/tt0057012/">Dr. Strangelove</a> about YAMLScript.
The results of my scripting efforts are pretty awesome to me.
Both in how much fun it is to interact with LLMs directly using code and how
clean the YAMLScript code ends up being.</p>
<blockquote>
<p><strong>Full Disclosure</strong>: The YAMLScript code is clean because I when it's not I
can (and do) fix the language.
Honestly, I think this is a very important point and should be a goal of any new
programming language.
Implementing a sizable number of <a href="https://rosettacode.org">Rosetta Code Tasks</a>
should be a prerelease milestone.</p>
</blockquote>
<h2>Show me the code!</h2>
<p>The GitHub repository for the YAMLLM script is at
<a href="https://github.com/yaml/yamllm">https://github.com/yaml/yamllm</a>.</p>
<p>It should take you about 60 seconds to <a href="https://github.com/yaml/yamllm?tab=readme-ov-file#installation">get it running</a> on your machine
(Linux or MacOS).</p>
<p>The main YAMLScript source file is at
<a href="https://github.com/yaml/yamllm/blob/main/bin/yamllm.ys">https://github.com/yaml/yamllm/blob/main/bin/yamllm.ys</a>.</p>
<p>Give it a look and <a href="https://github.com/yaml/yamllm/issues">let me know what you think</a>.</p>
<blockquote>
<p>Note that at 140 lines of YAMLScript, the code might seem big at first, but
realize that (aside from the JSON, YAML and HTTP libraries that are embedded in
the YAMLScript runtime) this is all the source code in one file.
No external dependencies.</p>
</blockquote>
<p>Sometimes I wonder if it's all worth it…
Let me ask a friend:</p>
<pre class="language-text"><code class="language-text">$ yamllm 'Do you think YAMLscript (yamlscript.org) will be a success?'<br><br>llama3-70b-8192:<br>What a fascinating question!<br><br>YAMLscript (yamlscript.org) is an interesting project that aims to create a<br>scripting language that uses YAML as its syntax. The idea is to make scripting<br>more accessible and easier to read/write, leveraging the simplicity and<br>familiarity of YAML.<br><br>To predict its success, let's consider a few factors:<br><br>**Pros:**<br><br>1. **Simplification**: YAMLscript's syntax is designed to be easy to read and<br>   write, which could attract users who find traditional programming languages<br>   intimidating.<br>2. ** Familiarity**: YAML is already widely used in many industries, so the<br>   learning curve might be shorter for developers already familiar with YAML.<br>3. **Interoperability**: YAMLscript's ability to integrate with existing YAML<br>   tools and workflows could lead to a seamless adoption process.<br><br>**Cons:**<br><br>1. **Competition**: The scripting language landscape is crowded, with<br>   established players like Python, JavaScript, and PowerShell.<br>2. **Adoption**: YAMLscript will need to gain significant traction and adoption<br>   to become a viable alternative to existing scripting languages.<br>3. **Ecosystem**: Building a comprehensive ecosystem of libraries, frameworks,<br>   and tools will take time and effort.<br><br>**Success factors:**<br><br>1. **Community involvement**: If YAMLscript can build a strong, engaged<br>   community that contributes to its development, it will increase its chances<br>   of success.<br>2. **Use cases**: Identifying specific use cases where YAMLscript shines, such<br>   as data processing or automation, could help it gain traction.<br>3. **Innovation**: Continuous innovation and improvement of the language and its<br>   ecosystem will be crucial to stay competitive.<br><br>**Conclusion:**<br><br>While it's difficult to predict the future, YAMLscript has an interesting value<br>proposition. If it can build a strong community, identify compelling use cases,<br>and continuously innovate, it has a chance to succeed. However, it will need to<br>overcome the challenges mentioned above to gain significant traction in the<br>scripting language market.<br><br>What do you think about YAMLscript? Do you see any potential use cases or<br>advantages that could contribute to its success?</code></pre>
<p>Huh. They answered a question with a question…
Smart little (er, large) language model.</p>
<p>I'll have to answer them in another post!</p>
<h2>PS (Perl Strangelove???)</h2>
<p>I should mention that I'm giving a couple talks about YAMLScript at <a href="http://https://tprc.us/tprc-2024-las/">The Perl
and Raku</a> Conference in Las Vegas next
week.</p>
<p>Hope to see you there!!!</p>

    ]]>
      </content>
    </entry>
  
</feed>