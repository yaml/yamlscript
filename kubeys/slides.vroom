---- config
title: Simplify and Optimize Your YAML with YAMLScript
indent: 5

# auto_size: 1
height: 25
width: 87

vim_opts: '-u NONE'
skip: 0
top: 2
before: 1

vimrc: |
  source ./vimrc


---- center
Simplify and Optimize Your YAML with YAMLScript

Code is Data - Program in YAML

by Ingy döt Net

KubeCon
November 15, 2024
Salt Lake City

https://yamlscript.org/kubeys24


----
== Let's Sing About YAML!

* Who knows the song "99 Charts of YAML"?

* This YAMLScript program will lead us!
$ ys 99-charts-of-yaml.ys

* Sing along!
$ ys 99-charts-of-yaml.ys 3


----
== About this Tutorial

* https://yamlscript.org/kubeys24

* I'm not a Kubernetes expert
* Kubernetes has been in my world since 2015

* I'll want to teach you things about YAML and YAMLScript
* Including how to use YAMLScript with Kubernetes Tools

* I expect YOU to discover the true potential of YS+k8s
* And share your discoveries with me

* Together we can make Kubernetes + YAML awesome!
* Let's get started…

+Also: Vroom! Live Coding and a few T-shirts

Questions?


----
== Ingy döt Net

* Invented the YAML data language
  * w/ Clark and Oren; 2001 - 2009
  * YAML 1.0, 1.1, 1.2 specs

* Primary Maintainer of YAML
  * w/ Tina, Panto, Eemeli, Thom; 2015 - 2024
  * YAML 1.2.2 spec in 2021
  * YAML 1.3 spec process begins in 2025!

* Created YAMLScript
  * w/ Ven and others; 2023 - 2024
  * A complete programming language
  * Solves many of the problems with YAML
  * YAMLScript v0 stable in 2024

+Questions?


----
== Introducing YAMLScript (aka YS)

* YAMLScript is a new programming language
* Complete, functional, and fast
* YAML based syntax; clean and flexible
$ vim 99-charts-of-yaml.ys

* YAMLScript code transpiles to Clojure; a JVM Lisp
$ vim <( ys --compile 99-charts-of-yaml.ys )
* `ys` is written in Clojure but compiled to native code
  * Using GraalVM's `native-image` compiler
* YS requires no knowledge, use or installation of Java
$ ys -S -e '1 / 0'

* The command line interpreter is called `ys`
  * A single binary with no dependencies
  * Pronounced "wise" (the plural of "y" :)
    * kubeys (kubewise), helmys (helmwise)

+Questions?


----
== Who Knows of Rosetta Code?

* Rosetta Code is a wiki comparing solutions to:
  * 1300+ Tasks
  * 950+ Languages
  * Since 2007

* YAMLScript has some programs there
* https://rosettacode.org/wiki/Category:YAMLScript

* You can `git clone` all the code!
* https://github.com/acmeism/RosettaCodeData

+Questions?


----
== Programming in YAMLScript

$ yamllm 'What is FizzBuzz?'

* "yamllm" is a YS program that queries LLMs
$ YAMLLM_MODEL=list yamllm
$ yamllm 'FizzBuzz in YAMLScript'

$ vim fizzbuzz.ys
$ ys fizzbuzz.ys
$ ys fizzbuzz.ys 16

* How does FizzBuzz in YAMLScript compare to other languages?
* https://gist.github.com/ingydotnet/9ece4af186c6a6dcfd589c446dab9b38

* Comparison page generated by a YS program!

+Questions?


----
== Real Programming in YAMLScript

* FizzBuzz is a "toy" program
* The comparison generator is a "real" program

* Read/parse command line arguments
* Read environment variables and a config file
* Define and use functions and variables
* Read files from many directories
* Create and manipulate data structures
* Format Markdown output
* Download data files from the web
* Read and write JSON
* Post to the GitHub API (for Gists)

* All in YAMLScript!
$ vim `command -v ys-vs-rc`
$ ys-vs-rc task=FizzBuzz
$ bash `command -v ys-vs-rc` task=FizzBuzz

+Questions?


----
== Bash style -x trace debugging in YAMLScript

* In Bash you can use `set -x` to trace debug
  * Print each command (and args) before running it
* The ys `-x` flag does the same thing!
* AFAIK, this is unique to Bash and YAMLScript

* Let's see how it works
$ vim RosettaCodeData/Conf/lang.yaml
$ vim RosettaCodeData/bin/rcd-new-langs
$ RosettaCodeData/bin/rcd-new-langs
$ bash -x RosettaCodeData/bin/rcd-new-langs | cat

* Now let's see it in ys
$ ys -x `command -v ys-vs-rc` task=FizzBuzz | cat


----
== YAMLScript Improves YAML

* YAMLScript's Primary Goal: "Make YAML Better"
  * For All Users and Uses!!!
* Embeds cleanly into existing YAML files
* Batteries included
  * Standard libraries w/ 1000+ fns

* Import, Interpolate, Transform, Replicate, Merge, etc
* Pull in data from files, databases, web, APIs, etc
* Define functions, use external libraries, etc

* Works as a YAML loader for all FFI languages (soon)
* libyamlscript.so Bindings for 10 languages so far
  * including Go, Rust, Python, Ruby, NodeJS, Java


----
== YAMLScript Improves YAML

* All YAMLScript code IS (and MUST BE) be valid YAML
  * The YAMLScript compiler uses SnakeYAML parser
* All YAML config files are valid YAMLScript

* Thus, all JSON files are valid YAMLScript
  * All JSON is valid YAML, right?

* YS can improve Kubernetes, Helm, Kustomize, etc

+Questions?


----
== Learn YAMLScript at Exercism

* Exercism is a free online platform for learning
  * 74 programming languages
* Including YAMLScript!!
* https://exercism.org/tracks

* YS is the newest track (#74) launched in September
  * 60 programming exercises
* You can get a mentor (real person) to help you learn
* If you get good at YAMLScript, become a mentor!

+Questions?


----
== YAML and the Merge Key -- a tale from "Copilot's Fables"

Once upon a time, in the land of YAML
there was a key named "<<" (Lessy Less).
It was called the "merge key".
It was the only function in YAML 1.1.

It was used to merge mappings,
and it was very powerful…


----
== YAML's << Merge Key

Who here has used the << YAML merge key?

YAML was designed to be a "programming language agnostic data
serialization language", but the whole process of inventing YAML
was not very rigorous.
Clark suggested the merge key, and we just went with it.

In YAML 1.2 (2009) we removed the merge key from the spec but
many YAML implementations still support it.

YAMLScript supports it too, but…

* The whole point of YAMLScript is to add functions to YAML
* The YS `merge` function is just one of over 1000 functions

Let's see how YAMLScript changes things…


----
== Merging with <<

$ vim merge-1.ys
$ ys -Y merge-1.ys

* This works, but we don't want the 'defaults' pair
  * That was just our "data source"

* We would need to remove the extra data somehow
$ ys -Y merge-1.ys -e '.dissoc("defaults")'


----
== Refactoring << with YAMLScript

$ vim merge-2.ys
$ ys -Y merge-2.ys

$ vim merge-3.ys
$ ys -Y merge-3.ys

$ vim merge-4.ys
$ ys -Y merge-4.ys

$ vim merge-5.ys
$ ys -Y merge-5.ys


----
== Replacing << with the `merge` function

$ vim merge-6.ys
$ ys -Y merge-6.ys

$ vim merge-7.ys
$ ys -Y merge-7.ys

$ vim merge-8.ys
$ ys -Y merge-8.ys

* Let's compare where we started with where we ended up
$ vim -O merge-1.ys merge-9.ys

+Questions?


----
== YAMLScript Modes

* Understanding YS Modes is Foundational
* Consider this YAMLScript program:

  say: hello

* Are 'say' and 'hello' data or code?
  * ie Strings or variables?

* YAMLScript programs need them to be strings sometimes
  * And variables other times

* Each node in a YAMLScript program has a "mode"
* Learning to switch modes is key to YS mastery


----
== YAMLScript Modes

* YAMLScript has 3 modes (semantics for a node)

  * Bare mode - All nodes are normal YAML (1.2 Core Schema)
    * No code evaluation will ever occur
    * Thus your YAML files are always valid YAMLScript

  * Code mode - Node is a code expression
    * Can switch to other modes

  * Data mode - Node is YAML data
    * Can switch to other modes


----
== YAMLScript Document Mode Tags

* Existing YAML files are valid YAMLScript in Bare Mode
* No code evaluation will occur
* YS will interpret them like any other YAML 1.2 loader

* To use YS logic in YAML the document must be tagged:
  * `!yamlscript/v0`      - Start in code mode
  * `!yamlscript/v0:`     - Start in data mode
  * `!yamlscript/v0/code` - Code mode (explicit)
  * `!yamlscript/v0/data` - Data mode (explicit)
  * `!yamlscript/v0/bare` - Bare mode (explicit)
  * `#!/usr/bin/env ys-0` - Shebang for YS scripts


----
== Mode switching tags:

* `!`     - Toggle code and data modes
* `::`    - Sugar for `: !` in mapping pairs
* `!code` - Switch to code mode
* `!data` - Switch to data mode
* `!bare` - Switch to bare mode

$ vim modes.ys
* ys returns the last document value by default
$ ys -Y modes.ys
$ ys -c modes.ys

+Questions?


----
== Setting the Mode in YAMLScript One-Liners

* I love one-liners in all languages
* YS needs `!yamlscript/v0` to evaluate any code
* For simplicity `-e` adds the `!yamlscript/v0` tag
  * ie Puts you in code mode

* You can override that with `-m` (b=bare, c=code, d=data)

$ ys -e 'say: inc(41)'
$ ys -mc -e 'say: inc(41)'
$ ys -mb -le 'say: inc(41)'   # -l is --load
$ ys -md -le 'say:: inc(41)'  # else nothing happens
$ ys -md -Je 'say:: inc(41)'  # -J is --load w/ pretty print JSON
$ ys -md -Ye 'say:: inc(41)'  # -J is --load w/ YAML output

+Questions?


----
== Dot Chains in YAMLScript One-Liners

$ ys -e 'say: ENV.USER.uc1().str(" wants to talk about YAML!")'

$ ys -e 'say: ENV.USER:uc1.str(" wants to talk about YAML!")'

$ ys -e 'say: ENV.USER:uc1 + " wants to talk about YAML!"'

$ ys -e 'say: "YAML wants to talk about " + ENV.USER:uc1 + "!"'

$ ys -e 'say: -"YAML wants to talk about " + ENV.USER:uc1 + "!"'

$ ys -e 'say: "YS $VERSION wants to talk about $(ENV.USER:uc1)!"'

+Questions?


----
== Refactoring large messy YAML configs

* Calva is a Clojure IDE for VS Code
* YAMLScript is written entirely using Calva
* Peter Strömberg is the creator of Calva
  * Without Peter, YAMLScript might not have happened!

* Last Spring, Calva had a very sad .circleci/config.yml :(
  * https://github.com/BetterThanTomorrow/calva/blob/9483828/.circleci/config.yml
  * 1 file w/ 636 lines of repetitive, hard to maintain YAML
    * with 9 embedded (unlintable) Bash scripts YAML strings


----
== Refactoring Calva's CircleCI Config

* I refactored it to YAMLScript
  * 37 small files
    * Main config.ys is 40 lines
    * 21 .yaml files
    * 9 bash files (now lintable)
    * A helper.ys file of shared functions
    * A Makefile to build the config.yml file for CircleCI
  * Added shellcheck lint tests for the Bash files
  * 'make build' creates the CircleCI config.yml file
    * Exactly the same as before,
      * Except for the Bash bugs that were fixed!

$ vim calva/.circleci

+Questions?


----
== How to Refactor any Large YAML Config File to YS

* Someday CircleCI might support YAMLScript
  * And GitHub Actions, Ansible, and Kubernetes :)
* For now you can do what I did with Calva
* Copy the big file.yaml to file.ys
* Break up the big file into smaller files
* Use YAMLScript to load them back in
* Use a function library for shared code
* DRY up the YAML with functions

* Run `ys -Y foobar.ys > foobar.yml` to build
  whenever you change things
* Use a Makefile to automate the build process

* Here's a simple Makefile template
  $ vim sample/Makefile

+Questions?


----
== Using YAMLScript in Helm Charts

* Where would YS hook into Helm YAML flow?
* Chart.yaml and values.yaml are YAML already
* Templates are YAML Go templates (not valid YAML)

$ helm create chart-a
$ tree chart-a

* Test the validity of the YAML files with ys
$ ys -Y chart-a/Chart.yaml
$ ys -Y chart-a/values.yaml
$ ys -Y chart-a/templates/deployment.yaml

+Questions?


----
== Using YAMLScript in Helm Charts

The rendered output of `helm template` is YAML

$ helm template chart-a | ys -Y -s - | tee before.yaml | less

* So we need to do our YS magic post-renderer ! :-)

+Questions?

$ make chart-clean   # In case of emergency, break glass


----
== YAMLScript in templates?

* What happens if we put YAMLScript code in templates?

$ vim -O chart-a/templates/{service{,account},deployment}.yaml
$ helm template chart-a | less

$ helm template chart-a | ys -Ys - | tee after.yaml | less
$ diff -u before.yaml after.yaml && echo "No differences!!"

+Questions?


----
== YAMLScript in templates?

* Lets use some YAMLScript in the templates

$ cp deployment-ys.yaml chart-a/templates/deployment.yaml
$ cp helpers.ys chart-a/templates/helpers.ys
$ vim -O chart-a/templates/{deployment.yaml,helpers.ys}

$ (cd chart-a; helm template . | YSPATH=templates ys -Ys -)|tee after.yaml|less
$ diff -u before.yaml after.yaml && echo "No differences!!"

+Questions?


----
== Introducing HelmYS

* HelmYS is a new project that lets you use YAMLScript in Helm templates
* https://github.com/kubeys/helmys

* You can use YAMLScript in Helm charts today!

* You can mix YS with Go template syntax or use YS exclusively
  * YS "templating" is cleaner than Go templates
  * YS is more powerful than Go templates / Sprig

* If you use YS exclusively, your templates are valid YAML
  * You can use YAML tools like `yamllint` on them

* Here's a side by side comparison of YS and Go in a Helm chart
* https://gist.github.com/ingydotnet/ff0638edf1bcb53c45161dce2d777f74


----
== Using HelmYS

$ git clone https://github.com/kubeys/helmys
$ make -C helmys test | cat

* Let's do this by hand a bit

$ helm create chart-ys
$ cp helmys/templates/* chart-ys/templates/
$ cp templates-ys/* chart-ys/templates/

$ helm install name-$RANDOM chart-ys --post-renderer helmys
$ vim -O helmys-{in,thru,out}put.yaml

$ vim -O chart-ys/templates/serviceaccount.yaml ys-test-chart/templates/serviceaccount.yaml

+Questions?


----
== Status of HelmYS

* HelmYS is a proof of concept
  * Created last week
  * Try it out and let me know what you think
  * Should be ready to use in Helm 3 by Christmas!

* Showed it to the Helm 4 team last week
  * They seem to like it
  * I'm working with them to make it a first class citizen in Helm 4
    * Go templates are not going away
    * But now there's an alternative
  * Haven't met anyone here so far who loves Go templates :)
    * Including the Helm 4 team…

+Questions?


----
== YAMLScript's Built-in Standard Libraries

* clojure::core   - ~700 base functions
* clojure::string - String processing functions
* clojure::math   - Math functions

* ys::std     - YAMLScript standard library
* ys::yaml    - YAML functions
* ys::json    - JSON functions
* ys::taptest - TAP Test functions
* ys::clj     - Clojure functions shadowed by ys::std

* babashka::fs - Filesystem functions
* babashka::http-client - HTTP functions
* babashka::process - IPC (shell commands) functions

+Questions?


----
== Accessing External Data in Data Mode

A superpower of YAMLScript is the ability to access external data

$ vim externals.ys

$ ys -Y externals.ys
$ ys -J externals.ys
$ ys -l externals.ys
$ ys -l externals.ys | jq

+Questions?


----
== Compiling YAMLScript programs to binary executables

* You can compile YAMLScript programs to native code
* ys --binary program.ys
* Must have a main function
* Compilation is done with GraalVM's native-image
* The resulting binary is standalone
* Compilation is slow, but the binary is fast
* The minimum binary size is ~13MB

$ ys --binary 99-charts-of-yaml.ys
$ time ./99-charts-of-yaml 3
$ time ys 99-charts-of-yaml.ys 3

+Questions?


----
== Installing YAMLScript

$ curl -s https://yamlscript.org/install | bash
  * Install ~/.local/bin/ys and ~/.local/lib/libyamlscript.so
  * curl -s https://yamlscript.org/install | BIN=1 VERSION=… PREFIX=… bash

* brew install yaml/yamlscript/ys
* https://yamlscript.org/install

+Questions?


----
== Replace your YAML Loader with YAMLScript

* YAMLScript works a full YAML 1.2 loader
* For all FFI languages
* libyamlscript.so Bindings for 10 languages so far:
  * https://rosettacode.org/wiki/Category:YAMLScript
* Works exactly the same in every language
* No need to learn a new API for each language
* Bug fixes and features are shared across all languages

+Questions?


----
== Replacing PyYAML with YAMLScript

$ vim invoice.yaml

$ vim load-pyyaml.py
$ python3 load-pyyaml.py invoice.yaml

$ vim load-yamlscript.py
$ python3 load-yamlscript.py invoice.yaml

$ diff -u <(python3 load-pyyaml.py invoice.yaml) <(python3 load-yamlscript.py invoice.yaml) && echo "No differences!!"

* You can do the same thing in any other language with a YS binding

+Questions?


---- skip
== YAMLScript and Kustomize

$ vim kustomize
$ make -C kustomize test
* Makefile .ys to .yaml


----
== How YAMLScript (& YAML Loaders) Work

* The YAML deserialization process is called "loading"
* It's a multi-step process
  * Read - data into code points
  * Lex - code points into tokens
  * Parse - tokens into events (structs)
  * Compose - events into nodes (tree)
  * Resolve - tags for each node
  * Construct - tagged nodes into native objects

* YAML serialization is called "dumping"
  * Similar stack of steps in reverse

+Questions?


----
== YAMLScript's Compiler is a fancy YAML Loader!

* We can see each step with the `-d` flag
$ ys -cd rot-13.ys

* YAMLScript loads plain YAML data files
  * Compiles them to Clojure code
  * Which is just a data structure
  * Prints the evaluation of that data structure
  * Formatting it to JSON or YAML for output

* Anchors and aliases compile to function calls!
$ ys -U -mb -ce 'a: &x 123' -e 'b: [1, 2, *x]'
$ ys -U -mb -l -e 'a: &x 123' -e 'b: [1, 2, *x]'
$ ys -U -mb -Ye 'a: &x 123' -e 'b: [1, 2, *x]'
$ ys -U -mb -pe 'a: &x 123' -e 'b: [1, 2, *x]'

+Questions?


----
== Learn Lisp and Clojure in One Minute

* First let's take a minute to learn Clojure :)

$ vim even-nums.clj

$ bb even-nums.clj
$ bb even-nums.clj 25
$ bb even-nums.clj 21 30
$ bb even-nums.clj 30 21

* Now you know Clojure and Lisp

+Questions?


----
== Learning YAMLScript in Reverse

* Since YAMLScript compiles to Clojure…

$ ys -ce 'for i (1 .. 10): say(i)'

* A great way to teach YAMLScript is to
  port Clojure code to it.

* Let's convert even-nums.clj to YAMLScript

$ vim even-nums-*.ys

$ vim -O even-nums.clj even-nums-06.ys

+Questions?


----
== Web Resources

* YAMLScript Website:       https://yamlscript.org
* YAMLScript Documentation: https://yamlscript.org/doc
* YAMLScript Blog:          https://yamlscript.org/blog
* YAMLScript Exercism:      https://exercism.org/tracks/yamlscript
* YAMLScript GitHub:        https://github.com/yaml/yamlscript
  * Mono repo with all the code, bindings, docs, blog, talks
* YAMLScript Releases:      https://github.com/yaml/yamlscript/releases


----
== What's Next for YAMLScript?

* YAMLScript v0 will be declared stable this year
* No breaking changes will be made to YAMLScript v0
* All code written to v0 will always work

* Expect more YS blogging after today!
  * https://yamlscript.org/blog
* Looking forward to AoC in YAMLScript this year

* Work with the Helm 4 development team
  * Make YAMLScript a first class citizen in Helm
* Work on YAMLScript v1 will begin in 2025

+Questions?


----
== YAMLScript Roadmap

* Still lots to do to make YAMLScript first class

* Improve Documentation!!
* Integration Guides for Major YAML Tools
  * Kubernetes: Helm, Kustomize, etc
  * CI/CD: GitHub Actions, CircleCI, etc
* YAMLScript LSP Server
* Windows Support
* Capabilities support
* Integrated Schema support

* So many things!
  * https://github.com/orgs/yaml/projects/6/views/1

+Questions?


----
== What's Next for YAML?

* YAML 1.3 specification work will begin in 2025
* First normative changes to YAML since 2009!
* I hope to share more about this at KubeCon London 2025

+Questions?


----
== Contributing to YAMLScript

* I'm personally inviting you to help with YAMLScript

* Still a young language
* Features come from experience
* If you expect something to work, it probably should!
* File issues and help YAMLScript get better

* The YS compiler and runtime are not that complicated
* Pull requests welcome
* Reach out if you need help getting started

+Questions?


----
== Funding YAMLScript

* In 2023 I realized the importance of YAMLScript
  * And that it could be realized in < 1 year
* I took all of 2024 off to work on YAMLScript
* YAMLScript is now "real", but the todo list is long

* If you or your company can help fund YAMLScript
  * Please reach out to me for details
  * See: https://yamlscript.org/funding
  * Hire me for YAML/YAMLScript consulting, training,
    speaking engagements, etc

* Have a direct influence on what gets done next!

+Questions?


----
== The End

* Thank you for attending!
* Info at https://yamlscript.org/kubeys24
  * Slides are there
  * My contact info is there
* Reach out to me about any of this!!

  Let's Talk About YAML!

$ Questions?
