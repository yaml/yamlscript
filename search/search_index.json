{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"YS \u2014 YAML Done Wisely","text":"YS (say \"wise\") is the best way to work with YAML <p>  Learn More About YS</p> <ul> <li> <p> Take Full Control of Your YAML</p> <ul> <li>YS is always 100% valid YAML\u00a0 <ul> <li>Lint, Query, Validate w/ existing tools</li> </ul> </li> <li>Created by YAML inventor/maintainer</li> <li>YS has YAML Loaders for all languages   Same Capabilities, Features, Bugs and Fixes</li> <li>A Common &amp; Consistent YAML Experience   (with or without using YS logic features)</li> </ul> </li> <li> <p> YAML Made Functional</p> <pre><code>!YS-v0:\nvars =: load('vars.yaml')\njson-file =: 'data.json'\n\na normal key: and normal value\nname:: ENV.USER:uc1\ncolor:: vars.colors:shuffle.0\nsome stuff::\n  curl(\"https://example.com/$json-file\")\n    .stuff.take(rand-int(5).++)\n:when ENV.DEBUG_VARS::\n  debug:: vars\n</code></pre> </li> <li> <p> Simplify your existing YAML</p> <ul> <li>Refactor, Deduplicate, DRY</li> <li>Over 1000 standard functions built in</li> <li>Dozens of built in libraries</li> <li>External libraries as well</li> <li>Define your own functions and libraries</li> <li>Limit YS capabilities to your exact needs</li> </ul> </li> <li> <p> Plays Well with DevOps Tools</p> <ul> <li>HelmYS for Kubernetes Helm charts</li> <li>CI/CD, Docker, Ansible, etc.</li> <li>Your existing YAML files are valid YS!</li> <li>Take them to the next level</li> </ul> </li> <li> <p> Import, Transform, Interpolate and More</p> <ul> <li>Load YS in your programs</li> <li>Script Automation with YS</li> <li>Query and Transform YAML data</li> <li>Compile YS to binary executables</li> </ul> </li> <li> <p> Learn YS Today!</p> <ul> <li>YS Exercism Track\u00a0 </li> <li>KubeCon 2024 YS Tutorial\u00a0 </li> <li>YS on Rosetta Code\u00a0 </li> <li>YS Documentation\u00a0 </li> </ul> </li> </ul> <ul> <li> <p> \"Zero to YS in 10 seconds!\"</p> <p><pre><code>curl -s https://getys.org/ys | bash\n# Adjust PATH if asked to.\nys --help\nys -e 'say: \"Hello, World. I am $(ENV.USER).\"'\n</code></pre>  Installing YS</p> </li> </ul>"},{"location":"about-website/","title":"About This Website","text":"<p>This website was built using the (OMG it's the best site generator in the universe!!!) Material for MkDocs\u00a0  theme for the MkDocs\u00a0  static site generator, and many of its plugins.</p>"},{"location":"about-website/#ys-enhancement","title":"YS Enhancement","text":"<p>While the Material for MkDocs theme is already feature-rich, we improved things a bit more by using YS.</p> <p>We also use a Makefile\u00a0  to automate all the MkDocs build steps like installing Python packages, creating and enabling a virtual environment, building the site, and serving it both locally and on GitHub Pages.</p> <p>All you need to do in the YS mono-repo's <code>www</code> directory\u00a0  is run these <code>make</code> commands:</p> <ul> <li><code>make serve</code> \u2014 Serve the site locally (after doing any necessary setup)</li> <li><code>make publish website=stage</code> \u2014 Publish the site to    https://stage.yamlscript.org\u00a0 </li> <li><code>make publish website=live</code> \u2014 Publish the site to    https://www.yamlscript.org\u00a0 </li> <li><code>make clean</code> \u2014 Remove the generated files</li> <li><code>make realclean</code> \u2014 Remove the generated files and the virtual environment</li> </ul> <p>So simple!</p>"},{"location":"about-website/#generating-the-mkdocsyml","title":"Generating the <code>mkdocs.yml</code>","text":"<p>MkDocs uses a <code>mkdocs.yml</code> YAML file for its configuration. As that file grew in size, we found it easier to manage by splitting it into multiple files, and using the <code>config.ys</code> file to include them.</p> <ul> <li><code>config.ys</code>    \u2014 The main configuration file</li> <li><code>config/*.yaml</code>    \u2014 The included configuration files</li> </ul>"},{"location":"about-website/#markdownys","title":"MarkdownYS","text":"<p>Certain pages (like library method documentation) are annoying to write because they require a lot of repeated boilerplate. We made a tool called <code>mdys</code> that lets you write YAML data inside of Markdown and specify a YS function to turn it into Markdown.</p> <p>If you have the documentation for 100 methods and later you want to change the formatting for them, you only need to tweak the YS function.</p> <p>A good example of this is the YS Standard Library documentation. Click on the \"Edit this page\" link to see the source.</p> <p>The YAML data starts with:</p> <pre><code>```mdys:stdlib\nString functions:\n- base64-decode(Str) Str: Decode a base64 string\n</code></pre> <p>This YAML gets loaded into an object and passed to the <code>mdys-stdlib</code> </p> <p>Note</p> <p>The <code>Makefile</code> takes care of watching any <code>.mdys</code> files and converting them to <code>.md</code> files whenever they change (when serving the site locally).</p> <p>Working with MarkdownYS in MkDocs is as easy as working with Markdown.</p>"},{"location":"about/","title":"About YS","text":"<p>YS (aka YAMLScript) is a functional programming language that uses YAML\u00a0  as its syntax. Its primary intent is to provide YAML with the capabilities of a general purpose programming language for all its users and use cases. YS does this in a seamless fashion, that feels like a very natural extension of the YAML you know and use today.</p> <p>All YS files are guaranteed to be valid YAML files</p> <p>Furthermore, all<sup>1</sup> YAML files (and thus all JSON files) are valid YS, and YS will load them as they were intended.</p> <p>YS enables an extensive amount of programming capabilities that can be used at any level and to any degree. The more commonly needed capabilities include:</p> <ul> <li>Loading data from external sources: files, databases, web, APIs, etc.</li> <li>Assigning values to variables, and using them in expressions</li> <li>Interpolating variables into strings</li> <li>Data path queries, conditionals, loops, transformations, etc</li> <li>Defining your own functions and libraries</li> <li>Builtin libraries with over 1000 functions for all common tasks</li> <li>Using external libraries and dependencies</li> <li>Making system calls, and accessing environment variables</li> </ul> <p>Here's file that demonstrates some of the capabilities of YS: <pre><code>!YS-v0:  # Allow functional capabilities in this YAML document\n\n# Define a local function inline:\n::\n  defn greet(name='World'): |\n    Hi, I'm $name,\n    Nice to meet you!\n\nvars =: load('vars.yaml')     # Load another YAML file\n\n# A YAML mapping:\nkey: value                    # A normal YAML key value pair of strings\n\n# Get a random name and anchor it:\nname:: &amp;name vars\n       .names.rand-nth()\n\n# System call to get the date:\ndate:: \"Today is\n        $(sh('date')\n        .out:chomp)\"\nme =: ENV.USER                # Assign USER env var to 'me' var\nuser:: uc(me)                 # Uppercase me\n:when (rand(10) ** 2) &gt; 1::   # Add mapping pair conditionally\n  maybe: this pair\n\n# Various ways to call a function:\ngreeting 1:: greet()\ngreeting 2:: lc(me):uc1:greet\ngreeting 3::\n  greet: -'&lt;' + *name + '&gt;'\n</code></pre></p> <p>This file goes a bit overboard from what you would typically see in a YAML file using YS, but it's just to show off the capabilities listed above.</p> <p>Use the <code>ys</code> command to evaluate the file to YAML or JSON: <pre><code>$ ys -Y file.yaml\nkey: value\nname: Alice\ndate: Today is Thu Feb 13 11:49:09 AM EST 2025\nuser: INGY\nmaybe: this pair\ngreeting 1: |\n  Hi, I'm World,\n  Nice to meet you!\ngreeting 2: |\n  Hi, I'm Ingy,\n  Nice to meet you!\ngreeting 3: |\n  Hi, I'm &lt;Alice&gt;,\n  Nice to meet you!\n</code></pre></p> <p>YS was created by one of the original YAML authors, Ingy d\u00f6t Net. It adheres to the YAML 1.2 specification\u00a0  and is implemented very much as the spec describes. The YS compiler (YS compiles to the Clojure Lisp for subsequent evaluation) is implemented as a YAML loader.</p> <p>Clojure\u00a0  is a JVM based functional language that known for its concise, powerful syntax. YS offers you these powers but without the need for Lisp syntax or a JVM.</p> <p>YS is compiled to the <code>ys</code> standalone native binary executable, and to the <code>libyamlscript</code> shared library, for common operating systems / architectures\u00a0 .</p> <p>This shared library can be bound to almost all modern  programming languages as a YAML Loader module. It currently ships to these 10 languages:</p> <ul> <li>Clojure\u00a0 </li> <li>Go\u00a0 </li> <li>Java\u00a0 </li> <li>Julia\u00a0 </li> <li>NodeJS\u00a0 </li> <li>Perl\u00a0 </li> <li>Python\u00a0 </li> <li>Raku\u00a0 </li> <li>Ruby\u00a0 </li> <li>Rust\u00a0 </li> </ul> <p>with many more on the way.</p> <ol> <li> <p>There are ways to write YAML that is not valid YS, but they are highly unlikely to be seen in places where YAML is used as a configuration language. If a YAML file can be converted to JSON and then back to YAML, without changing semantics, then it is valid YS.\u00a0\u21a9</p> </li> </ol>"},{"location":"cicd/","title":"YS for CI/CD","text":"<p>YS is a great language for CI/CD pipelines.</p> <p>Regardless of what CI/CD system you are using, you can use YS to make those configuration files much more maintainable and powerful.</p>"},{"location":"cicd/#the-problem","title":"The Problem","text":"<p>CI/CD pipelines are often written in YAML but YAML is not a programming language. This means that you can't do things like:</p> <ul> <li>Load data from other files, databases, APIs, URLs, etc</li> <li>Query data structures to get the data you need</li> <li>Access environment variables</li> <li>Assign variables</li> <li>Reference other parts of the YAML file</li> <li>Interpolate variables and function calls into strings</li> <li>Use loops and conditional logic</li> <li>Transform data structures using 100s of built-in functions</li> <li>Define and call your own functions</li> <li>Use external libraries</li> <li>Run shell commands</li> </ul>"},{"location":"cicd/#the-solution","title":"The Solution","text":"<p>YS can do all of these things, and more, and it does it all in a way that is completely compatible with YAML. You can start with your existing YAML files and add YS capabilities to them as much or as little as you need.</p>"},{"location":"cicd/#the-next-problem","title":"The Next Problem","text":"<p>YS is a new language, and your CI/CD system probably doesn't support it out of the box.</p> <p>The YS team hopes that over time YS YAML loaders will become the preferred way to load YAML config file in almost any situation, including CI/CD systems.</p>"},{"location":"cicd/#the-general-solution","title":"The General Solution","text":"<p>Until then, you can use YS to generate the YAML files that your CI/CD system expects.</p> <p>A typical way to do this is to copy your existing YAML file, say <code>pipeline.yaml</code>, and then run this command:</p> <pre><code>ys -Y pipeline.ys &gt; pipeline.yaml\n</code></pre> <p>This will generate a new <code>pipeline.yaml</code> file that should be semantically equivalent to the original <code>pipeline.yaml</code> file. The comments and formatting will be different, but the data should be the same.</p> <p>Next you'll want to add that command to your CI/CD system so that it runs every time you make a change to your <code>pipeline.ys</code> file. This could be as simple as adding a Makefile (see below) with a Git hook, but that's up to you.</p>"},{"location":"cicd/#first-time-validation","title":"First time validation","text":"<p>After converting your <code>pipeline.yaml</code> file to <code>pipeline.ys</code> the first time, you should validate that the conversion is correct.</p> <p>One way to do this is by running:</p> <pre><code>$ ys -pe 'ARGS.0:read:yaml/load == ARGS.1:read:yaml/load' -- \\\n    &lt;(git show HEAD:pipeline.yaml) pipeline.yaml\ntrue\n</code></pre> <p>If the output is <code>true</code>, then the conversion is correct. If the output is <code>false</code>, then you'll need to investigate why.</p> <p>After the first time, you can refactor your <code>pipeline.ys</code> file with YS any way you like. The resulting <code>pipeline.yaml</code> file should never change at all. This makes refactoring so much easier, because you will know immediately if you broke something. (if the <code>pipeline.yaml</code> file is modified)</p>"},{"location":"cicd/#using-a-makefile","title":"Using a Makefile","text":"<p>When you use YS to generate your YAML files, you'll only be editing the YS files but you need to make sure that the YAML files are always up to date.</p> <p>There are many ways to do this, but one simple way is to use a Makefile.</p> <p>Here is an example Makefile that will generate any files in your project that end in <code>.ys</code> from the corresponding <code>.yaml</code> file:</p> <pre><code>SHELL := bash\n\nYS_VERSION := 0.1.96\nYS := /tmp/bin/ys-$(YS_VERSION)\nYS_FILES := $(shell find . -name '*.ys')\nYAML_FILES := $(YS_FILES:.ys=.yaml)\n\nupdate: $(YAML_FILES)\n\ntest: update\n        @git diff --quiet --exit-code -- $(YAML_FILES) || { \\\n          git diff -- $(YAML_FILES); \\\n          echo \"ERROR: YAML files are out of date\"; \\\n          echo \"Run 'make update' to update them\"; \\\n          exit 1; \\\n          }\n        @echo \"PASS: All YAML files are up to date\"\n\n%.yaml: %.ys $(YS) Makefile\n        @echo \"# GENERATED FILE. EDIT '$&lt;' INSTEAD.\" &gt; $@.tmp\n        $(YS) -Y $&lt; &gt;&gt; $@.tmp\n        mv $@.tmp $@\n\n$(YS):\n        curl -s https://getys.org/ys | \\\n          PREFIX=/tmp VERSION=$(YS_VERSION) QUIET=1 bash \\\n          &gt; /dev/null\n\n.PHONY: update test\n</code></pre> <p>Every time you change a <code>.ys</code> file, you can run <code>make test</code> to make sure that the corresponding <code>.yaml</code> file is up to date. You'll see a diff of the changes if there are any. If you are refactoring your <code>.ys</code> file, you can run <code>make update</code> to make sure nothing has changed in the <code>.yaml</code> files.</p> <p>Note</p> <p>Notice how the Makefile adds a comment to remind you that the <code>.yaml</code> files are generated and should not be edited directly.</p> <p>This Makefile even downloads the <code>ys</code> binary for you, so you don't need to have it pre-installed on your system. In fact it installs a specific version of <code>ys</code> so you can be assured that the generated YAML files are always the same.</p>"},{"location":"cicd/#using-a-git-hook","title":"Using a Git hook","text":"<p>You can add a Git pre-push hook to make sure that the <code>.yaml</code> files are up to date before you push your changes.</p> <p>If the updated <code>.yaml</code> files have changed, the commit will be aborted and you'll need to commit the changes before you can push.</p>"},{"location":"circleci/","title":"YS and CircleCI","text":"<p>Calva\u00a0  is an integrated development environment for enjoyable and productive Clojure\u00a0  and ClojureScript\u00a0  programming in Visual Studio Code\u00a0 .</p> <p>Calva uses CircleCI\u00a0  for continuous integration and deployment. CircleCI requires a <code>.circleci/config.yml</code> file to define the build and deployment steps.</p> <p>YS  Calva</p> <p>Nearly all of the YS Project's\u00a0  code was written using Calva. It's by far the best way to develop software with Clojure.</p> <p>Calva's <code>config.yml</code> file had grown to be quite large and complex, but after refactoring it to use YS\u00a0 , it is now much more maintainable and easier to work with.</p> <p>What started out as one big 636 line YAML file\u00a0  with lots of embedded Bash scripts, was refactored into nearly 40 small files\u00a0  each with a clear and specific purpose.</p> <p>You can see the how the migration was made over 30 single purpose commits in this Pull Request\u00a0 .</p> <p>Now changes are made in a much more maintainable way, and the CircleCI required <code>config.yml</code> file is generated from the YS files using a simple <code>ys</code> command:</p> <pre><code>$ ys -Y config.ys &gt; config.yml\n</code></pre> <p>As a bonus, linting was performed on the Bash scripts (now in their own files) and several small issues were found and fixed.</p> <p>This technique is a general strategy for refactoring large YAML files into smaller, more maintainable ones, regardless of whether or not the target system uses YS natively yet.</p>"},{"location":"contrib-roadmap/","title":"The YS Road Map","text":"<p>While the YS language is quite capable today for both extending YAML files and general programming, there is still a seemingly endless list of things that should be done to improve the language, its libraries, and full integration with with the world of data and code.</p>"},{"location":"contrib-roadmap/#ys-language-bindings","title":"YS Language Bindings","text":"<p>YS YAML loaders have major advantages over the existing YAML loaders:</p> <ul> <li>Same API and capabilities regardless of the language.</li> <li>T </li> <li>Highly configurable.</li> </ul>"},{"location":"contrib-rules/","title":"Contribution Guidelines","text":""},{"location":"contrib-rules/#please-and-thank-you","title":"Please and Thank You","text":"<p>YS is an Open Source project, and we need your help!</p>"},{"location":"contrib-website/","title":"Website Contribution","text":""},{"location":"contrib-website/#please-and-thank-you","title":"Please and Thank You","text":"<p>The YS website needs your help! Especially with the documentation.</p> <p>Everyone is welcome to contribute to the website, and your contributions are greatly appreciated.</p>"},{"location":"contrib-website/#about-this-website","title":"About this Website","text":"<p>Read This Page to learn how this website combined Material for MkDocs with YS to make a site that is super easy to contribute to.</p>"},{"location":"contrib-website/#how-to-contribute","title":"How to Contribute","text":"<p>The yamlscript.org website is designed to be very easy to contribute to.</p> <p>Every single page on the site is created from a Markdown file in the YS repository\u00a0 . This repo is a mono-repo, meaning that all parts of the YS project is in there.</p> <p>Also, every page in the site (except the front page) has a \"view source\" button and an \"edit this page\" button. These buttons will take you to the source file for that page.</p> <p>The \"edit\" button will drop you into the GitHub editor for that page. You can make your changes and then submit a pull request.</p> <p>This is the easiest way to contribute to the site for small changes.</p>"},{"location":"contrib-website/#bigger-changes","title":"Bigger Changes","text":"<p>If you want to add new pages of content, or make more significant changes, you should clone the repo and work on it locally. When you are ready to submit your changes, you can create a pull request.</p> <p>Testing your changes locally is incredibly easy. To get started, run thesee commands:</p> <pre><code>$ git clone https://github.com/yaml/yamlscript\n$ cd yamlscript\n$ git checkout website  # PRs should be made against the \"website\" branch\n$ cd www\n$ make serve\n</code></pre> <p>The <code>make serve</code> command will install all the dependencies in the <code>./.venv/</code> and in <code>/tmp/yamlscript/</code> and then start a local webserver at http://localhost:8000\u00a0 .</p> <p>It will also start a watcher that will automatically rebuild the site when you make changes to the source files. These  changes will be visible in your browser immediately.</p>"},{"location":"contrib-website/#important-source-files","title":"Important Source Files","text":"<p>The YS website\u00a0  is built using the Material for MkDocs\u00a0  statis site framework, which is quite incredible in terms of what it can do (and easily).</p> <p>Note</p> <p>You don't need to know anything about MkDocs to make changes to the site, but if you want to add plugins or make theme customizations, you will need to learn a bit.</p> <p>The prerequisites for building the site are very minimal:</p> <ul> <li>Linux or MacOS</li> <li>Python 3.6+</li> <li>Python <code>pip</code></li> <li>GNU <code>make</code></li> <li><code>curl</code></li> <li><code>bash</code></li> </ul> <p>Note</p> <p>The <code>bash</code> command just needs to be found in your <code>PATH</code>; it doesn't need to be your interactive shell. In other words, you can do development work on this site from from a terminal using <code>zsh</code>, <code>fish</code>, or whatever shell you prefer.</p> <p>The most important files for the website are:</p> <ul> <li><code>www/Makefile</code> - This <code>Makefile</code> is used to handle all the various   orchestration tasks you may need to do.</li> <li><code>www/config.ys</code> - The main configuration file for the site. Written in YS.</li> <li><code>www/config/</code> - The YAML config files for various aspects of the site.</li> <li><code>www/src/</code> - The source files for the site.</li> <li><code>doc/</code> - The source files for the documentation.</li> <li><code>blog/</code> - The source files for the blog.</li> <li><code>www/requirements.txt</code> - The Python requirements for the site.</li> <li><code>www/theme/**</code> - The theme override files for the site.</li> </ul>"},{"location":"contrib-website/#ask-us-for-help","title":"Ask Us for Help","text":"<p>If you need help with anything, start a discussion here\u00a0 .</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":"How do you pronounce YS? <p>We like to say \"wise\" since its how you might pronounce the plural of \"Y\".  You can also say \"why-ess\" for \"Y S\" or the long name for YS: \"YAMLScript\" (\"YAML (rhymes with camel) Script\").</p> <p>YS has many side projects like HelmYS (\"helm-wise\") or SchemaYS (\"schema-wise\").</p> Is YS really YAML? <p>Yes. Empirically. The YS compiler has 7 stages (phases) to transform YS (YAML) into Clojure. The first phase is call <code>parse</code> and it currently uses the SnakeYAML Engine parser\u00a0  code for this process.</p> Who created YS? <p>YS was created by Ingy d\u00f6t Net, a founding creator and current maintainer of the YAML Data Language\u00a0 .</p> What is the preferred file extension for YS files? <p>The preferred file extension for YS files is <code>.ys</code>, but you can use <code>.yaml</code> or <code>.yml</code> if you prefer for most files. The <code>ys</code> command line tool doesn't look at the file extension and will treat them all the same.</p> <p>If you are enhancing an existing YAML file, there is no need to change the file extension to <code>.ys</code>. You can just start using YS features in the file.</p> <p>On the other hand, YS libraries loaded with the <code>use</code> function are required to have the <code>.ys</code> extension.</p> Clojure is a JVM language. Does YS need the JVM? <p>No. YS is written in Clojure and exposes the Clojure/Java runtime ecosystem, but there is no JVM involved. This is thanks to the GraalVM\u00a0  project's native-image\u00a0  which can compile anything compiled to jar files into a standalone native binary executable or shared library.</p> <p>This is how the <code>ys</code> binary and the <code>libyamlscript.so</code> shared library are created.</p> <p>Note</p> <p>Even the YS build system does not require you to have any Java or Clojure stuff installed. It simply downloads a GraalVM tarball into <code>/tmp</code>, and the Makefile takes care of everything without leaving any mess behind.</p> Do I need to know Clojure to use YS? <p>All YS/YAML code is compiled to Clojure and evaluated when you run or load it.</p> <p>That said, you can get pretty far with YS without knowing any Clojure. Just read the docs and look at the examples.</p> <p>To become a YS expert, you will need to know Clojure (and YAML) well.</p>"},{"location":"gha/","title":"YS and GitHub Actions","text":"<p>RapidYAML\u00a0  is the world's fastest and most correct YAML parser written in C++.</p> <p>It uses GitHub Actions (GHA)\u00a0  workflows to build and test the codebase for a variety of platforms and configurations.</p> <p>The YAML files for these workflows are have been converted to YS\u00a0  resulting in a much more concise, maintainable and readable set of workflows files (that do exactly the same thing as before).</p> <p>GitHub Actions is a really well thought out system for using YAML as a language to define CI/CD workflows. That said, YS can be used to make these workflows cleaner and more enjoyable to work with.</p> <p>RapidYAML coming to YS Soon</p> <p>The YS and RapidYAML authors have been working together to bring the power of RapidYAML to the YS compiler. Currently the YS compiler uses SnakeYAML Engine\u00a0  (which is quite good) for its parsing stage. We hope that by offering RapidYAML as an option, we can make YS even faster and more correct.</p>"},{"location":"helmys/","title":"HelmYS - YS Helm Charts","text":"<p>HelmYS\u00a0  is a Kubernetes Helm\u00a0 \"post renderer\"\u00a0  that lets you write your Helm chart templates with YS.</p> Click here for how to install <code>helmys</code> and <code>ys</code> quickly <p>Run these commands to install <code>helmys</code> and <code>ys</code> in <code>~/.local/bin</code>:</p> <pre><code>git clone https://github.com/kubeys/helmys\nmake -C helmys install PREFIX=$HOME/.local\n</code></pre> <p>Full details here\u00a0 .</p> <p>YS can be used in combination with Helm's standard Go template\u00a0  syntax or it can replace it entirely.</p> <p>When YS is used exclusively, the Helm chart templates are not only simpler and more concise, but they are also valid YAML files (just like the <code>Chart.yaml</code> and <code>values.yaml</code> files). That means they can be processed with any YAML tools, such as being validated with a YAML linter like yamllint\u00a0 .</p>"},{"location":"helmys/#template-file-comparisons","title":"Template File Comparisons","text":"<p>This is a side by side comparison of the Helm chart template YAML files created by <code>helm create &lt;chart-name&gt;</code> and then converted to use YS. The left side is the YS version and the right side is the original Go template version.</p> ys-chart/templates/helpers.yaml<pre><code>!YS-v0\ndefn trunc(s): take(63 s).str(*).replace(/-$/)\n\n# Expand the name of the chart:\nchart-name =:\n  trunc: Values.nameOverride ||| Chart.name\n\n# Create a default fully qualified app name.\nchart-fullname =:\n  if Values.fullnameOverride.?:\n    trunc: Values.fullnameOverride\n    else:\n      name =: Values.nameOverride ||| Chart.name\n      if name.has?(Release.Name):\n        trunc: Release.Name\n        format \"%s-%s\": Release.Name name\n\n# Selector labels:\nselectorLabels =::\n  app.kubernetes.io/name:: Chart.name\n  app.kubernetes.io/instance:: Release.Name\n\n# Chart labels:\nchart-labels =::\n  helm.sh/chart:: \"$(Chart.name)-$(Chart.version)\"\n  :: selectorLabels\n  app.kubernetes.io/version:: Chart.appVersion\n  app.kubernetes.io/managed-by:: Release.Service\n\n# Create the name of the service account to use:\nserviceAccountName =:\n  Values.serviceAccount.name |||:\n    if Values.serviceAccount.create:\n      chart-fullname\n      'default'\n</code></pre> go-chart/templates/_helpers.tpl<pre><code>{{/*\nExpand the name of the chart.\n*/}}\n{{- define \"go-chart.name\" -}}\n{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix \"-\" }}\n{{- end }}\n\n{{/*\nCreate a default fully qualified app name.\nWe truncate at 63 chars because some Kubernetes name fields are limited to\nthis (by the DNS naming spec).\nIf release name contains chart name it will be used as a full name.\n*/}}\n{{- define \"go-chart.fullname\" -}}\n{{- if .Values.fullnameOverride }}\n{{- .Values.fullnameOverride | trunc 63 | trimSuffix \"-\" }}\n{{- else }}\n{{- $name := default .Chart.Name .Values.nameOverride }}\n{{- if contains $name .Release.Name }}\n{{- .Release.Name | trunc 63 | trimSuffix \"-\" }}\n{{- else }}\n{{- printf \"%s-%s\" .Release.Name $name | trunc 63 | trimSuffix \"-\" }}\n{{- end }}\n{{- end }}\n{{- end }}\n\n{{/*\nCreate chart name and version as used by the chart label.\n*/}}\n{{- define \"go-chart.chart\" -}}\n{{- printf \"%s-%s\" .Chart.Name .Chart.Version | replace \"+\" \"_\" | trunc 63 |\n    trimSuffix \"-\" }}\n{{- end }}\n\n{{/*\nCommon labels\n*/}}\n{{- define \"go-chart.labels\" -}}\nhelm.sh/chart: {{ include \"go-chart.chart\" . }}\n{{ include \"go-chart.selectorLabels\" . }}\n{{- if .Chart.AppVersion }}\napp.kubernetes.io/version: {{ .Chart.AppVersion | quote }}\n{{- end }}\napp.kubernetes.io/managed-by: {{ .Release.Service }}\n{{- end }}\n\n{{/*\nSelector labels\n*/}}\n{{- define \"go-chart.selectorLabels\" -}}\napp.kubernetes.io/name: {{ include \"go-chart.name\" . }}\napp.kubernetes.io/instance: {{ .Release.Name }}\n{{- end }}\n\n{{/*\nCreate the name of the service account to use\n*/}}\n{{- define \"go-chart.serviceAccountName\" -}}\n{{- if .Values.serviceAccount.create }}\n{{- default (include \"go-chart.fullname\" .) .Values.serviceAccount.name }}\n{{- else }}\n{{- default \"default\" .Values.serviceAccount.name }}\n{{- end }}\n{{- end }}\n</code></pre> ys-chart/templates/deployment.yaml<pre><code>!YS-v0:\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name:: chart-fullname\n  labels:: chart-labels\nspec:\n  :when-not Values.autoscaling.enabled.?::\n   replicas:: Values.replicaCount\n  selector:\n    matchLabels:: selectorLabels\n  template:\n    metadata:\n      :when+ Values.podAnnotations.?::\n       annotations:: _\n      labels:: chart-labels\n    spec:\n      :when+ Values.imagePullSecrets.?::\n       imagePullSecrets:: _\n      serviceAccountName:: serviceAccountName\n      securityContext:: Values.podSecurityContext\n      containers:\n      - name:: Chart.name\n        securityContext:: Values.securityContext\n        image::\n          \"$(Values.image.repository):\\\n           $(Values.image.tag ||| Chart.appVersion)\"\n        imagePullPolicy:: Values.image.pullPolicy\n        ports:\n        - name: http\n          containerPort:: Values.service.port\n          protocol: TCP\n        livenessProbe:: Values.livenessProbe\n        readinessProbe:: Values.readinessProbe\n        resources:: Values.resources\n        :when+ Values.volumeMounts.?::\n         volumeMounts:: _\n      :when+ Values.volumes.?::      {volumes:: _}\n      :when+ Values.nodeSelector.?:: {nodeSelector:: _}\n      :when+ Values.affinity.?::     {affinity:: _}\n      :when+ Values.tolerations.?::  {tolerations:: _}\n</code></pre> go-chart/templates/deployment.yaml<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: {{ include \"go-chart.fullname\" . }}\n  labels:\n    {{- include \"go-chart.labels\" . | nindent 4 }}\nspec:\n  {{- if not .Values.autoscaling.enabled }}\n  replicas: {{ .Values.replicaCount }}\n  {{- end }}\n  selector:\n    matchLabels:\n      {{- include \"go-chart.selectorLabels\" . | nindent 6 }}\n  template:\n    metadata:\n      {{- with .Values.podAnnotations }}\n      annotations:\n        {{- toYaml . | nindent 8 }}\n      {{- end }}\n      labels:\n        {{- include \"go-chart.labels\" . | nindent 8 }}\n        {{- with .Values.podLabels }}\n        {{- toYaml . | nindent 8 }}\n        {{- end }}\n    spec:\n      {{- with .Values.imagePullSecrets }}\n      imagePullSecrets:\n        {{- toYaml . | nindent 8 }}\n      {{- end }}\n      serviceAccountName: {{ include \"go-chart.serviceAccountName\" . }}\n      securityContext:\n        {{- toYaml .Values.podSecurityContext | nindent 8 }}\n      containers:\n        - name: {{ .Chart.Name }}\n          securityContext:\n            {{- toYaml .Values.securityContext | nindent 12 }}\n          image: \"{{ .Values.image.repository }}:{{ .Values.image.tag |\n                     default .Chart.AppVersion }}\"\n          imagePullPolicy: {{ .Values.image.pullPolicy }}\n          ports:\n            - name: http\n              containerPort: {{ .Values.service.port }}\n              protocol: TCP\n          livenessProbe:\n            {{- toYaml .Values.livenessProbe | nindent 12 }}\n          readinessProbe:\n            {{- toYaml .Values.readinessProbe | nindent 12 }}\n          resources:\n            {{- toYaml .Values.resources | nindent 12 }}\n          {{- with .Values.volumeMounts }}\n          volumeMounts:\n            {{- toYaml . | nindent 12 }}\n          {{- end }}\n      {{- with .Values.volumes }}\n      volumes:\n        {{- toYaml . | nindent 8 }}\n      {{- end }}\n      {{- with .Values.nodeSelector }}\n      nodeSelector:\n        {{- toYaml . | nindent 8 }}\n      {{- end }}\n      {{- with .Values.affinity }}\n      affinity:\n        {{- toYaml . | nindent 8 }}\n      {{- end }}\n      {{- with .Values.tolerations }}\n      tolerations:\n        {{- toYaml . | nindent 8 }}\n      {{- end }}\n</code></pre> ys-chart/templates/serviceaccount.yaml<pre><code>!YS-v0:\n:when Values.serviceAccount.create:\n  apiVersion: v1\n  kind: ServiceAccount\n  metadata:\n    name:: serviceAccountName\n    labels:: chart-labels\n    :when+ Values.serviceAccount.annotations.?::\n     annotations:: _\n  automountServiceAccountToken::\n    Values.serviceAccount.automount\n</code></pre> go-chart/templates/serviceaccount.yaml<pre><code>{{- if .Values.serviceAccount.create -}}\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: {{ include \"go-chart.serviceAccountName\" . }}\n  labels:\n    {{- include \"go-chart.labels\" . | nindent 4 }}\n  {{- with .Values.serviceAccount.annotations }}\n  annotations:\n    {{- toYaml . | nindent 4 }}\n  {{- end }}\nautomountServiceAccountToken: {{ .Values.serviceAccount.automount }}\n{{- end }}\n</code></pre> ys-chart/templates/service.yaml<pre><code>!YS-v0:\napiVersion: v1\nkind: Service\nmetadata:\n  name:: chart-fullname\n  labels:: chart-labels\nspec:\n  type:: Values.service.type\n  ports:\n  - port:: Values.service.port\n    targetPort: http\n    protocol: TCP\n    name: http\n  selector:: selectorLabels\n</code></pre> go-chart/templates/service.yaml<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: {{ include \"go-chart.fullname\" . }}\n  labels:\n    {{- include \"go-chart.labels\" . | nindent 4 }}\nspec:\n  type: {{ .Values.service.type }}\n  ports:\n    - port: {{ .Values.service.port }}\n      targetPort: http\n      protocol: TCP\n      name: http\n  selector:\n    {{- include \"go-chart.selectorLabels\" . | nindent 4 }}\n</code></pre>"},{"location":"ingydotnet/","title":"About Ingy d\u00f6t Net","text":"<p>Ingy d\u00f6t Net is a software developer and speaker. He is best known for his work on the YAML\u00a0  data serialization language.</p> <p>Recently Ingy created the YS programming language, which embeds cleanly into YAML, adding the functional features that many YAML users need.</p>"},{"location":"ingydotnet/#contact-ingy","title":"Contact Ingy","text":"<ul> <li>Email: ingy@ingy.net</li> <li>LinkedIn: https://www.linkedin.com/in/ingydotnet\u00a0 </li> <li>GitHub: https://github.com/ingydotnet\u00a0 </li> <li>Matrix: https://matrix.to/#/@ingy:yaml.io\u00a0  (best way to chat w/ Ingy)</li> <li>Slack: https://kubernetes.slack.com/team/U080RUYTQL8\u00a0 </li> <li>BlueSky: https://bsky.app/profile/ingydotnet.bsky.social\u00a0 </li> <li>Mastodon: https://mastodon.cloud/@ingydotnet\u00a0 </li> </ul>"},{"location":"ingydotnet/#hire-ingy","title":"Hire Ingy","text":"<p>Ingy\u00a0  is available for consulting, training, and speaking engagements worldwide on YS, YAML, and other related topics.</p>"},{"location":"json/","title":"JSON is YAML!","text":"<p>Since YAML 1.2\u00a0  (2009) JSON is a complete subset of YAML. This means that any valid JSON file is also a valid YAML file and can be loaded by a YAML loader to produce the equivalent data structure as if it were loaded by a JSON parser.</p> <p>Since YS is a YAML loader it can used on JSON files as well.</p> <p>This is very useful for converting between the two formats and for using YS to query and transform JSON files.</p> <p>Note</p> <p>Just because the YAML spec says it's a subset doesn't mean that all YAML tools can be trusted to handle JSON files 100% correctly. Caveat emptor.</p>"},{"location":"kubeys24/","title":"KubeCon 2024 YS Tutorial Info Page","text":"<p>This page has info from Ingy d\u00f6t Net's YS tutorial at KubeCon 2024 in Salt Lake City\u00a0 .</p> <ul> <li>Ingy d\u00f6t Net\u00a0 </li> <li>Video\u00a0 </li> <li>Slides\u00a0 </li> <li>YS Documentation\u00a0 </li> <li>YS Blog\u00a0 </li> <li>YS Repository\u00a0 </li> <li>YS on Exercism\u00a0 </li> <li>HelmYS Helm Templating\u00a0 </li> <li>YS on Rosetta Code\u00a0 </li> <li>RosettaCodeData Repository\u00a0 </li> <li>Calva CircleCI Refactor\u00a0 </li> <li>Vroom Slides in Vim\u00a0 </li> </ul> <p></p> <ul> <li>Programs written in YS</li> <li>sbs\u00a0      Creates markdown gists to compare pairs of files side by side. Used to show     differences between YS and Go templates in Helm.<ul> <li>Example HelmYS gist\u00a0 </li> </ul> </li> <li>yamllm\u00a0      A command line multi LLM (Anthropic, OpenAI, Gemma) query tool</li> <li>ys-vs-rc\u00a0      Compares YS and Rosetta Code solutions to the same problem in many     languages.<ul> <li>Example FizzBuzz gist\u00a0 </li> </ul> </li> <li>See YS by Example in the YS documentation for more     examples.</li> </ul>"},{"location":"kubeys24/#tutorial-outline","title":"Tutorial Outline","text":"<ul> <li>Ingy d\u00f6t Net</li> <li>Introducing YAMLScript (aka YS)</li> <li>Rosetta Code</li> <li>Programming in YAMLScript</li> <li>Real Programming in YAMLScript</li> <li>Bash style -x trace debugging in YAMLScript</li> <li>YAMLScript Improves YAML</li> <li>Learn YAMLScript at Exercism</li> <li>Replacing YAML's &lt;&lt; Merge Key</li> <li>YAMLScript Modes</li> <li>Dot Chains in YAMLScript One-Liners</li> <li>Refactoring large messy YAML configs</li> <li>Refactoring Calva's CircleCI Config</li> <li>Using YAMLScript in Helm Charts</li> <li>YAMLScript's Built-in Standard Libraries</li> <li>Accessing External Data in Data Mode</li> <li>Compiling YAMLScript programs to binary executables</li> <li>Installing YAMLScript</li> <li>Replace your YAML Loader with YAMLScript</li> <li>How YAMLScript (&amp; YAML Loaders) Work</li> <li>Learn Lisp and Clojure in One Minute</li> <li>Learning YAMLScript in Reverse</li> </ul>"},{"location":"kubeys24/#contributing-to-ys","title":"Contributing to YS","text":"<p>YS is a young language and we are looking for contributors to help improve the language, the documentation, and the ecosystem. We welcome your contributions!</p>"},{"location":"kubeys24/#funding-ys-and-yaml","title":"Funding YS and YAML","text":"<p>YS is a free and open source programming language. If you would like to help fund the development of YS, please consider becoming a YS sponsor.</p> <p>Reach out to Ingy about this.</p>"},{"location":"kubeys24/#hire-ingy","title":"Hire Ingy","text":"<p>Ingy\u00a0  is available for consulting, training, and speaking engagements worldwide on YS, YAML, and other related topics.</p>"},{"location":"play/","title":"Playing with YS","text":""},{"location":"play/#coming-soon","title":"Coming Soon!","text":"<p>We are working on a fun and interactive way to play with YS. Stay tuned!</p>"},{"location":"press/","title":"Press","text":""},{"location":"press/#ys-in-the-news","title":"YS in the News","text":"<ul> <li>YS Releases\u00a0 </li> <li>YAML Becomes a Proper Programming Language\u00a0 </li> </ul>"},{"location":"press/#podcasts","title":"PodCasts","text":"<ul> <li>Dead Code \u2014 February 11, 2025\u00a0 </li> <li>The REPL \u2014 April 15, 2024\u00a0 </li> </ul>"},{"location":"press/#presentation-videos","title":"Presentation Videos","text":"<ul> <li>Tutorial: Simplify and Optimize Your YAML with YAMLScript\u00a0  --   Ingy's tutorial at KubeCon 2024 in Salt Lake City</li> <li>YAMLScript - Scripting in YAML\u00a0  --   Ingy at the 2024 TPRC in Las Vegas</li> <li>YAML and YAMLScript\u00a0  --   Ingy at Open Source Summit North America 2024 in Seattle</li> <li>Seajure March 2024 - YAMLScript\u00a0 </li> </ul>"},{"location":"rejekts/","title":"Kubernetes Rejekts 2025 London","text":"<ul> <li>YS Lightning Talk Slides\u00a0 </li> <li>Contact Ingy</li> </ul>"},{"location":"site-testing/","title":"Nothing to see here...","text":"<ul> <li>Social Card for main page</li> </ul>"},{"location":"social/","title":"Social YS","text":"<p>Here are some places where you can engage with the YS Community:</p> <ul> <li>YS GitHub Discussions\u00a0 </li> <li>YS Matrix Chat\u00a0 </li> <li>YS in Clojurians Slack\u00a0 </li> <li>YS on IRC\u00a0 </li> </ul>"},{"location":"tprc2024/","title":"TPRC 2024 YS Talks","text":""},{"location":"tprc2024/#tprc-2024-ingys-ys-talks-info","title":"TPRC 2024 Ingy's YS Talks Info","text":"<p>This web page has info to help you follow along with the YS talks at The Perl and Raku Conference 2024 in Las Vegas.</p>"},{"location":"tprc2024/#quick-links-for-ys","title":"Quick Links for YS","text":"<ul> <li>Talks Assets\u00a0 </li> <li>Talk Slide Files:</li> <li>YAMLScript \u2014 Scripting in YAML\u00a0 </li> <li>YAMLScript \u2014 Dynamic YAML in Perl and Raku\u00a0 </li> <li>Introduction to Clojure for Perl Programmers\u00a0 </li> <li>YS Repository\u00a0 </li> <li>YS Web Site\u00a0 </li> <li>YS Blog\u00a0 </li> <li>YS Docs\u00a0 </li> <li>Clojurians' Slack #yamlscript Channel\u00a0 </li> <li>Matrix #chat-yamlscript Room\u00a0 </li> </ul>"},{"location":"tprc2024/#contact-ingy-dot-net","title":"Contact Ingy d\u00f6t Net","text":"<ul> <li>Matrix DM\u00a0 </li> <li>Slack DM\u00a0 </li> <li>GitHub\u00a0 </li> <li>Email\u00a0\u2709</li> </ul>"},{"location":"tprc2024/#quick-install-for-ys-and-libyamlscriptso","title":"Quick Install For ys and libyamlscript.so","text":"<p>YS works on Linux and macOS. Not on Windows yet.</p> <p>Install ys and libyamlscript.so (in <code>~/.local/bin</code> and <code>~/.local/lib</code>): <pre><code>curl -s https://yamlscript.org/install | bash\n</code></pre></p> <p>Run that as root installs under <code>PREFIX=/usr/local</code>.</p> <p>Install into different directory <code>... | PREFIX=/other/dir bash</code>. Install specific version <code>... | VERSION=0.1.xx bash</code>.</p>"},{"location":"tprc2024/#install-from-source","title":"Install from Source","text":"<p>If the quick install has problems, you can usually get it to work by building from source.</p> <pre><code>git clone https://github.com/yaml/yamlscript\ncd yamlscript\nmake install\n</code></pre> <p>The only dependencies are <code>git</code>, <code>curl</code>, <code>bash</code> and <code>make</code>. Also a <code>libz-dev</code> package is required on Linux.</p>"},{"location":"tprc2024/#install-the-language-modules","title":"Install the Language Modules","text":"<pre><code>cpanm YAMLScript\nzef install YAMLScript\npip install yamlscript\nnpm install @yaml/yamlscript\ngem install yamlscript\n</code></pre> <p>Also you'll need to have <code>libyamlscript.so</code> installed. See above.</p>"},{"location":"blog/","title":"Index","text":"<p>RSS Feed</p>"},{"location":"blog/#the-ys-blog","title":"The YS Blog","text":""},{"location":"blog/2023-12-01/ys-advent-2023/","title":"YS Advent 2023","text":""},{"location":"blog/2023-12-01/ys-advent-2023/#seasons-greetings-my-yaml-friends","title":"Seasons Greetings, my YAML friends!","text":"<p>What if I told you that you could write a program in YAML that would generate a Christmas tree?</p> <p>Well, you can! Here's how:</p> <pre><code>#!/usr/bin/env ys-0\n\ndefn main(width=5):\n  say: tree(width)\n\ndefn tree(width):\n  top =: (width .. 1)\n    .map(\\(line width _))\n    .join(\"\\n\")\n\n  trunk =: trunk(width) * 2\n\n  =&gt;: |-\n    $top\n    $trunk\n\ndefn trunk(num): \"$spaces(num)*\\n\"\n\ndefn line(width, num):\n  :: \"`stars` is a lexically defined function\"\n  stars =: \\(_.++ * '*')\n\n  join '':\n    spaces: num\n    stars: (width - num) * 2\n\ndefn spaces(num): num * ' '\n</code></pre> <p>Let's get a tree!</p> <pre><code>$ ys tree.ys\n     *\n    ***\n   *****\n  *******\n *********\n     *\n     *\n</code></pre> <p>That's a pretty nice tree, but it's a little small. Let's make it bigger!</p> <pre><code>$ ys tree.ys 10\n          *\n         ***\n        *****\n       *******\n      *********\n     ***********\n    *************\n   ***************\n  *****************\n *******************\n          *\n          *\n</code></pre> <p>Welcome to the first day of YS Advent 2023! We're going to be writing a lot of YS this month, so let's get started\u2026</p> <p>Wait! What is YS?</p> <p>YS (aka YAMLScript) is a new programming language that uses YAML as its syntax. You can do anything in YS that you can do in a language like Python or JavaScript such as:</p> <ul> <li>Defining functions</li> <li>Using variables</li> <li>String manipulation and interpolation</li> <li>Loops and conditionals</li> <li>Importing modules</li> <li>And more!</li> </ul> <p>YS looks and feels like an imperative programming language, but it's actually a functional programming language. This means that YS programs are made up of expressions that are evaluated to produce a result.</p> <p>But why would you even want to write a program in YAML?</p> <p>YS is a full-featured, general purpose programming language, but it's also designed to be a great language for writing YAML configuration files. To that point, almost all YAML files are valid YS programs! And they evaluate to the same result that a YAML loader would produce.</p> <p>For example, here's a YAML file that defines a list of fruits:</p> <pre><code># fruits.yaml\n- apple\n- banana\n- cherry\n</code></pre> <p>Let's run this file as a YS program: <pre><code>$ ys fruits.yaml\n$\n</code></pre></p> <p>Nothing happens!</p> <p>But why would anything happen? The program doesn't do anything!</p> <p>It's the same as running this Python program: <pre><code>$ python -c '[\"apple\", \"banana\", \"cherry\"]'\n$\n</code></pre></p> <p>To obtain the evaluation result of a YS program, we need to use the <code>--load</code> option: <pre><code>$ ys --load fruits.yaml\n[\"apple\", \"banana\", \"cherry\"]\n$\n</code></pre></p> <p>We got some JSON back! That's because by default, <code>--load</code> evaluates the YS and prints the result as JSON.</p> <p>What if we want to include these fruits in our YAML grocery list? Let's try it:</p> <pre><code># grocery.yaml\n- bread\n- fruits: load('fruits.yaml')\n- milk\n</code></pre> <p>Let's add the <code>--yaml</code> option to print the result as YAML:</p> <pre><code>$ ys --load grocery.yaml --yaml\n- bread\n- fruits: load('fruits.yaml')\n- milk\n$\n</code></pre> <p>That's not what we wanted! We wanted the contents of the fruits list to be included in the grocery list.</p> <p>But if you think about it, this is exactly what we asked for. Since every YAML file is a valid YS program, it certainly should be loaded just like any other YAML loader would do it.</p> <p>Let's fix this to do what we want:</p> <pre><code># grocery.yaml\n!YS-v0:\n\n:::\n- bread\n- fruits: ! load('fruits.yaml')\n- milk\n</code></pre> <p>Now when we run it:</p> <pre><code>$ ys -l -Y grocery.yaml\n- bread\n- fruits:\n  - apple\n  - banana\n  - cherry\n- milk\n$\n</code></pre> <p>There we go! We got our fruits!</p> <p>So what did we do here? We added 2 things: * A <code>!YS-v0:</code> tag at the top * A <code>!</code> tag before the <code>load</code> function call</p> <p>We won't get into the details of what these tags mean today, but you'll learn about them soon enough.</p>"},{"location":"blog/2023-12-01/ys-advent-2023/#ys-advent-2023-teasers","title":"YS Advent 2023 Teasers","text":"<p>My name is Ingy d\u00f6t Net\u00a0 . I'm one of the original creators of the YAML data language\u00a0  and I lead the YAML Language Development Team\u00a0 .</p> <p>I've been working on YS for about a year now, and I'm excited to finally share it with you. I believe that YS is going to take YAML to exciting new places, while remedying many of its shortcomings, limitations and frustrations. I hope you'll come to agree as you join me on this holiday season unwrapping of the gift that is YS!</p> <p>I also hope that you enjoyed this first day of the YS Advent 2023! I'll be posting a new blog article every day this month, so stay tuned! Well at least until December 25th, but I might keep going after that. :-)</p> <p>Here's a sneak peek of some of the things to come:</p> <ul> <li>Installing and using <code>ys</code> \u2014 the YS interpreter</li> <li>The history of YS</li> <li>How YS is compiled and evaluated</li> <li>How YS can fix many of YAML's problems</li> <li>How to use YS like a YAML loader in any programming language</li> <li>Is YS actually a Lisp???</li> <li>Refactoring complicated YAML configurations with YS</li> <li>Writing polyglot libraries in YS</li> <li>What makes a YAML file a valid (or invalid) YS program?</li> <li>Compiling YS to native binaries and shared libraries</li> </ul> <p>Hopefully you're as excited as I am to learn more about YS!</p> <p>See you tomorrow!</p>"},{"location":"blog/2023-12-02/twas-a-bit/","title":"Twas a Bit","text":"<p>Quote</p> <p>'Twas a bit before Hanukkah, and all through the igloo, not a creature was stirring, not even a frog. The stockings were hung by the window with care, In hopes that St. Krampus soon would be there. The offspring were nestled all snug in their bunks, While visions of spicy-cookies danced in their heads. And cuz in their 'kerchief, and I in my bonnet, Had just settled down for a long winter's snooze. When out on the lawn there arose such a clatter, I sprang from my bench to see what was the matter. Away to the window, I flew like a jet, Tore open the shutters and threw up the curtain. The asteroid on the breast of the new-fallen frost, Gave the lustre of mid-day to dirt below. When what to my wondering eyes should materialize? But a miniature car, and eight tiny elephants.</p> <p>Well that was a bit weird. Let's try again. Don't worry, it's not that hard to write Winter holiday poetry when you have YS on your side!</p>"},{"location":"blog/2023-12-02/twas-a-bit/#welcome-to-day-2-of-ys-advent-2023","title":"Welcome to day 2 of YS Advent 2023!","text":"<p>Today we're going to write a program that generates a winter holiday poem in the Mad Libs style. Along the way, we'll learn about several of the YS basic language features, including:</p> <ul> <li>The <code>load</code> function</li> <li>Defining functions</li> <li>Calling functions</li> <li>Variables</li> <li>Random numbers</li> <li>String interpolation</li> </ul> <p>So where is this awesome YS poetry generator? Well, it's right here, of course; wrapped up in a nice little package for you to open and enjoy!</p> Open Me!!! <pre><code>#!/usr/bin/env ys-0\n# twas-a-bit -- Generate a winter-holiday poem in the Mad Libs style\n\ndefn main():\n  say: poem()\n\ndata =: load('a-bit-of-data.ys')\n\ndefn W(kind):\n  rand-nth: get(data, name(kind))\n\ndefn poem(): |\n  'Twas a bit before $W(:holiday), and all through the $W(:place),\n  not a creature was stirring, not even a $W(:animal).\n  The stockings were hung by the $W(:hang-by) with care,\n  In hopes that St. $W(:saint) soon would be there.\n  The $W(:children) were nestled all snug in their $W(:beds),\n  While visions of $W(:adj)-$W(:candies) danced in their heads.\n  And $W(:relative) in their 'kerchief, and I in my $W(:hat),\n  Had just settled down for a long winter's $W(:activity).\n  When out on the $W(:outside) there arose such a clatter,\n  I sprang from my $W(:seat) to see what was the matter.\n  Away to the window, I flew like a $W(:flyer),\n  Tore open the $W(:covers) and threw up the $W(:cover).\n  The $W(:luminary) on the breast of the new-fallen $W(:fallers),\n  Gave the lustre of mid-day to $W(:outers) below.\n  When what to my wondering eyes should $W(:arrive)?\n  But a miniature $W(:vehicle), and eight tiny $W(:service-animals).\n</code></pre> <p>You can run this program with one of the following commands:</p> <pre><code>$ ys twas-a-bit\n\n$ chmod +x twas-a-bit &amp;&amp; ./twas-a-bit\n</code></pre> <p>and you'll (very likely) get a different version of the poem every time you run it!</p> <p>You might be wondering where all the data for this poem comes from. I hid it in a secret place... see if you can find it!</p> Don't Open Me!!! <pre><code># a-bit-of-data.ys -- Data for a-bit-before\n\nholiday:  [Christmas, Hanukkah, Kwanzaa, Winter, Solstice, Yule, Saturnalia]\nplace:    [house, apartment, condo, igloo, cave, castle, mansion, tent, hut]\nanimal:   [mouse, cat, dog, bird, fish, snake, pug, frog, turtle, rabbit]\nhang-by:  [chimney, fireplace, window, toilet, door, wall, faucet, tree]\nsaint:    [Nicholas, Grinchy, Krampus, Valentines, Jack, Frosty, Santa, Bernard]\nchildren: [children, kids, tots, babies, offspring, spawn, progeny, brats]\nbeds:     [beds, bunks, cots, hammocks, pallets, mats, futons, blankets]\nadj:      [sweet, sour, salty, bitter, spicy, savory, pungent, tart, tangy]\ncandies:  [candies, chocolates, sweets, cookies, cakes, pies, pastries]\nrelative: [mamma, papa, sis, bro, aunty, uncle, cuz, gram, gramps]\nhat:      [cap, hat, bonnet, beanie, beret, fedora, sombrero, helmet, crown]\nactivity: [nap, sleep, slumber, snooze, rest, hibernation, siesta, doze]\noutside:  [lawn, yard, field, forest, woods, jungle, desert, tundra, ocean]\nseat:     [bed, chair, couch, sofa, futon, hammock, bench, stool, throne]\nflyer:    [flash, bolt, bullet, rocket, plane, jet, eagle, hawk, falcon]\ncovers:   [shutters, blinds, curtains, shades, drapes, screens, panels]\ncover:    [shutter, blind, curtain, shade, drape, screen, panel]\nluminary: [moon, sun, star, planet, comet, asteroid, meteor, satellite]\nfallers:  [snow, rain, hail, sleet, ice, slush, frost, dew, fog, mist]\nouters:   [trees, bushes, shrubs, flowers, grass, weeds, rocks, dirt, sand]\narrive:   [appear, arrive, come, materialize, manifest, show up, land]\nvehicle:  [sleigh, car, truck, van, bus, train, plane, boat, ship, rocket]\nservice-animals: [reindeer, horses, camels, elephants, oxen, donkeys, mules]\n</code></pre>"},{"location":"blog/2023-12-02/twas-a-bit/#the-load-function","title":"The <code>load</code> Function","text":"<p>If you found the secret database you can see that it's just a YAML file. Our YS program loads this file using the <code>load</code> function. The <code>load</code> function is one of the most important functions in YS. It reads a YS file, evaluates it, and returns the result.</p> <p>But we loaded a YAML file, not a YS file. How did that work? Remember that (almost) every YAML file is a valid YS program, so it just works.</p> <p>We can also use it to load a JSON data file. Why? Because JSON is a subset of YAML. That means that (absolutely) every JSON file is a valid YAML file, and therefore every JSON file is a valid YS program!</p> <p>The <code>load</code> function is just one of literally hundreds of core functions available to you by default in YS. It's part of the YS standard library. These functions give you the ability to code anything possible in any modern programming language. We'll be learning more about them in the coming days.</p>"},{"location":"blog/2023-12-02/twas-a-bit/#defining-functions","title":"Defining Functions","text":"<p>We defined 3 functions in our poem generator: <code>main</code>, <code>W</code>, and <code>poem</code>. We did this using <code>defn</code>, which is short for \"define function\".</p> <p>Here's a simple function that tells you how far away you are from the answer to life, the universe, and everything:</p> <pre><code>defn how-far-away(n): abs(42 - n)\n</code></pre> <p>In YAML terms this is a mapping pair whose key is a plain (unquoted) string containing <code>defn</code>, the function name, and the function parameters. The mapping pair's value is the function body, which is a YS expression.</p> <p>A YS function returns the value of its last evaluated expression.</p>"},{"location":"blog/2023-12-02/twas-a-bit/#calling-functions","title":"Calling Functions","text":"<p>There are a lot of ways to call a function in YS. In fact, there are a lot of ways to do almost everything in YS. The only hard and fast rule is that the entire program must be valid YAML.</p> <p>Consider this expression:</p> <pre><code>map inc: range(1, 10)\n</code></pre> <p>Here we are calling 2 functions: <code>map</code> and <code>range</code>. Another way to write this would be:</p> <pre><code>map inc:\n  range: 1, 10\n</code></pre> <p>or:</p> <pre><code>=&gt;: map(inc, range(1, 10))\n</code></pre> <p>or:</p> <pre><code>-&gt;&gt;: range(1, 10), map(inc)\n</code></pre> <p>There's actually many more ways to write this, but this is only day 2 of YS Advent 2023, so we'll save those for later.</p> <p>In general, these 2 forms are equivalent:</p> <pre><code>a b, c: d, e, f\n---\na(b, c, d, e, f)\n</code></pre> <p>In YS, a function call is either a mapping pair or a scalar. When it is a mapping pair, the key and the value can both have 1 or more expressions. The first expression on the key side is the function name and all the rest of the expressions on both sides are the function arguments. When it is a scalar, a function name is followed by a parenthesized list of arguments. Note that the opening parenthesis must immediately follow the function name without any intervening whitespace.</p> <p>You may have noticed a few more functions just now: <code>inc</code>, <code>=&gt;</code>, and <code>-&gt;&gt;</code>. Well, <code>inc</code> is a function but we didn't call it directly. We passed it as an argument to the <code>map</code> function.</p> <p>I'll tell you about <code>=&gt;</code> and <code>-&gt;&gt;</code> later.</p> <p>Info</p>"},{"location":"blog/2023-12-02/twas-a-bit/#comma-chameleon","title":"Comma Chameleon","text":"<p>I was going to save this for later, but I just can't wait...</p> <p>Commas are a Lie!</p> <p>In YS, commas are optional whitespace. You can use them to make your code more readable, if that's your thing. It's not my thing, so I won't use them much from here on out.</p>"},{"location":"blog/2023-12-02/twas-a-bit/#variables","title":"Variables","text":"<p>One of my favorite things about YS is that you can use any word as a variable or function name. We call these names \"symbols\".</p> <p>For example almost every language has an <code>if</code> keyword, and (since it is a special keyword) you can't use it for a name. In YS you are free to use the <code>if</code> symbol (as a variable or function name) as long as you don't need to use the standard <code>if</code> function in the same scope.</p> <p>We assign a value to a variable like so:</p> <pre><code>foo =: 42\n</code></pre> <p>This is a mapping pair whose key is a plain string containing the variable name followed by <code>=:</code> separated by at least one space character. The pair value is the assignment value. Simple!</p>"},{"location":"blog/2023-12-02/twas-a-bit/#strings","title":"Strings","text":"<p>If you know your YAML, you know that YAML has 5 different styles to represent a scalar value (a string, number, boolean, etc). The styles are called \"plain\" (unquoted), \"single-quoted\", \"double-quoted\", \"literal\", and \"folded\". Plain scalar turns strings, numbers, booleans, etc. The other 4 styles are always strings.</p> <p>In YS code, the scalar style is very important. Symbols and expressions are always plain scalars. The 4 other styles are used for strings.</p>"},{"location":"blog/2023-12-02/twas-a-bit/#random-numbers","title":"Random Numbers","text":"<p>We used the <code>rand-nth</code> function to select a random value from a list. Not much to say about that, except that it's a function that takes a list as an argument and returns a random value from it.</p>"},{"location":"blog/2023-12-02/twas-a-bit/#string-interpolation","title":"String Interpolation","text":"<p>YS strings written in the \"single-quoted\" or \"folded\" styles are just strings, but when you use the \"double-quoted\" or \"literal\" styles, the strings have interpolation super powers!</p> <p>Interpolation is the process of inserting the value of variables or expressions into a string in the place where they appear. In YS, these expanding objects are indicated by a <code>$</code> character immediately followed by the variable or expression.</p> <p>This is pretty much the same as string interpolation in a shell like Bash:</p> <pre><code>name=World\necho \"Hello $name. The answer is $((43 - 1)).\"\n</code></pre> <p>The equivalent YS code would be:</p> <pre><code>name =: 'World'\nsay: \"Hello $name. The answer is $(43 - 1).\"\n</code></pre> <p>You can also interpolate a YS function call (symbol followed by argument list) like this:</p> <pre><code>say: \"Hello $inc(41).\"\n</code></pre> <p>In most languages that support interpolation <code>inc</code> would expand as a variable, but in YS it's a function and the parenthesized argument list is part of the expression.</p> <p>This is the kind of interpolation syntax we used in our poem generator program.</p>"},{"location":"blog/2023-12-02/twas-a-bit/#conclusion","title":"Conclusion","text":"<p>Well that wraps up day 2 of the YS Advent 2023. I hope you enjoyed it, and learned a bit more about YS.</p> <p>Honestly, at this point you probaby have more questions than answers. Luckily for you, December has more than 2 days in it. See you tomorrow!</p> <p>I'll leave you with a little poem that a close friend of mine just wrote:</p> <p>Quote</p> <p>'Twas a bit before Winter, and all through the hut, not a creature was stirring, not even a snake. The stockings were hung by the faucet with care, In hopes that St. Frosty soon would be there. The tots were nestled all snug in their bunks, While visions of pungent-candies danced in their heads. And uncle in their 'kerchief, and I in my fedora, Had just settled down for a long winter's rest. When out on the lawn there arose such a clatter, I sprang from my sofa to see what was the matter. Away to the window, I flew like a bullet, Tore open the panels and threw up the blind. The planet on the breast of the new-fallen snow, Gave the lustre of mid-day to flowers below. When what to my wondering eyes should materialize? But a miniature train, and eight tiny oxen.</p>"},{"location":"blog/2023-12-03/load-em-up/","title":"Load em Up!","text":"<p>On the 3rd day of Advent, my YS code gave to me... A sequence in a map tree!</p> <p>Did you know that all JSON is YAML? You should, because I told you that yesterday!</p> <p>It's true. YAML is a superset of JSON. Both in terms of syntax and data model.</p> <p>This means that any possible valid JSON input is also valid as a YAML input. A proper YAML loader and a JSON loader should produce the same data structure from the same JSON input.</p> <p>Note</p> <p>Assuming a YAML 1.2 loader using the YAML 1.2 JSON Schema</p>"},{"location":"blog/2023-12-03/load-em-up/#welcome-to-day-3-of-ys-advent-2023","title":"Welcome to day 3 of YS Advent 2023!","text":"<p>This YAML/JSON relationship has some interesting implications for people interacting with systems that read YAML or JSON as input.</p> <p>People often prefer to read or write data in YAML because it's more human-friendly with its structured indentation, lack of excessive punctuation and its support for comments. JSON is more machine-friendly due to its simplicity and robust tooling, thus often prererable for machine-to-machine communication.</p> <p>It's quite common to see people configure their systems that have JSON inputs by using YAML instead, and setting things up to convert the hand maintained YAML to JSON before the system sees it. It can also be helpful to format large JSON API responses as YAML so that they are easier to read.</p> <p>Going the other way, people can refactor large YAML configurations by first converting them to JSON, using JSON tools like <code>jq</code> to manipulate the data and then converting the data back to YAML.</p> <p>YS is an ideal technology for performing these kinds of conversions and manipulations.</p>"},{"location":"blog/2023-12-03/load-em-up/#loading-vs-running-ys","title":"Loading vs Running YS","text":"<p>On one hand, YS is a complete programming language that you can use for writing new applications (and libraries). In YS jargon, we \"run\" these applications. We'll discuss YS apps and \"running\" them extensively in the coming days.</p> <p>Today we are covering YS's purpose we just described: reading YAML files into data; possibly transforming the data dynamically along the way.</p> <p>This use of YS is called \"loading\" and can be done on most existing YAML files and all existing JSON files.</p> What does \"most\" mean?  When I say \"most YAML input files\" I mean YAML input that fits into the JSON data model. Almost all YAML files used for configuration purposes fall into this category.  Specifically:  * Mapping keys must be strings. * Aliases may not create circular references. * Custom tags (those beyond the YAML 1.2 JSON Schema) must not be used.  I've never seen any of those things used in a configuration file.  ---  <p>Let's look at an example.</p> <p>YAML uses the term \"load\" to refer to the process of a computer program converting a YAML text into a data structure in memory. It is common for a YAML framework to have a <code>load</code> (and <code>dump</code>) function or method as its primary API.</p> <p>Here's a Python single line program that loads a YAML text into a Python dictionary and and then prints it.</p> <pre><code>$ python -c 'import yaml; print(yaml.safe_load(\"Advent day: 3\"))'\n{'Advent day': 3}\n</code></pre> <p>YS has a Python binding that does the same thing:</p> <pre><code>$ python -c 'from yamlscript import YAMLScript; print(YAMLScript().load(\"Advent day: 3\"))'\n{'Advent day': 3}\n</code></pre> <p>It also has these bindings in many other programming languages and plans to have them in all modern programming languages.</p> <p>A major goal of the YS project is to have these YS binding libraries be the best way to load YAML config files in all modern programming languages. This will be a big improvement over the current situation where every YAML framework has its own API and its own set of bugs and quirks.</p>"},{"location":"blog/2023-12-03/load-em-up/#loading-ys-from-the-command-line","title":"Loading YS from the Command Line","text":"<p>We can also load YS outside of any programming language.</p> <p>We can do it from the command line using the <code>ys</code> command with the <code>--load</code> option.</p> <pre><code>$ ys -le 'Advent day: 3'\n{\"Advent day\": 3}\n</code></pre> <p>Note</p> <p>The <code>-le</code> option is a short for <code>-l</code> (short for <code>--load</code>) and <code>-e</code> (short for `--eval).</p> <p>Since the command line doesn't have any way to store the loaded YAML (like a programming language would as a data structure) we have to get it back as text. By default, <code>ys</code> prints the loaded YAML as JSON.</p> <p>That may seem strange; a YAML loader defaulting to JSON. But it's not strange at all, for two reasons:</p> <ul> <li>JSON is YAML. Remember?!</li> <li>JSON is the de facto Lingua Franca of inter-program communication.</li> </ul> <p>Put another way, <code>ys</code> outputs YAML in its most compatible format.</p> <p>In a programming language, we load YAML data into an object and pass it to some function to do something with it. In the CLI-as-programming-language analogy, the functions are other programs!</p>"},{"location":"blog/2023-12-03/load-em-up/#loading-yaml-dynamically","title":"Loading YAML Dynamically","text":"<p>The main point of today's post is to show how YS can be used as a normal YAML loader. But of course, YS has SuperPowers\u2122 that other YAML loaders don't have.</p> <p>With great SuperPowers comes SuperResponsibility. YS won't use its SuperPowers unless you ask it to. You may ask it (politely) in one of these ways:</p> <ul> <li>Start the YS with the <code>!YS-v0</code> tag</li> <li>Words are commands by default</li> <li>Start the YS with the <code>!YS-v0:</code> tag</li> <li>Words are data by default</li> <li>Use a <code>ys-0</code> shebang line like: <code>#!/usr/bin/env ys-0</code></li> <li>Implicitly defaults to <code>!YS-v0</code></li> <li>Use the <code>-e</code> option for YS one-liners</li> <li>Imlicitly defaults to <code>!YS-v0</code> (for one-liner convenience)</li> </ul> <p>After that you are good to go!</p> <p>Imagine we have YAML files containing top level mappings such as:</p> <pre><code># map1.yaml\nreindeer:\n- name: Dancer\n- name: Blitzen\n- name: Rudolph\n  nosy: true\n</code></pre> <p>We can pull data from these files into our YAML dynamically:</p> <pre><code># file1.ys\n!YS-v0:\n\nkey1: val1\nkey2: ! load('map1.yaml')\nkey3: val3\n</code></pre> <p>Now if we \"ran\" the YS nothing would happen, but when we \"load\" it, we get the data we expect.</p> <pre><code>$ ys --load file1.ys\n{\"key1\": \"val1\", \"key2\": {\"reindeer\": [{\"name\": \"Dancer\"}, {\"name\": \"Blitzen\"}, {\"name\": \"Rudolph\", \"nosy\": true}]}, \"key3\": \"val3\"}\n</code></pre> <p>Now I can explain those pesky YAML tags! What does this YS mapping pair mean?</p> <pre><code>say: 123\n</code></pre> <p>Well, it depends. It could be a command to print the number 123 as text to the console. Or it could be a mapping pair with the key <code>say</code> and the value <code>123</code>. The starting tag tells us which it is. The <code>!YS-v0</code> tag means that we start off things in a state where plain (unquoted) YAML scalars are code. OTOH, with <code>!YS-v0:</code> these scalars are data like in normal YAML.</p> <p>The <code>!</code> tag is how we switch back and forth (toggle) between these two states. If you have existing YAML files and you want to use a couple of YS functions in them, start them with <code>!YS-v0:</code> and then use <code>!</code> tags before the functional parts.</p> <p>Another way to accomplish the same result is:</p> <pre><code># file2.ys\n!YS-v0\n\nmap1 =: load('map1.yaml')\n\n=&gt;:\n  +{\n    :key1 'val1'\n    :key2 map1\n    :key3 'val3'\n  }\n</code></pre> <p>Here everything is code, and the final expression is the data we want to load. When you run <code>ys --load file2.ys</code> you get the same result as before.</p> <p>Note</p> <p>The things starting with <code>:</code> are called keywords, and they turn into one word strings on output. More on keywords another day.</p>"},{"location":"blog/2023-12-03/load-em-up/#merging-mappings-and-joining-sequences","title":"Merging Mappings and Joining Sequences","text":"<p>I'll leave you with the two most frequent requests that Santa gets from YAML kids: <code>merge</code> and <code>concat</code>.</p> <pre><code># file3.ys\n!YS-v0:\n\nmy-map: !\n  merge:\n    load('map1.yaml')\n    load('map2.yaml')\nmy-seq: !\n  concat:\n    load('seq1.yaml')\n    load('seq2.yaml')\n</code></pre> <p>When we were inventing YAML 20 years ago, one of the most confusing things we did was to suggest that <code>&lt;&lt;</code> used as a key could trigger a merge operation.</p> <p>It wasn't a good idea because:</p> <ul> <li>It's the only dynamic thing we put in YAML</li> <li>It actually wasn't in the spec proper</li> <li>It's not well defined at all</li> <li>Many YAML frameworks don't support it at all</li> <li>The ones that do it, all do it differently</li> </ul> <p>But people love it, and they want more!</p> <p>Well... YS gives you more. 100s more (standard functions) in fact! (All in good time, my patient Advent-urers.)</p> <p>Let's end this day by making that last YS file even cooler than Rudolph's toes!</p> <pre><code>!YS-v0:\n\nmy-map: ! load('map1.yaml') + load('map2.yaml')\nmy-seq: ! load('seq1.yaml') + load('seq2.yaml')\n</code></pre> <p>THe YS <code>+</code> operator is a general purpose joiner. It's polymorphic for numbers, strings, sequences and mappings.</p> <p>As ususal, I hope you enjoyed today's post. I'll see you tomorrow for day 4 of YS Advent 2023!</p>"},{"location":"blog/2023-12-04/santas-big-secret/","title":"Santa's Big Secret","text":"<p>I've got a little secret to tell you. I've been hiding a little something from you. Even that's a lie. I've actually been hiding something very very big something from you.</p>"},{"location":"blog/2023-12-04/santas-big-secret/#ys-is-a-lisp","title":"*** YS is a Lisp! *****","text":""},{"location":"blog/2023-12-04/santas-big-secret/#welcome-to-day-4-of-ys-advent-2023","title":"Welcome to day 4 of YS Advent 2023!","text":"<p>Today is Monday and Monday's are made for big headlines.</p> <p>That's right. Not only is YS a Lisp, it's a very specific and modern Lisp. It's a Lisp that has a community and conferences and books and jobs that pay people to write code in Lisp!</p> <p>If you know the slightest thing about Lisp, you must think I'm crazy. YS is YAML, and YAML is no Lisp. It's almost the Anti-Lisp incarnate.</p> <p>OK. Here's the deal...</p> <p>There you go. The secret is out. Every YS program is program is a Clojure program.</p> <p>Every time you run (or load!) a YS program, it compiles to Clojure code that is then run by a Clojure runtime engine. I can prove it!</p> <p>Consider this YS program:</p> <pre><code># hw.ys\n!YS-v0\nprintln: 'Hello, world!'\n</code></pre> <p>Let's run it:</p> <pre><code>$ ys --run hw.ys\nHello, world!\n</code></pre> <p>No surprises there. Now let's first compile it to Clojure:</p> <pre><code>$ ys --compile hw.ys\n(println \"Hello, world!\")\n</code></pre> <p>Looks pretty Lispy to me. Now let's run the Clojure code:</p> <pre><code>$ ys -c hw.ys | clojure -M -\nHello, world!\n</code></pre> <p>It works! YS really is Clojure. And Clojure most definitely is a Lisp. Soooooo...?! Yeah, you get it. QED, baby!</p>"},{"location":"blog/2023-12-04/santas-big-secret/#ys-is-clojure","title":"YS is Clojure","text":""},{"location":"blog/2023-12-04/santas-big-secret/#what-is-clojure","title":"What is Clojure?","text":"<p>Oh wait, you don't know what Clojure is? Or maybe you need a quick refresher?</p> <p>Clojure is a modern Lisp that runs on the JVM. It was created by this really interesting guy named Rich Hickey\u00a0  whom I've actually met many times...</p> <p>...on YouTube.</p> <p>I don't typically watch a lot of programming videos, but I've seen at least a dozen of his. I encourage you to watch some too. Or at least peruse some of his various opinions on varying programming topics\u00a0 .</p> <p>Rich programmed professionally in Java for many years. One day he decided that he couldn't take it anymore. He took a couple years off and he changed the world. The Java world anyway.</p> <p>Java is a widely used imperative programming language, with mutable data structures and a noisy syntax. Clojure by contrast is a functional programming language, with immutable data structures and a very clean syntax. You can use any Java library directly from Clojure and vice versa, making Clojure an extremely practical language.</p> <p>In a phrase: \"Clojure makes Java not suck\". (Ingy's words, not Rich's)</p>"},{"location":"blog/2023-12-04/santas-big-secret/#what-does-this-all-have-to-say-about-ys","title":"What does this all have to say about YS?","text":"<p>Yesterday we learned that all JSON is YAML and that almost all YAML is YS. Does this means that all JSON is Clojure?</p> <p>Actually it kind of does.</p> <p>Let's compile some JSON with <code>ys</code>:</p> <pre><code>$ ys -md -ce '{ \"foo\": \"bar\", \"baz\": [1, 2, null, true] }'\n{\"foo\" \"bar\", \"baz\" [1 2 nil true]}\n</code></pre> <p>Yep. That's Clojure. It also happens to be EDN, which is Clojure's native data format.</p> <p>Note</p> <p>The <code>-md</code> option tells <code>ys</code> not to add the <code>!YS-v0</code> tag that it usually does with <code>-e</code> to make your YS life easier. We'll learn more about <code>-m</code> another time.</p> <p>Lisp puts parentheses around everything. Does that mean that YS does too?</p> <p>Good question. The answer may surprise you. YS has a lot of different ways to express code. It embraces diversity. (As long as that diversity can be written as YAML!) One of the ways to write code in YS is in Clojure syntax!</p> <p>This YS prints 3 symbol names available in the current namespace:</p> <pre><code>$ ys -e '(say (take (+ 1 2) (keys (ns-map NS))))'\n(+' decimal? sort-by)\n</code></pre> <p>In Lisp every expression (function call) is a paranthesized list where the first word is the function name and the rest are the arguments. That means arithmetic expressions like <code>1 + 2</code> are written as <code>(+ 1 2)</code>.</p> <p>This feels very natural to Lisp programmers, but it can be a bit of a shock to the rest of us. YS offers alternate ways (called ysexprs or YeS Expressions) to write these Lisp basic forms.</p> <p>We'll learn the gritty details in another post, but here's the basics:</p> <pre><code>=&gt;: 1 + 2               # (+ 1 2)   ;; + - * /\n=&gt;: 3 * 4 * 5           # (* 3 4 5) ;; if operators are the same\n=&gt;: foo(bar(42 true))   # (foo (bar 42 true))\n</code></pre> <p>We could write the above YS expression like this:</p> <pre><code>say:\n  take:\n    +: 1 2\n    keys:\n      ns-map: NS\n</code></pre> <p>Both YS forms compile to the same Clojure code.</p> <p>Basically at any level of YAML in YS, you can switch to using Clojure. Since an entire YAML document can be a single string you can sometimes use an entire Clojure file as a YS program. As long as it's valid YAML, of course.</p> <p>Clojure is a JVM Language. Does that mean that YS is a JVM language?</p> <p>This one is crazy. YS does not need the JVM or anything Java whatsoever. The <code>ys</code> binary is a native machine code executable. The <code>libyamlscript</code> shared library is also native machine code and thus can be FFI bound to almost any programming language.</p> <p>You don't even need to have Java installed on your system to build YS. That's a little fib. The build system always downloads a Java build system and then discards it when it's done. The point is that to build <code>ys</code> you don't need to set up any prerequisites. It just works.</p> <p>How is this possible? It's all thanks to GraalVM\u00a0  which is, as one of my YS friends puts it, \"a cheat code\"! GraalVM's <code>native-image</code> compiler can magically turn anything Java into native machine code on Linux, macOS and Windows. Wow!</p> <p>A very noticeable difference between YS and Clojure is startup time:</p> <pre><code>$ time ys -e 1\nreal    0m0.044s\n$ time perl -e 1    # for comparison\nreal    0m0.048s\n$ time clojure -M -e 1\n1\nreal    0m0.637s\n</code></pre> <p>Clojure's not 10 times slower than YS (or Perl). It just takes 10 times longer to start up a JVM.</p> <p>Do you need to know Clojure to use YS?</p> <p>No, not at first. Proof? I just got through 3 days of YS Advent without mentioning Clojure once.</p> <p>If you just want to make your out of control YAML files more manageable, composable and maintainable, you can easily learn how to wield YS without knowing a lick of Clojure.</p> <p>When you need more power it's there for you because Clojure is there for you. But you have to learn some new things first.</p> <p>I honestly think YS can be a great introduction to Clojure. I think that Clojure is a great introduction to Lisp, working with immutable data structures, and functional programming. And I think that learning these things will make you a better programmer in whatever language you use.</p> <p>YAML has always been about making things easier in all programming languages. My love for Clojure is that it has the right parts to make YAML more powerful in all those same languages. I have no desire to see the whole world switch to Clojure (or anything else). Clojure is a great gift and I hope YS can help more people benefit from it in the languages and technologies they already use.</p> <p>How does YS benefit from building over Clojure?</p> <p>In a nutshell, it makes YS a complete, robust, battle tested, and well-documented language from the get go. Rich knew that to make a new language in 2006 he needed to build on something that was already a big deal; the Java ecosystem.</p> <p>I feel the exact same way about YS.</p> <p>YS is poised to take YAML to a whole new level. This is all thanks to the shoulders of these specific giants:</p> <ul> <li>YAML\u00a0 </li> <li>Clojure\u00a0 </li> <li>SnakeYAML\u00a0 </li> <li>Small Clojure Interpreter (SCI)\u00a0 </li> <li>GraalVM\u00a0 </li> </ul> <p>I'll have more to say about each of these in future posts. For now, I'll just say that I'm extremely grateful for all of them.</p> <p>I'll see you tomorrow for day 5 of YS Advent 2023!</p>"},{"location":"blog/2023-12-05/unwrapping-gifts/","title":"Unwrapping Gifts","text":"<p>It's certainly a relief now that I've told you the big secret about YS. Now that you know that YS is really Clojure, I don't have to dance around the subject anymore. I didn't want to scare you away by going Full-Lisp on you from the start!</p> <p>Now we can just get into it. We can write, run and load YS until the cows come home.</p> <p>But wait... How do we do that? You don't even have YS installed yet!</p>"},{"location":"blog/2023-12-05/unwrapping-gifts/#welcome-to-day-5-of-the-ys-advent-calendar","title":"Welcome to Day 5 of the YS Advent Calendar","text":"<p>Today we're going to learn how to install YS a couple different ways.</p> <p>Luckily for you I just finished creating the first official YS release\u00a0 . What a coincidence!</p> <p>At he moment there are only releases published for Linux x86_64 and macOS aarch64. If you happen to be running on one of those platforms, you can run the following command to install the YS CLI, <code>ys</code>:</p> <p>Info</p> <p>UPDATE: Releases are now available for Linux and macOS on both <code>x86_64</code> and <code>aarch64</code> (for either). See the YS Releases Page\u00a0 </p> <pre><code>curl https://yamlscript.org/install | bash\n</code></pre> <p>This installer defaults to installing <code>ys</code> into <code>~/.local/bin</code>, unless you run it as root in which case it defautlls to <code>/usr/local/bin</code>.</p> <p>If you want to install it somewhere else, like say <code>~/local/bin</code>, you can do:</p> <pre><code>curl https://yamlscript.org/install | PREFIX=~/local bash\n</code></pre> <p>Wherever you install it, make sure that the <code>$PREFIX/bin</code> directory is in your <code>PATH</code> environment variable.</p> <p>YS also provides a release for <code>libyamlscript.so</code>, the YS shared library. You can install it like above but with (some variation of):</p> <pre><code>curl https://yamlscript.org/install | bash\n</code></pre> <p>We'll be using the shared library soon when we start playing around with using YS from other programming languages.</p>"},{"location":"blog/2023-12-05/unwrapping-gifts/#building-from-source","title":"Building from Source","text":"<p>The most reliable way to install YS is to build it from source. We've put a lot of effort into making this as easy as possible. You don't need any special prerequisites; just git, bash, curl and make.</p> <p>The first thing you need to do is clone the YS repo:</p> <pre><code>git clone https://github.com/yaml/yamlscript\n</code></pre> <p>Then you can build and install the CLI with:</p> <pre><code>$ cd yamlscript\n$ make build\n$ make install\nor\n$ make install PREFIX=...\n</code></pre> <p>The <code>make install</code> command will install both <code>ys</code> and <code>libyamlscript.so</code> into <code>$PREFIX/bin</code> and <code>$PREFIX/lib</code> respectively.</p> <p>YS has a pretty sophisticated build system, built around GNU Make. Even though the build uses Java, Clojure and GraalVM, you don't need to install any of those things. In fact, even if you have them installed, the build will ignore them.</p>"},{"location":"blog/2023-12-05/unwrapping-gifts/#running-ys","title":"Running YS","text":"<p>Now that you have YS installed, you can run it. Try:</p> <pre><code>$ ys --help\n</code></pre> <p>It should display:</p> <pre><code>ys - The YS Command Line Tool - v0.1.96\n\nUsage: ys [&lt;option...&gt;] [&lt;file&gt;]\n\nOptions:\n\n  -l, --load               Output (compact) JSON of YS evaluation\n  -e, --eval YSEXPR        Evaluate a YS expression\n                           multiple -e values joined by newline\n\n  -c, --compile            Compile YS to Clojure\n  -b, --binary             Compile to a native binary executable\n\n  -p, --print              Print the result of --run in code mode\n  -o, --output FILE        Output file for --load, --compile or --binary\n\n  -T, --to FORMAT          Output format for --load:\n                             json, yaml, edn\n  -J, --json               Output (pretty) JSON for --load\n  -Y, --yaml               Output YAML for --load\n  -E, --edn                Output EDN for --load\n  -U, --unordered          Mappings don't preserve key order (faster)\n\n  -m, --mode MODE          Add a mode tag: code, data, or bare (for -e)\n  -C, --clojure            Treat input as Clojure code\n\n  -d                       Debug all compilation stages\n  -D, --debug-stage STAGE  Debug a specific compilation stage:\n                             parse, compose, resolve, build,\n                             transform, construct, print\n                           can be used multiple times\n  -S, --stack-trace        Print full stack trace for errors\n  -x, --xtrace             Print each expression before evaluation\n\n      --install            Install the libyamlscript shared library\n      --upgrade            Upgrade both ys and libyamlscript\n\n      --version            Print version and exit\n  -h, --help               Print this help and exit\n</code></pre> <p>In the next day or two we'll go over all of these options in detail.</p> <p>Here's a quick example of how to run YS to process a file from the internet that Google just told me about:</p> <pre><code>$ curl https://gist.githubusercontent.com/chriscowley/8598119/raw/8f671464f914320281e5e75bb8dcbe11285d21e6/nfs.example.lan.yml |\nys -J - | jq .classes\n{\n  \"nfs::server\": {\n    \"exports\": [\n      \"/srv/share1\",\n      \"/srv/share3\"\n    ]\n  }\n}\n</code></pre> <p>The special file name <code>-</code> tells <code>ys</code> to read the program from STDIN. The <code>-J</code> option tells <code>ys</code> to <code>--load</code> the YS and output the evaluation to JSON.</p> <p>Well that's a wrap. Thanks again for following along each day.</p> <p>I'll see you tomorrow for day 6 of YS Advent 2023!</p>"},{"location":"blog/2023-12-06/modes-of-transportation/","title":"Modes of Transportation","text":"<p>How do you get around? Some people walk, some ride bikes, some drive cars (or the cars drive them), some take trains, some in planes, so many ways, even some in sleighs.</p> <p>In YS, data gets around via various modes of transportation...  3 modes to be exact.</p> <p>Rememeber back on December 3rd when we talked about the 2 different states that a YS program can be in? In one state <code>say</code> is a function, and in the other it's just a plain string.</p> <p>We call these states \"modes\", and there is actually three of them.</p>"},{"location":"blog/2023-12-06/modes-of-transportation/#welcome-to-day-6-of-the-ys-advent-calendar","title":"Welcome to Day 6 of the YS Advent Calendar","text":"<p>YS has these 3 modes:</p> <ul> <li>Code Mode</li> </ul> <p>A starting <code>!YS-v0</code> tag puts the YS file into Code Mode.   Unquoted strings are code expressions which are further parsed into AST   forms.   A <code>!</code> tag can switch the mode to Data Mode.</p> <ul> <li>Data Mode</li> </ul> <p>A starting <code>!YS-v0:</code> tag puts the YS file into Data Mode.   Everything is the regular YAML data language that you are used to.   But a <code>!</code> tag can switch the mode to Code Mode.</p> <ul> <li>Bare Mode</li> </ul> <p>Without a magic starting <code>!yamlscript</code> tag, the YS file is in Bare Mode.   This is like Data Mode but you aren't allowed to ever switch to Code Mode.   This is the default mode for YS files, and the reason we can claim that   almost all existing YAML files are valid YS files.   Specifically all those that adhere to the JSON data model, which is almost   all YAML config files.</p> <p>The <code>ys</code> CLI tool will implicitly add a <code>!YS-v0</code> tag when you use the <code>--eval</code> (aka <code>-e</code>) option, unless you actually provide a tag yourself. This is simply for convenience when you are testing out code snippets.</p> <p>Note that you can use multiple <code>-e</code> options and each one acts like a separate line of code in a file.</p> <p>So <code>ys -e 'say: \"Hello\"' -e 'say: \"World\"'</code> is the same as this YS program:</p> <pre><code>!YS-v0\nsay: \"Hello\"\nsay: \"World\"\n</code></pre> <p>If you wanted to write a <code>ys</code> one-liner that used Data Mode, you could do this: <code>ys --load -e '!YS-v0:' -e 'foo: 111' -e 'bar: 222'</code> which is the same as this YS program:</p> <pre><code>!YS-v0:\nfoo: 111\nbar: 222\n</code></pre> <p>If you wanted to write a <code>ys</code> one-liner that used Bare Mode, you could do this: <code>ys --load -e '!YS-v0' -e '--- !bare' -e 'foo: 111' -e 'bar: 222'</code> which is the same as the Data Mode example above.</p> <p>There's actually a better way to write Data and Bare Mode one-liners. The <code>ys</code> command has a <code>--mode</code> (aka <code>-m</code>) option that lets you set the mode to <code>code</code> (<code>c</code>), <code>data</code> (<code>d</code>) or <code>bare</code> (<code>b</code>).</p> <p>Thus the last one liner could be written as: <code>ys -mb -l -e 'foo: 111' -e 'bar: 222'</code>.</p> <p>Note</p> <p>The <code>-m</code> option only works with the <code>-e</code> option. You can't use it to change the mode of a file that you are loading or running.</p>"},{"location":"blog/2023-12-06/modes-of-transportation/#switching-modes","title":"Switching Modes","text":"<p>In YAML tags are words that start with <code>!</code>. They are instructions to the YAML loader (specifically to the constructor phase) about what exactly to construct.</p> <p>It's quite rare to see a YAML tag in the wild. But here's something you probably didn't know... Every untagged node in an internal YAML loader tree is implicitly assigned a tag. This process (of a YAML loader) is called \"tag resolution\". This is how the unquoted string <code>123</code> becomes the integer <code>123</code>. It is implicitly tagged with <code>!!int</code>, which happens to be shorthand for <code>tag:yaml.org,2002:int</code>.</p> <p>All YAML loaders understand the set of <code>yaml.org,2002</code> tags: <code>!!map</code>, <code>!!seq</code>, <code>!!str</code>, etc. In fact you are free to use these tags in YS programs, even in Bare Mode. But there is really no good reason to do so.</p> <p>The <code>!</code> tag is a valid YAML tag, but it is special in YS. It switches between Code Mode and Data Mode.</p> <p>If you think <code>!</code> looks weird, there is another cleaner looking way to switch from Code Mode to Data Mode.</p> <p>You can use <code>::</code> instead of <code>:</code> to separate the key and value of a mapping.</p> <pre><code>!YS-v0\nmy-map =::\n  foo = 111\n  bar = 222\n</code></pre> <p>is the same as:</p> <pre><code>!YS-v0\nmy-map =: !\n  foo: 111\n  bar: 222\n</code></pre> <p>At this point you can't do the same thing to switch from Data Mode to Code Mode.</p> <p>Well that concludes our coverage of YS a la Mode! Mmmm... Now doesn't that just sound delicious? (or at least fashionable!)</p> <p>I'll see you tomorrow for day 7 of YS Advent 2023!</p>"},{"location":"blog/2023-12-07/sharpen-your-tools/","title":"Sharpen Your Tools","text":"<p>Wanna make some fun toys with YS? You'll need some sharp tools. You think those elves make all those toys with dull tools?</p> <p>The CLI tool <code>ys</code> is the main tool you'll use to work with YS. Today we'll learn about all the things you can do with it.</p>"},{"location":"blog/2023-12-07/sharpen-your-tools/#welcome-to-day-7-of-the-ys-advent-calendar","title":"Welcome to Day 7 of the YS Advent Calendar","text":"<p>On Tuesday you learned how to install YS. Reminder, here's the quick way to install the latest version:</p> <pre><code>$ curl https://yamlscript.org/install | PREFIX=~/.ys bash\n$ export PATH=$HOME/.ys/bin:$PATH\n$ ys --version\nYS (YAMLScript) v0.1.96\n</code></pre> <p>The best first command to run is <code>ys --help</code>:</p> <pre><code>$ ys --help\n\nys - The YS Command Line Tool - v0.1.96\n\nUsage: ys [&lt;option...&gt;] [&lt;file&gt;]\n\nOptions:\n\n  -l, --load               Output (compact) JSON of YS evaluation\n  -e, --eval YSEXPR        Evaluate a YS expression\n                           multiple -e values joined by newline\n\n  -c, --compile            Compile YS to Clojure\n  -b, --binary             Compile to a native binary executable\n\n  -p, --print              Print the result of --run in code mode\n  -o, --output FILE        Output file for --load, --compile or --binary\n\n  -T, --to FORMAT          Output format for --load:\n                             json, yaml, edn\n  -J, --json               Output (pretty) JSON for --load\n  -Y, --yaml               Output YAML for --load\n  -E, --edn                Output EDN for --load\n  -U, --unordered          Mappings don't preserve key order (faster)\n\n  -m, --mode MODE          Add a mode tag: code, data, or bare (for -e)\n  -C, --clojure            Treat input as Clojure code\n\n  -d                       Debug all compilation stages\n  -D, --debug-stage STAGE  Debug a specific compilation stage:\n                             parse, compose, resolve, build,\n                             transform, construct, print\n                           can be used multiple times\n  -S, --stack-trace        Print full stack trace for errors\n  -x, --xtrace             Print each expression before evaluation\n\n      --install            Install the libyamlscript shared library\n      --upgrade            Upgrade both ys and libyamlscript\n\n      --version            Print version and exit\n  -h, --help               Print this help and exit\n</code></pre>"},{"location":"blog/2023-12-07/sharpen-your-tools/#ready-set-actions","title":"Ready, set, actions!","text":"<p>The first thing to notice is that <code>ys</code> has 3 \"actions\":</p> <ul> <li>Run (default) - Compile and evaluate a YS file</li> <li><code>--load</code> - Output the evaluated YS value as JSON (by default)</li> <li><code>--compile</code> - Compile YS code to Clojure code</li> </ul> <p>For each action you'll need some YS source code. This can come from 3 different places:</p> <ul> <li>The <code>--eval</code> (<code>-e</code>) option - specifies a line of YS code.   You can use this option multiple times to specify multiple lines of code.</li> <li>A file path - specify a path to a file containing YS code.</li> <li>Standard input - specify <code>-</code> as the file path to read YS code from standard   input.   If no file or <code>-e</code> options are specified, <code>ys</code> will check to see if there is   data on stdin.   That means you can leave off the <code>-</code> and pipe data into <code>ys</code> like this:   <code>echo $'!YS-v0\\nsay: \"Hello\"' | ys</code>.   Of course, it doesn't hurt to specify the <code>-</code> anyway.</li> </ul>"},{"location":"blog/2023-12-07/sharpen-your-tools/#running-clojure-with-ys","title":"Running Clojure  with <code>ys</code>","text":"<p>Clojure code is often valid YS code:</p> <pre><code>$ ys --compile -e '(println (+ 1 2))'\n(println (+ 1 2))\n</code></pre> <p>This YS compiles to the exact same Clojure code.</p> <p>If you want the code you run to be considered to be Clojure code (thus not compiled by the yamlscript compiler), you can use the <code>--clj</code> (<code>-C</code>) option. This is useful when you want to test out the YS runtime envronment directly with Clojure code.</p> <p>Also you can pipe the output of <code>ys --compile</code> to <code>ys --clj</code> to run the compiler's Clojure code ouput:</p> <pre><code>$ ys -c -e 'say: 123' | ys -C -\n</code></pre>"},{"location":"blog/2023-12-07/sharpen-your-tools/#modes-and-formats","title":"Modes and Formats","text":"<p>We learned about modes and the <code>--mode</code> option yesterday. You can set the mode for <code>--eval</code> (<code>-e</code>) code with the <code>--mode</code> (<code>-m</code>) option. The accepted values are <code>code</code> (<code>c</code>), <code>data</code> (<code>d</code>) and <code>bare</code> (<code>b</code>).</p> <p>When you \"load\" YS using <code>--load</code> you get the result printed to stdout as JSON. These are 3 formatting options to control how the output is displayed:</p> <ul> <li><code>--json</code> (<code>-J</code>) - Output JSON (default)   Note that this JSON is a bit more nicely formatted than the default output.</li> <li><code>--yaml</code> (<code>-Y</code>) - Output YAML</li> <li><code>--edn</code> (<code>-E</code>) - Output EDN. EDN is Clojure's native data format.   It is also valid Clojure code.</li> </ul> <p>Note that when you specify a formatting option, it implies the <code>--load</code> action.</p>"},{"location":"blog/2023-12-07/sharpen-your-tools/#debugging","title":"Debugging","text":"<p>When you \"run\" a YS program it doesn't print anything unless you use a printing command. This isn't surprising; all languages work this way.</p> <p>Sometimes you want to know what the final value of the run was. To get this you could print it with <code>say.</code> You can also use the special <code>--print</code> (<code>-p</code>) option, which does exactly that (with less typing)..</p> <p>Finally there a 3 special debugging options:</p> <ul> <li><code>--stack-trace</code> (<code>-S</code>) - Print a full stack trace for errors (more info)</li> <li><code>--debug-stage</code> (<code>-D</code>) - Display the result of a stage/stages</li> <li><code>-d</code> - Short for <code>--debug-stage=all</code> - Display the result of all stages</li> </ul> <p>The <code>--debug-stage</code> option is super useful for understanding exactly how YS code compiles to Clojure code.</p> <p>For example, to see the internal AST when compiling some YS:</p> <pre><code>$ ys -c -e 'say: \"Hello\"' -Dconstruct\n*** construct output ***\n{:Lst [{:Sym say} {:Str \"Hello\"}]}\n\n(say \"Hello\")\n</code></pre> <p>And to see all 7 compilation stages:</p> <pre><code>$ ys -c -e 'say: \"Hello\"' -d\n*** parse     *** 0.181519 ms\n({:+ \"+MAP\", :! \"YS-v0\"}\n {:+ \"=VAL\", := \"say\"}\n {:+ \"=VAL\", :$ \"Hello\"}\n {:+ \"-MAP\"}\n {:+ \"-DOC\"})\n\n*** compose   *** 0.005334 ms\n{:! \"YS-v0\", :% [{:= \"say\"} {:$ \"Hello\"}]}\n\n*** resolve   *** 0.055135 ms\n{:pairs [{:exp \"say\"} {:vstr \"Hello\"}]}\n\n*** build     *** 0.102548 ms\n{:pairs [{:Sym say} {:Str \"Hello\"}]}\n\n*** transform *** 0.014468 ms\n{:pairs [{:Sym say} {:Str \"Hello\"}]}\n\n*** construct *** 0.048013 ms\n{:Top [{:Lst [{:Sym say} {:Str \"Hello\"}]}]}\n\n*** print     *** 0.006561 ms\n\"(say \\\"Hello\\\")\"\n\n(say \"Hello\")\n</code></pre> <p>We'll go over all of these stages in detail in a future post.</p> <p>In the meantime, try out your new <code>ys</code> tool and see what you can do with it. The more you use it, the sharper it will get.</p> <p>I'll see you tomorrow for day 8 of YS Advent 2023!</p>"},{"location":"blog/2023-12-08/going-to-the-library/","title":"Going to the Library","text":"<p>Programming in YS is as easy as reading a book. The only thing you really need is some good books! For that let's go to the library.</p> <p>By books of course I mean YS functions. And by library I mean the YS Standard Library! There you'll find all-time best sellers like <code>map</code>, <code>filter</code>, <code>reduce</code> and <code>say</code>.</p> <p>And Standard isn't the only Library in town...</p>"},{"location":"blog/2023-12-08/going-to-the-library/#welcome-to-day-8-of-the-ys-advent-calendar","title":"Welcome to Day 8 of the YS Advent Calendar","text":"<p>In our YS programming so far, we've been using various functions like <code>say</code>, <code>take</code>, <code>keys</code>, <code>join</code> and <code>map</code>. Also we've been using various operators like <code>+</code>, <code>*</code>, <code>=&gt;</code> and <code>..</code>. Operators are just functions with names made out of punctuation characters.</p> <p>Where do these functions come from? Are they built into the YS language?</p> <p>Nope. They all come from the Library!</p> Libraries and Namespaces  It's probably a good idea to explain what a Clojure library is. And we should probably talk about namespaces too. Don't worry, it's quite simple.  A library is a file that contains a namespace and a bunch of functions (who belong to that library/namespace). The namespace name is made up of 2 or more words separated by the `.` character. The name corresponds to the file path of the library.  For example (in Clojure) the `foo.bar` library would contain a `foo.bar` namespace and be located at `foo/bar.clj` in your Java classpath. To access a function called `thinger` in `foo.bar`, you would use the fully qualified name (aka a Clojure symbol) `foo.bar/thinger`.  YS is the same except:  * File names end with `.ys` * The 2 or more words are separated by `::` instead of `.` * A fully qualified symbol looks like `foo::bar.thinger`.   * You'll find out later why this is really cool   <p>The YS runtime has several libraries that are always available. The two primary ones are <code>clojure::core</code> and <code>ys::std</code>.</p> <p>The <code>clojure::core</code> library is what YS calls Clojure's famous <code>clojure.core</code> library. In Clojure (and thus YS!) <code>clojure.core</code> is the heart and soul of the language. It's where all the Good Parts live. All of the functions (and macros) that you use constantly in your day-to-day programming.</p> <p>How many publicly accessible functions does <code>clojure::core</code> give you? 581!!</p> <p>How do I know that? YS just told me so:</p> <pre><code>$ ys -pe '-&gt;(clojure::core quote find-ns ns-publics count)'\n581\n</code></pre> <p>That's a lot of functions!</p> Why not 671?  Honestly it's not as many as the real `clojure.core` library called from Clojure.  <pre><code>$ clojure -M -e '(-&gt; clojure.core quote ns-publics count)'\n671\n</code></pre>  The reason for this is because YS uses a special version of Clojure the [SCI](https://github.com/babashka/sci) (Small Clojure Interpreter).  SCI offers a subset of Clojure's functionality, but it's a very useful subset. It's also a \"safe\" subset.  I don't think you'll run into anything that's not available in your day to day YS coding. If you do, give me a ring and we'll see what we can do to get it added.  <p>The <code>clojure.core</code> library is very well documented so we won't talk about it more right now.</p> <p>Let's discuss the other one I mentioned, <code>ys::std</code>. This is the YS Standard Library. It's where you'll find functions that make YS nicer to work with. The <code>say</code> function that shows up constantly is defined as <code>ys::std.say</code>.</p> <p>How many functions does it offer?</p> <pre><code>$ YS -pe '-&gt;(ys::std quote find-ns ns-publics count)'\n17\n</code></pre> <p>Not that many yet, but it is still being actively defined.</p> <p>Here's a few of them:</p> <ul> <li><code>say</code> - A shorter way to say <code>println</code></li> <li><code>warn</code> - Like <code>say</code> but prints to stderr</li> <li><code>load</code> - Load an external YS file</li> <li><code>=&gt;</code> - <code>=&gt;: 123</code> or <code>(=&gt; 123)</code> compiles to <code>123</code></li> <li><code>pretty</code> - Pretty formats a data structure (without printing it)</li> <li><code>toInt</code>, <code>toStr</code>, <code>toBool</code> etc casting functions (Integer, String, Boolean)</li> <li><code>_+</code> and <code>_*</code> - The polymorphic versions of <code>+</code> and <code>*</code> infix operators</li> </ul> <p>The <code>ys::std</code> library will certainly grow over time. Functions is this library use names that are not used by <code>clojure.core</code> functions.</p>"},{"location":"blog/2023-12-08/going-to-the-library/#other-ys-libraries","title":"Other <code>ys::</code> Libraries","text":"<p>There are currently several other <code>ys::</code> libraries that are always available. Here are a few of them:</p> <ul> <li><code>ys::yaml</code> - YAML <code>load</code> and <code>dump</code> functions</li> <li><code>ys::json</code> - JSON <code>load</code> and <code>dump</code> functions</li> <li><code>ys::ys</code> - <code>compile</code>, <code>eval</code> and <code>load</code> YS from within YS!</li> <li><code>ys::clj</code> - Clojure core functions replaced by YS ones</li> <li><code>ys::taptest</code> - A TAP-based testing library</li> </ul> <p>For fun let's write a silly YS program that uses them.</p> <p>Let's call it <code>silly.ys</code>:</p> <pre><code>#!/usr/bin/env ys-0\n\nmy-yaml =: |\n  - Hello\n  - Salutations\n  - Ho Ho Ho\n  - Merry Christmas\n  - Happy Holidays\n  - Seasons Greetings\n  - Happy New Year\n  - Happy Hanukkah\n  - Happy Kwanzaa\n\nmy-json =: |\n  [ \"World\",\n    \"Santa\",\n    \"Elves\",\n    \"Reindeer\",\n    \"Snowman\",\n    \"Mrs. Claus\",\n    \"Rudolph\",\n    \"Frosty\",\n    \"Kids\" ]\n\ngreets =: yaml/load(my-yaml)\n\nnames =: json/load(my-json)\n\nsay: \"$rand-nth(greets), $rand-nth(names)!!\"\n</code></pre> <p>Now let's run it a few times:</p> <pre><code>$ for x in {1..10}; do ys silly.ys; done\nHappy Holidays, Kids!!\nHello, World!!\nHappy New Year, World!!\nHello, Rudolph!!\nSalutations, Santa!!\nSalutations, Mrs. Claus!!\nHappy Hanukkah, Mrs. Claus!!\nMerry Christmas, Santa!!\nHo Ho Ho, Rudolph!!\nHello, Elves!!\n</code></pre> <p>That's a lot of fun! We wrote a program in YAML to play with some YAML that was inside the YAML!</p> <p>I hope you're starting to see the power of YS, and I hope you have a wonderful day.</p> <p>Full disclosure: I'm stuck in the Winnipeg airport, writing this and hacking on YS because my flight's toilets stopped working and they decided to land here for the night.</p> <p>True story.</p> <p>Tune in tomorrow for Day 9 of the YS Advent Calendar.</p>"},{"location":"blog/2023-12-09/coding-with-style/","title":"Coding with Style","text":"<p>What's the best thing about Rudolph's nose? Is it that lights the way for Santa's sleigh? I'm calling BS on that. I'd say it's the main thing that gives the whole Sanata Story some Serious Style!</p> <p>Good programmers do more than just get their solutions right. They do the whole thing with style. That makes the program easier to read, understand and maintain. It also gives the code a certain je ne sais quoi.</p>"},{"location":"blog/2023-12-09/coding-with-style/#welcome-to-day-9-of-the-ys-advent-calendar","title":"Welcome to Day 9 of the YS Advent Calendar","text":"<p>We know that YS compiles to Clojure. And we know that YAML doesn't really look anything like a Lisp. But it turns out that YS can use as much or as little Lisp style as you want it to. It's all about your personal style.</p> <p>Here's a YS program that sings my favorite drinking song:</p> <pre><code>#!/usr/bin/env ys-0\n# 99-bottles.ys\n\n# Print the verses to \"99 Bottles of Beer\"\n#\n# usage:\n#   ys 99-bottles.ys [&lt;count&gt;]\n\ndefn main(number=99):\n  each n (number .. 1):\n    say: paragraph(n)\n\ndefn paragraph(num): |\n  $bottles(num) of beer on the wall,\n  $bottles(num) of beer.\n  Take one down, pass it around.\n  $bottles(num - 1) of beer on the wall.\n\ndefn bottles(n):\n  cond:\n    n == 0 : 'No more bottles'\n    n == 1 : '1 bottle'\n    else   : \"$n bottles\"\n</code></pre> <p>Let's give it a try:</p> <pre><code>$ ys 99-bottles.ys 3\n3 bottles of beer on the wall,\n3 bottles of beer.\nTake one down, pass it around.\n2 bottles of beer on the wall.\n\n2 bottles of beer on the wall,\n2 bottles of beer.\nTake one down, pass it around.\n1 bottle of beer on the wall.\n\n1 bottle of beer on the wall,\n1 bottle of beer.\nTake one down, pass it around.\nNo more bottles of beer on the wall.\n</code></pre> <p>I feel tipsy.</p> <p>Let's compile this program to Clojure and see what it looks like:</p> <pre><code>$ ys -c 99-bottles.ys\n(declare paragraph bottles)\n(defn main\n  ([number] (each [n (rng number 1)] (say (paragraph n))))\n  ([] (main 99)))\n(defn paragraph [num]\n  (str (bottles num)\n       \" of beer on the wall,\\n\" (bottles num)\n       \" of beer.\\nTake one down, pass it around.\\n\" (bottles (- num 1))\n       \" of beer on the wall.\" \"\\n\"))\n(defn bottles [n]\n  (cond (= n 0) \"No more bottles\"\n        (= n 1) \"1 bottle\"\n        :else (str n \" bottles\")))\n(apply main ARGS)\n</code></pre> <p>It turns out that the compiled Clojure code is actually valid YS syntax as well. Well, almost.</p> <p>The file is valid YAML. It represents a single big string. Normally YAML files represent a single big mapping or sequence, but they can also define a top level scalar (string).</p> <p>If I run this program though, it doesn't print anything. The reason is simple. We didn't give it the power to. We didn't add the <code>!YS-v0</code> tag to the beginning of the file.</p> <p>If we do that it works fine.</p> <p>So apparently we can write YS in a purely Lisp style. The truth is you can write YS is a completely YAML style (no parens), a completely Lisp style (all parens), or somewhere in between.</p> <p>Good looking YS programs start with YAML style and then switch to the Lisp style for certain nicer idioms. Note that you can't switch back to YAML style once you've switched to Lisp style.</p> <p>Let's iterate on the above code and make it YAML just at the top level:</p> <pre><code>defn main:\n  ([number] (each [n (rng number 1)] (say (paragraph n))))\n  ([] (main 99))\ndefn paragraph [num]:\n  (str (bottles num)\n       \" of beer on the wall,\\n\" (bottles num)\n       \" of beer.\\nTake one down, pass it around.\\n\" (bottles (- num 1))\n       \" of beer on the wall.\" \"\\n\")\ndefn bottles [n]:\n  (cond (= n 0) \"No more bottles\"\n        (= n 1) \"1 bottle\"\n        :else (str n \" bottles\"))\napply: main ARGS\n</code></pre> <p>That already looks a lot better.</p> <p>We get a big win turning the <code>paragraph</code> into a YAML literal scalar (heredoc) with string interpolation.</p> <pre><code>defn paragraph(num): |\n  $bottles(num) of beer on the wall,\n  $bottles(num) of beer.\n  Take one down, pass it around.\n  $bottles(num - 1) of beer on the wall.\n</code></pre> <p>That's so much easier to read and understand.</p> <p>I hope you are inspired to write some beautiful YS code.</p> <p>You've got style, baby!</p> <p>Come back tomorrow for day 10 of the YS Advent Calendar.</p>"},{"location":"blog/2023-12-10/states-and-ladders/","title":"States and Ladders","text":"<p>Santa is a busy guy. He has a lot of work to do. He has to make a list and check it twice. He has to find out who's naughty and nice. He has the monumental task of transforming wishes into happiness.</p> <p>YS only needs to transform YS code into Clojure code. But it's a bit more involved than you might think.</p> <p>To make things easier the YS compiler breaks the transformation into eight distinct States and seven distinct ~~Ladders~~ transformations.</p>"},{"location":"blog/2023-12-10/states-and-ladders/#welcome-to-day-10-of-the-ys-advent-calendar","title":"Welcome to Day 10 of the YS Advent Calendar","text":"<p>Today we're going to learn more exactly how <code>ys --compile</code> turns YS into Clojure. Fair Warning: This is going to be a long post.</p> <p>The <code>ys</code> CLI has an awesome tool to visualize the transformation process any time you are interested. This might be for debugging where something went wrong, or just to learn more about how the compiler works.</p> <p>To begin this journey, let's use this visualizer in action. You could write it like this:</p> <pre><code>ys --compile --debug-stage=all -e 'name =: \"Clojure\"' -e 'say: \"Hello, $name!\"'\n</code></pre> <p>The one line program is equivalent to the file containing:</p> <pre><code>!YS-v0\nname =: \"Clojure\"\nsay: \"Hello, $name!\"\n</code></pre> <p>Let's run the command now (but we'll use the shorter options):</p> <pre><code>$ ys -c -e 'name =: \"Clojure\"' -e 'say: \"Hello, $name!\"' -d\n*** parse     *** 0.127737 ms\n({:+ \"+MAP\", :! \"YS-v0\"}\n {:+ \"=VAL\", := \"name =\"}\n {:+ \"=VAL\", :$ \"Clojure\"}\n {:+ \"=VAL\", := \"say\"}\n {:+ \"=VAL\", :$ \"Hello, $name!\"}\n {:+ \"-MAP\"}\n {:+ \"-DOC\"})\n\n*** compose   *** 0.009495 ms\n{:! \"YS-v0\",\n :% [{:= \"name =\"} {:$ \"Clojure\"} {:= \"say\"} {:$ \"Hello, $name!\"}]}\n\n*** resolve   *** 0.073969 ms\n{:pairs\n [{:def \"name =\"}\n  {:vstr \"Clojure\"}\n  {:exp \"say\"}\n  {:vstr \"Hello, $name!\"}]}\n\n*** build     *** 0.375378 ms\n{:pairs\n [[{:Sym def} {:Sym name}]\n  {:Str \"Clojure\"}\n  {:Sym say}\n  {:Lst [{:Sym str} {:Str \"Hello, \"} {:Sym name} {:Str \"!\"}]}]}\n\n*** transform *** 0.027342 ms\n{:pairs\n [[{:Sym def} {:Sym name}]\n  {:Str \"Clojure\"}\n  {:Sym say}\n  {:Lst [{:Sym str} {:Str \"Hello, \"} {:Sym name} {:Str \"!\"}]}]}\n\n*** construct *** 0.087933 ms\n{:Top\n [{:Lst [{:Sym def} {:Sym name} {:Str \"Clojure\"}]}\n  {:Lst\n   [{:Sym say}\n    {:Lst [{:Sym str} {:Str \"Hello, \"} {:Sym name} {:Str \"!\"}]}]}]}\n\n*** print     *** 0.014494 ms\n\"(def name \\\"Clojure\\\")(say (str \\\"Hello, \\\" name \\\"!\\\"))\"\n\n(def name \"Clojure\")\n(say (str \"Hello, \" name \"!\"))\n</code></pre> <p>Woah! That's a lot of output. But it's exactly what I want to tell you about today.</p> <p>At the bottom is the clojure code we expect. Above that is the output of each of the seven transformations (aka the 7 states that come after the first state: our YS input).</p> <p>Let's look at each of these transformations in turn...</p>"},{"location":"blog/2023-12-10/states-and-ladders/#transformation-1-parse","title":"Transformation 1: Parse","text":"<p>The first transformation is parsing YAML into a sequence of \"parse events\". This is by far the hardest transformation, not just for YS but for any YAML processor. Sadly, it's so hard that only a few of the dozens of YAML processors out there actually do it correctly. See: https://matrix.yaml.info/\u00a0 </p> <p>On the other hand, this is actually the simplest part for the YS compiler to implement. Why? Because it uses somebody else's YAML parser!!</p> <p>Note</p> <p>YS currently uses the SnakeYAML Engine\u00a0  framework (only for it's YAML 1.2 parser component). Later we plan to use libfyaml\u00a0  which is currently considered the best YAML parser in the world. SnakeYAML was the obvious first choice because it's written in Java, YS is written in Clojure and Clojure is a JVM language. It's doing a great job for now!</p> <p>This is a good time to mention that the YAML data language spec describes \"loading\" YAML text into native data structures as a several step process of states and transformations. In reality, the YS compiler is really just a very fancy YAML loader!</p> <p>YAML parsers typically produce 10 different kinds of parse events:</p> <ul> <li>Start Stream</li> <li>End Stream</li> <li>Start Document</li> <li>End Document</li> <li>Start Sequence</li> <li>End Sequence</li> <li>Start Mapping</li> <li>End Mapping</li> <li>Scalar Value</li> <li>Alias Reference</li> </ul> <p>YS (currently) doesn't care about the first 4 events, so it just ignores them.</p> <p>That leaves use with a mapping containing 2 key/value pairs:</p> <pre><code>[{:+ \"+MAP\", :! \"YS-v0\"}\n {:+ \"=VAL\", := \"name =\"}\n {:+ \"=VAL\", :$ \"Clojure\"}\n {:+ \"=VAL\", := \"say\"}\n {:+ \"=VAL\", :$ \"Hello, $name!\"}\n {:+ \"-MAP\"}]\n</code></pre> <p>We are showing this state as a Clojure data structure and that's the kind of serialization that we use in the YS compiler tests.</p> <p>Here's a quick breakdown of the mapping keywords used above:</p> <ul> <li><code>:+</code> is the parse event type</li> <li><code>:!</code> is the (optional) YAML tag</li> <li><code>:=</code> is a plain (unquoted) scalar value</li> <li><code>:$</code> is a double quoted scalar value</li> </ul> <p>That was a lot of info, but hopefully it sets the stage for the rest of this post.</p> <p>If you are interested in seeing how all this is implemented, check out:</p> <ul> <li>All the YS transformation libraries source code\u00a0 </li> <li>The YS Test Suite Files:</li> <li>https://github.com/yaml/yamlscript/blob/main/core/test/compiler-stack.yaml\u00a0 </li> <li>https://github.com/yaml/yamlscript/blob/main/core/test/compiler.yaml\u00a0 </li> </ul>"},{"location":"blog/2023-12-10/states-and-ladders/#transformation-2-compose","title":"Transformation 2: Compose","text":"<p>The second transformer is called the composer (in the <code>yamlscript.composer</code> library).</p> <pre><code>{:! \"YS-v0\",\n :% [{:= \"name =\"} {:$ \"Clojure\"} {:= \"say\"} {:$ \"Hello, $name!\"}]}\n</code></pre> <p>Its simple job is to take the parse events and compose them into a tree of mapping, sequence and scalar nodes.</p> <p>It preserves the node's tag if any.</p> <p>Here we see a new keyword <code>:%</code> which is used for a mapping node. Sequence nodes use the keyword <code>:-</code> but they only show up in data mode, which we aren't using here.</p> <p>Now we have all the important information from the YAML input in an AST form that we can refine (transform) a few more times until it becomes a Clojure AST!</p>"},{"location":"blog/2023-12-10/states-and-ladders/#transformation-3-resolve","title":"Transformation 3: Resolve","text":"<p>YAML tags are rarely seen in the wild. Many YAML users don't even know they exist. But tags play an important role in the YAML load process. Internally every single untagged node is assigned a tag based on heuristics that consider its kind, position and content.</p> <p>This process is called \"tag resolution\" and it's what we are doing here:</p> <pre><code>{:ysm\n [{:ysx \"def name\"}\n  {:ysi \"Clojure\"}\n  {:ysx \"say\"}\n  {:ysi \"Hello, $name!\"}]}\n</code></pre> <p>Notice that all the keywords changed to <code>:ys?</code> here. This is how YS stores the tag. Each tag knows what kind of node it is attached to (map, seq or scalar) so, to keep things simple, it doesn't store that info in the AST.</p> <p>Note</p> <p>Keeping the structure of each state AST as simple as possible is a key concern of the YS compiler. It makes it easier to see what's going on when debugging and even more importantly, it makes it easier to write tests for each transformation.</p> <p>The keywords seen above are:</p> <ul> <li><code>:ysm</code> is a code mode mapping node</li> <li><code>:ysi</code> is a scalar that supports interpolation</li> <li><code>:ysx</code> is a ys expression (a string of code to be further parsed)</li> </ul> <p>Tags are are essentially the names of the transformations that will be applied to the node in the following transformation.</p>"},{"location":"blog/2023-12-10/states-and-ladders/#transformation-4-build","title":"Transformation 4: Build","text":"<p>The build transformation is where a lot of the magic happens.</p> <p>Most importantly, it's where scalars containing YS expressions are lexed and parsed into Clojure expression ASTs.</p> <pre><code>{:ysm\n ([{:Sym def} {:Sym name}]\n  {:Str \"Clojure\"}\n  {:Sym say}\n  {:Lst [{:Sym str} {:Str \"Hello, \"} {:Sym name} {:Str \"!\"}]})}\n</code></pre> <p>For instance we can see that the simple string expression \"def name\" was parsed into 2 Clojure symbol nodes: <code>{:Sym def}</code> and <code>{:Sym name}</code>.</p> <p>We can also see that the string expression \"Hello, $name!\" was parsed into a an interpolated string expression that joins string literals and variable values into a single string.</p> <p>One important aspect of the build output AST is that it retains the original structure of the YAML input. Mappings still have key/value pairs, and the key info stays separate from the value info.</p>"},{"location":"blog/2023-12-10/states-and-ladders/#transformation-5-transform","title":"Transformation 5: Transform","text":"<p>The transformer transformation (that's a bit awkward I'll admit) is where \"special cases\" are handled.</p> <p>Not much happens in this stage yet. In fact nothing at all happened in this example.</p> <pre><code>{:ysm\n [[{:Sym def} {:Sym name}]\n  {:Str \"Clojure\"}\n  {:Sym say}\n  {:Lst [{:Sym str} {:Str \"Hello, \"} {:Sym name} {:Str \"!\"}]}]}\n</code></pre> <p>It's exactly the same as the build output.</p> <p>In the future, the transform stage is where we will add support for letting users defined their own syntax and semantic transformations for specific functions. If you know about Lisp macros, this will be something spiritually similar.</p> <p>If you happen to think a particular function should be coded a specific way, you'll be able to make it so. As long as you don't break the rules of physics... or YAML!</p> <p>Note that even though this transformation can change the AST quite a bit, it still retains its overall YAML structure.</p>"},{"location":"blog/2023-12-10/states-and-ladders/#transformation-6-construct","title":"Transformation 6: Construct","text":"<p>The constructor phase's job is simple. Turn the final YAML structured AST into an AST that directly represents the intended Clojure code compilation result.</p> <p>It does this essentially by applying the function asscoiated with a node's tag to the node's value.</p> <pre><code>{:Lst\n [{:Sym do}\n  {:Lst [{:Sym def} {:Sym name} {:Str \"Clojure\"}]}\n  {:Lst\n   [{:Sym say}\n    {:Lst [{:Sym str} {:Str \"Hello, \"} {:Sym name} {:Str \"!\"}]}]}]}\n</code></pre> <p>Every node in this AST directy represents a Clojure code construct. Voila!</p>"},{"location":"blog/2023-12-10/states-and-ladders/#transformation-7-print","title":"Transformation 7: Print","text":"<p>Just like in any Lisp, a Clojure AST \"prints\" directly to Clojure code. This is because every node in the AST is essentially a token that knows how to print itself!</p> <p>Again here's our final AST:</p> <pre><code>{:Lst\n [{:Sym do}\n  {:Lst [{:Sym def} {:Sym name} {:Str \"Clojure\"}]}\n  {:Lst\n   [{:Sym say}\n    {:Lst [{:Sym str} {:Str \"Hello, \"} {:Sym name} {:Str \"!\"}]}]}]}\n</code></pre> <p>The <code>yamlscript.printer/print</code> function converts that to this string (of Clojure code):</p> <pre><code>\"(def name \\\"Clojure\\\")\\n(say (str \\\"Hello, \\\" name \\\"!\\\"))\\n\"\n</code></pre> <p>When that string is printed out, it looks like this:</p> <pre><code>(def name \"Clojure\")\n(say (str \"Hello, \" name \"!\"))\n</code></pre> <p>Aaaand, we're done!</p>"},{"location":"blog/2023-12-10/states-and-ladders/#transformation-1-7-compile","title":"Transformation 1-7: Compile","text":"<p>The YS compiler is just all the above crammed together is sequence; passing YS input through the 7 transformations we just described.</p> <p>I'd like to show you the actual YS <code>compile</code> function (written in Clojure):</p> <pre><code>(defn compile\n  \"Convert YS code string to an equivalent Clojure code string.\"\n  [^String yamlscript-string]\n  (-&gt;&gt; yamlscript-string\n    yamlscript.parser/parse\n    yamlscript.composer/compose\n    yamlscript.resolver/resolve\n    yamlscript.builder/build\n    yamlscript.transformer/transform\n    yamlscript.constructor/construct\n    yamlscript.printer/print))\n</code></pre> <p>Pretty straightforward, right? Or if you are more familiar with YS than Clojure:</p> <pre><code>defn compile(yamlscript-string):\n  \"Convert YS code string to an equivalent Clojure code string.\":\n  -&gt;&gt;:\n    yamlscript-string\n    yamlscript::parser/parse\n    yamlscript::composer/compose\n    yamlscript::resolver/resolve\n    yamlscript::builder/build\n    yamlscript::transformer/transform\n    yamlscript::constructor/construct\n    yamlscript::printer/print\n</code></pre> <p>I hope I didn't waste too much of your Sunday on this post. I know it was a lot to take in, and I also know you don't need to know all this to be a good YS programmer.</p> <p>But then again, you probably want to know all about this to become a great one!</p> <p>See you tomorrow for Day 11 of the YS Advent Calendar.</p>"},{"location":"blog/2023-12-11/the-yes-express/","title":"The YeS Express","text":"<p>Santa's got a lot of ground to cover in a short amount of time. He doesn't have time to deal with confusing maps and directions.</p> <p>Lisp has other-worldly powers of abstraction, but when it comes to reading syntax, most people prefer the familiarity of this world.</p> <p>YS fully embraces all that Clojure has to offer, but syntax-wise it also offers a more familiar face.</p>"},{"location":"blog/2023-12-11/the-yes-express/#welcome-to-day-11-of-the-ys-advent-calendar","title":"Welcome to Day 11 of the YS Advent Calendar!","text":"<p>Today we'll look at YS Expressions, aka YeS-Expressions. Lisp has S-Expressions, YS has YeS-Expressions!</p> <p>When writing YS instructions in \"code mode\" you are always working with 3 basic YAML elements:</p> <ul> <li>YAML Block Mappings - The indented style <code>key: value</code> pairs</li> <li>YAML Quoted Scalars - String literals</li> <li>YAML Plain Scalars - The unquoted <code>value</code> scalars</li> </ul> <p>YS treats all YAML plain scalars as YeS-Expressions (ysexprs).</p> <p>Let's look at some examples.</p>"},{"location":"blog/2023-12-11/the-yes-express/#infix-expressions","title":"Infix Expressions","text":"<pre><code>x =: (y * 2)\nz =: (x + 5 + y)\n</code></pre> <p>Compiles to Clojure (Lisp) like this:</p> <pre><code>(def x (* y 2))\n(def z (+ x 5 y))\n</code></pre> <p>YeS-Expressions support infix operators for very simple expressions. If you put exactly 3 forms in parentheses, and the second one is an operator, then the first and third forms are operands. The compiler will swap the first and second forms making it work like Lisp wants it to.</p> <p>If you have a parenthesized expression with more than 2 operands and the operators are all the same, then the compiler will make a Lisp form starting with the operator and followed by the operands.</p> <p>Note</p> <p>In rare cases in Lisp <code>(a + 1)</code> is valid when <code>a</code> is a function that takes two arguments, an operator function add a number in this case. There are ways to specifiy this in YS, but we won't cover them here.</p> <p>In simple cases where the infix expression is the only thing in the YAML scalar, you can omit the parentheses.</p> <pre><code>x =: y * 2\nz =: x + 5 + y\n</code></pre> <p>Note that YS has no support for operator precedence. You must use parentheses to group expressions and group operations in triplets.</p> <pre><code>x =: ((y * 2) + 5) / 2\n</code></pre>"},{"location":"blog/2023-12-11/the-yes-express/#prefix-expressions","title":"Prefix Expressions","text":"<p>In Lisp you might see a function call like this:</p> <pre><code>(abspath (join \"/\" [\"foo\" \"bar\"]))\n</code></pre> <p>Many non-Lisp languages would write this as:</p> <pre><code>abspath(join(\"/\", [\"foo\", \"bar\"]))\n</code></pre> <p>YS supports this style of function call as well.</p> <p>YS is very flexible about how you can write function calls. You could do the above in all the ways below:</p> <pre><code>path1 =: abspath(join(\"/\" [\"foo\" \"bar\"]))\npath2 =: (abspath (join \"/\" [\"foo\" \"bar\"]))\npath3 =:\n  abspath:\n    join \"/\": [\"foo\" \"bar\"]\n=&gt;: (def path4 abspath(join(\"/\" [\"foo\" \"bar\"])))\n</code></pre> <p>Look closely at the last example (<code>path4</code>). It looks like a Clojure form, but it actually makes use of prefix function calls.</p>"},{"location":"blog/2023-12-11/the-yes-express/#special-operators","title":"Special Operators","text":"<p>YS has a few special operators that are not part of Clojure.</p> <p>The <code>..</code> operator is used to create a range of consectutive integers. The expression <code>(1 .. 3)</code> is equivalent to the Clojure form <code>(range 1 4)</code> and evaluates to the list <code>(1 2 3)</code>. The expression <code>(3 .. 1)</code> is equivalent to the Clojure form <code>(range 3 0 -1)</code> and evaluates to the list <code>(3 2 1)</code>.</p> <p>The <code>+</code> and <code>*</code> operators are polymorphic.</p> <ul> <li><code>\"x\" * 3</code> -&gt; <code>\"xxx\"</code></li> <li><code>\"x\" + \"y\" + \"z\"</code> -&gt; <code>\"xyz\"</code></li> <li><code>{a: 1} + {b: 2}</code> -&gt; <code>{a: 1, b: 2}</code></li> <li><code>[1 2] + [3 4]</code> -&gt; <code>[1 2 3 4]</code></li> </ul>"},{"location":"blog/2023-12-11/the-yes-express/#special-thanks","title":"Special Thanks","text":"<p>I'd like to say thank you to David A. Wheeler for his web page Curly infix, Modern-expressions, and Sweet-expressions: A suite of readable formats for Lisp-like languages.</p> <p>I adapted many of those ideas to make YeS-Expressions.</p>"},{"location":"blog/2023-12-11/the-yes-express/#conclusion","title":"Conclusion","text":"<p>As I've said before, YS is very flexible, allowing you to decide how much Lisp or YAML style you want to use at any point. YeS-Expressions allow you to lean to the Lisp but keep it readable for your non-Lisper friends.</p> <p>Join me tomorrow for Day 12 of the YS Advent Calendar.</p>"},{"location":"blog/2023-12-12/future-proof/","title":"Future Proof","text":"<p>Santa has very little margin for error. He has to get everything just right all in one night.</p> <p>YS is a work in progress, and will be for a long time. I'm trying to get it right, but I'm no Santa! In fact I'm quite sure I'll get some things wrong. That's just the nature of the beast when you're a programmer.</p> <p>Also, have you ever wondered why the magic YS starter tag has that <code>/v0</code> at the end?</p>"},{"location":"blog/2023-12-12/future-proof/#welcome-to-day-12-of-the-ys-advent-calendar","title":"Welcome to Day 12 of the YS Advent Calendar!","text":"<p>Today we'll discuss how YS is designed to be future proof.</p> <p>I've been programming for quite a long time now. I've learned that no matter how good I think an idea it today, I'll almost certainly think of a better way to do it in the future.</p> <p>This means I'll almost certainly want to make big changes to YS long after it's in use in the real world.</p> <p>I also believe that it is really important for things like APIs and progamming languages to be stable and backwards compatible, basically forever.</p> <p>If I could always have the freedom to make big changes to YS, but never break backwards compatibility, then I could have my cake and eat it too. And I think I can!</p>"},{"location":"blog/2023-12-12/future-proof/#the-ys-api-version","title":"The YS API Version","text":"<p>I call <code>v0</code> the YS API version. YS v0 isn't done yet, but it should be in the next couple months. At that point I'll release it as a stable version of the API version <code>0</code>.</p> <p>So you've seen that to make a <code>.ys</code> file executable, you need to add a special starter tag to the top of the file:</p> <pre><code>--- !YS-v0\nsay: \"Hello!\"\n</code></pre> <p>Or you can write it with the shebang line:</p> <pre><code>#!/usr/bin/env ys-0\nsay: \"Hello!\"\n</code></pre> <p>Leaving off that <code>0</code> here will make things not work as you intended.</p> <p>You might also have noticed that when you install the <code>ys</code> binary CLI is is a symlink to <code>ys-0.1.26</code>. And there is another symlink called <code>ys-0</code> that points to <code>ys-0.1.26</code>.</p> <p>This is all by design.</p> <p>The leading <code>0</code> in <code>!YS-v0</code> and in <code>bin/ys-0</code> and also in <code>0.1.26</code> is the YS API version.</p> <p>When YS v0 is declared stable, there will never be changes that break backwards compatibility with the <code>v0</code> API version.</p> <p>That means you can write YS programs today, and they will continue to work forever, even if you upgrade to a new version of YS.</p>"},{"location":"blog/2023-12-12/future-proof/#new-versions-of-ys","title":"New Versions of YS","text":"<p>At some point after YS v0 is released as stable, I'll start working on YS v1.</p> <p>I can make any changes I want in YS v1, even ones that break backwards compatibility with YS v0. That's because I set up the rules such that you need to declare the version when you write a YS program.</p>"},{"location":"blog/2023-12-12/future-proof/#conclusion","title":"Conclusion","text":"<p>This doesn't mean that I don't think extremely carefully about every change I make to YS. But it does mean that I don't have to worry about everything being perfect before I release stable v0.</p> <p>That's exciting as I strive to make YS a great language today and a better language in the future.</p> <p>I hope that also encorages you write more YS today, knowing that it will continue to work in the future.</p> <p>That wraps up Day 12. And that also means we're half way through the Advent Calendar. I hope you're enjoying it as much as I am, and I hope the best is yet to come!</p> <p>Tune in tomorrow for Day 13 of the YS Advent Calendar.</p>"},{"location":"blog/2023-12-13/history-lesson/","title":"History Lesson","text":"<p>Santa is Legend. Legends have histories. The histories of Santa are many and varied, some going back to the 4th century AD.</p> <p>The history of YS is much shorter, but it's still a history. Today I'd like to tell you a little bit about it.</p>"},{"location":"blog/2023-12-13/history-lesson/#welcome-to-day-13-of-the-ys-advent-calendar","title":"Welcome to Day 13 of the YS Advent Calendar!","text":"<p>In the summer of 2022 I was gathering information about a computer system that I was learning about. I was putting the information into a YAML file. At first I thought to myself, this YAML file could essentially be a configuration file for running the system. Then I thought, what if I could run the system by just \"running\" the YAML file?</p> <p>Hmmmm... YAMLScript! For me a project can only be started when it has a name. I had the name, I loved the name, I loved the idea, I started the project!</p> <p>I put together a prototype as a Perl module and published it to CPAN. I knew that conceptually YS would be a Lisp, but to be honest I barely knew what a Lisp was.</p>"},{"location":"blog/2023-12-13/history-lesson/#one-true-yaml","title":"One True YAML","text":"<p>Earlier in the year I had come to the conclusion that the YAML spec and all of the YAML implementations were too hard to fix. I had spent the second half of 2021 trying to fix YAML, with a core group\u00a0  of five people, and it slowly became obvious that it was a lost cause. It was just too much work to get everyone to agree on anything, let alone everything.</p> <p>A possibly better solution was to create a new YAML framework (based on the current YAML 1.2 spec) and publish it in 42 different languages.</p> <p>At least this way there would be a set of quality YAML implementations that were the same in every language. The main problem with this idea was simply learning (and remembering!) how to publish a library in 42 different languages!</p> <p>I decided to write a meta publishing framework that would allow me to publish to any language using the same simple commands. I called this framework PST - Package Super Tool\u00a0 .</p> <p>In doing that I had to pick 42 languages and start learning a bit about each of them. At some point I came across Clojure and thought it was interesting.</p>"},{"location":"blog/2023-12-13/history-lesson/#make-a-lisp","title":"Make a Lisp","text":"<p>Around the start of 2023 I started thinking about YS again. My fledgling language with just a toy implementation in Perl. I knew YS was going to be a Lisp, but I didn't know much about Lisps. I asked the internet how to make a Lisp and it told me to read Make a Lisp\u00a0 !</p> <p>Make a Lisp (Mal) is a project that walks you through making a baby Clojure-inspired Lisp implementation in the programming language of your choice. It has eleven chapters, each with a set of tests that you must pass before you can move on to the next chapter. At the end you have a working Lisp implementation and you have to use it to run the Mal implementation written in Mal and make sure it passes all the tests!</p> <p>I decided to do Mal in Perl (even though there was already a Perl implementation). There are nearly 100 implementations of Mal in over 70 different languages. It took me about 2 weeks to get through the whole thing. By the end I really felt like I knew what a Lisp was, how Lisps worked and how to make one.</p> <p>When I finish the Mal course I decided to do it again but this time in YS, a language that didn't exist yet. This was really easy and fun. I just ported the Mal in Mal code to a YAML form that I found pleasing and acceptable as a programming language; essentially making up YS as I went along.</p> <p>I also wanted to go much further with the Perl implementation. I decided I would create a full implementation of Clojure on Perl based off of my Mal in Perl code. I call this project Lingy\u00a0  (currently available on CPAN\u00a0 ). This is when I started learning Clojure. (Spring 2023).</p>"},{"location":"blog/2023-12-13/history-lesson/#tprc-2023","title":"TPRC 2023","text":"<p>I was also helping to organize the TPRC 2023\u00a0  (Perl and Raku) conference. I decided I would give a talk called Lingy and YAMLScript\u00a0 . I had to get a working Lingy and a working YAMLScript implementation in Perl by the end of June.</p> <p>After I gave the talk I noticed it was getting a lot of attention. A lot more views on youtube than any other talk at the conference. I realized this was happening because the words \"Clojure\" and \"Java\" were in the talk description.</p>"},{"location":"blog/2023-12-13/history-lesson/#the-clojure-community","title":"The Clojure Community","text":"<p>A lovely man named Peter Str\u00f6mberg reached out to me and asked if I would be interested in joining the Clojure Community Slack\u00a0 . Peter is the author of Calva\u00a0 , a Clojure IDE for VS Code, one of the best ways to write and work with Clojure. I joined right away and he pointed me in all the right directions and got me talking to all the right people.</p> <p>I soon learned about GraalVM\u00a0  and SCI\u00a0  written by Michiel Borkent, a man to whom I owe much credit for helping me with many deep technical issues I encountered. Michiel is the author of Babashka\u00a0 , a popular way to do shell scripting in Clojure. SCI is the Clojure runtime engine that Babashka uses and that YS now uses as well!</p> <p>All the pieces started falling into place, and I got a clear vision of what YS should become... AND how relatively easy it would be to make it happen thanks to the Clojure ecosystem. I started rewriting the YS compiler and runtime in Clojure and rebuilding it into what it is today.</p>"},{"location":"blog/2023-12-13/history-lesson/#december-1st-2023","title":"December 1st, 2023","text":"<p>At some point in the Fall, I decided that I would start blogging about YS every day in December 2023, in the Programming Project Advent Calendar style.</p> <p>I thought I would easily get everything done by Dec 1st but to be honest, even as I write this now, there is still so much to do. Some days I really want to write about a particular topic, but the code isn't quite ready yet.</p> <p>But all that said, it's all working out pretty dang well. I'm loving this language and project!</p> <p>I have the highest hopes of hopes for YS in 2024.</p> <p>There's a lot more details I could add here but it's getting late and I need to get some sleep.</p>"},{"location":"blog/2023-12-13/history-lesson/#join-me-again-tomorrow-for-day-14-of-the-ys-advent-calendar","title":"Join me again tomorrow for Day 14 of the YS Advent Calendar!","text":""},{"location":"blog/2023-12-14/stocking-stuffers/","title":"Stocking Stuffers","text":"<p>It's always nice to get a little something extra in your stocking whilst waiting for the big guy to show up on the big day.</p> <p>Learning eveything you need to know about YS in 24 days is a tall order. I still have a quite a bit to learn about it myself! :-)</p> <p>It helps to learn the small stuff first.</p>"},{"location":"blog/2023-12-14/stocking-stuffers/#welcome-to-day-14-of-ys-advent-2023","title":"Welcome to Day 14 of YS Advent 2023!","text":"<p>Today we'll look at some of the little things that make YS a joy to work with. We'll go over some of the basic syntax, semantics, features and commands of YS.</p> <p>What if... What if? What <code>if</code>!</p> <p>Let's start out by looking at some of the various ways you can write the ubiquituous <code>if</code> statement in YS.</p> <p>To set the tone here, let's code an <code>if</code> in another simple language, Python, since it can often be used as pseudocode:</p> <pre><code>if a &gt; b:\n  print(a + \" is greater than \" + b)\nelse:\n  print(b + \" is greater than or equal to \" + a)\n</code></pre> <p>Abstractly we are saying that if some condition is true, then do one thing, otherwise do another thing.</p> <p>Since YS compiles to Clojure, it's important to understand how Clojure does <code>if</code>. Let's look at the same code in Clojure.</p> <pre><code>(if (&gt; a b)\n  (println (str a \" is greater than \" b))\n  (println (str b \" is greater than or equal to \" a)))\n</code></pre> <p>The Clojure code has an <code>if</code> command followed by: * a condition form * a form to run if the condition is true * a form to run if the condition is false (optional)</p> <p>This is how all <code>if</code> statements look in Clojure.</p> <p>There are many ways to do the same thing in YS. Here's a one good way to do it:</p> <pre><code>!YS-v0\nif a &gt; b:\n  say: \"$a is greater than $b\"\n  say: \"$b is greater than or equal to $a\"\n</code></pre> <p>Note</p> <p>All the YS examples in this post use code-mode which requires the <code>!YS-v0</code> tag at the top of the file. We'll leave it out of the rest of the examples for brevity.</p> <p>Let's see what happens when we compile that YS program:</p> <pre><code>$ ys -c if.ys\n(if\n (&gt; a b)\n (say (str a \" is greater than \" b))\n (say (str b \" is greater than or equal to \" a)))\n</code></pre> <p>We get the exact same Clojure code as above! (in a slightly different format) Note that <code>say</code> is an alternate way to write <code>println</code> in YS, but you can use <code>println</code> if you prefer to type more.</p> <p>The <code>if</code> command is an interesting YAML mapping. The key has both the <code>if</code> command symbol and the condition form in it. The value is another YAML mapping with two pairs: one for the \"then\" form and one for the \"else\" form.</p> <p>Note</p> <p>Notice that both pairs have the same key, <code>say</code>. Duplicate keys aren't allowed in YAML, but they are allowed in YS code-mode. That's because the YS compiler (a fancy YAML loader) isn't loading the mapping into a data structure, but rather into an AST. For the AST, the \"duplicate keys\" are no problem, because they're not actually being used as mapping keys. By contrast, in YS data-mode, duplicate keys are not allowed because they are actually being used as mapping keys (like normal YAML).</p> <p>YS code-mode does everything using only YAML block mappings or scalars. Using sequences or flow nodes is not allowed in code-mode.</p> Quick YAML Jargon Review  ----  * node - a mapping, sequence or scalar * collection - a mapping or sequence data structure * mapping - a key/value data structure; aka hash, dictionary, object, * sequence - an ordered list of values; aka array, list, vector * scalar - a single value; aka string, number, boolean, null * block - the normal YAML indented style (with `-` before each sequence node) * flow - the JSON looking style with braces and brackets * plain scalar - a scalar that is not quoted * double quoted scalar - a scalar that is quoted with double quotes * single quoted scalar - a scalar that is quoted with single quotes * literal scalar - a scalar that is quoted with `|` * folded scalar - a scalar that is quoted with `&gt;` * pair - a key/value pair in a mapping * key - the first part of a pair or lefthand side * value - the second part of a pair or righthand side  !!! note      YAML block mapping values can span multiple lines, and can start after the     line with the key and the `:` separator.  ----   <p>Let's write the <code>if</code> statement using YAML scalars instead of a mapping:</p> <pre><code>if a &gt; b:\n  say(\"$a is greater than $b\")\n  say(\"$b is greater than or equal to $a\")\n</code></pre> <p>If you <code>ys --compile</code> this you get the exact same thing as the previous compile. In this case the value of the top YAML mapping is just a scalar. Even though it is 2 lines of code, it represents a a single long line containing two function calls, one for \"then\" and one for \"else\".</p> <p>So that's 2 ways to write the <code>if</code> statement in YS. The two best ways. There are several other ways to do it that are less readable but still valid syntax. And there's nothing special about this being an <code>if</code> statement; the same rules apply to all YS commands in general.</p>"},{"location":"blog/2023-12-14/stocking-stuffers/#general-syntax-rules","title":"General Syntax Rules","text":"<p>By default in code-mode, a mapping is a set of pairs where each pair compiles to a form:</p> <pre><code>a: b c d\na b: c d\na b c: d\na b c d:\n=&gt;: (a b c d)\n=&gt;: a(b c d)\na:\n  =&gt;: b\n  =&gt;: c\n  =&gt;: d\na b:\n  =&gt;: c\n  =&gt;: d\n</code></pre> <p>Note</p> <p>This is important to understand!</p> <p>All the pairs above compile to the same Clojure form: <code>(a b c d)</code>, which is calling a function <code>a</code> with 3 arguments: <code>b</code>, <code>c</code> and <code>d</code>.</p> <p>The <code>=&gt;</code> symbol is a special YS key symbol that can be used when you only care about using a scalar in that spot. Since YS always needs to be valid YAML, this can often be useful.</p> <p>So now you can see what I was talking about with all the ways to write an <code>if</code> statement. Only the <code>a b: c d</code> forms look normal to most programmers.</p>"},{"location":"blog/2023-12-14/stocking-stuffers/#ys-loops","title":"YS Loops","text":"<p>Let's look at another common control structure: looping.</p> <p>There are a lot of ways to do loops in Clojure (thus YS). They have lots of subtle differences and properties. We'll just cover one or two here for now. (We're not even halfway through December yet!)</p> <p>Here's a simple <code>for</code> loop in Python that prints the numbers 0 through 4:</p> <pre><code>for i in range(5):\n  print(i)\n</code></pre> <p>Here's the same loop in Clojure:</p> <pre><code>(for [i (range 5)]\n  (println i))\n</code></pre> <p>So in YS we can do this:</p> <pre><code>for i range(5):\n  say: i\n</code></pre> <p>When we compile this we get:</p> <pre><code>$ ys -c for.ys\n(for [i (range 5)] (say i))\n</code></pre> <p>Let's run it:</p> <pre><code>$ ys for.ys\n$\n</code></pre> <p>Nothing happened!</p> <p>This has to do with some of the more advanced understanding of Clojure. Specifically laziness and evaluation.</p> <p>To be honest, the Clojure code I wrote above would not print anything depending on how you ran it. If you ran it in the Clojure REPL or as a one liner it would print the numbers. If you ran it as a program it would not print anything.</p> <p>To make things work as expected in the REPL Clojure forces the lazy structures to be evaluated.</p> <p>Clojure also has a <code>doall</code> function that forces evaluation. Let's use that in our YS program:</p> <pre><code>doall:\n  for i range(5):\n    say: i\n</code></pre> <p>Now when we compile and run it we get:</p> <pre><code>$ ys for.ys\n0\n1\n2\n3\n4\n</code></pre> <p>Success! But at what cost? That's a lot of code to print 5 numbers.</p> <p>YS has a nicer way to do this. It has an <code>each</code> command that calls <code>doall</code> and <code>for</code> for you:</p> <pre><code>each i range(5):\n  say: i\n</code></pre> <p>or:</p> <pre><code>each i range(5): say(i)\n</code></pre> <p>or:</p> <pre><code>each i (0 .. 4): say(i)\n</code></pre> <p>Doesn't it seem strange to you that <code>(range 5)</code> really means 0 to 4? There are technical reasons for this, but it's not very intuitive.</p> <p>YS's <code>..</code> operator does what you told it to. It really just compiles to <code>(ys.std/rng 0 4)</code> which is a standard YS function that returns a range from 0 to 4.</p> <p>It also works in reverse:</p> <pre><code>$ ys -e 'each i (4 .. 0): say(i)'\n4\n3\n2\n1\n0\n</code></pre> <p>To do that in Clojure you'd have to write:</p> <pre><code>(doall\n  (for [i (range 4 -1 -1)]\n    (println i)))\n</code></pre> <p>Sheesh!</p> <p>I know that was only 2 or 3 things in your stocking, but they were quite a lot to chew on. Maybe we'll have to stuff your stocking a couple more times this month!</p> <p>See you tomorrow for Day 15 of YS Advent 2023!</p>"},{"location":"blog/2023-12-15/naughty-is-nice/","title":"Naughty is Nice!","text":"<p>As the architect of a major world holiday, Santa Claus has hard design choices to make. What is Suki going to get this year? He keeps it simple with the standard Naughty-Or-Nice algorithm.</p> <p>As architects of an aspiring new programming language, the YS folks have design choices to make as well!</p> <p>Naughty-Or-Nice should not be discounted but what about Naughty-And-Nice? Naughty-Xor-Nice???</p> <p>My personal favorite?</p> <p>Naughty-Is-Nice!!</p>"},{"location":"blog/2023-12-15/naughty-is-nice/#welcome-to-day-15-of-the-ys-advent-2023","title":"Welcome to Day 15 of the YS Advent 2023!","text":"<p>Today I want to carry on a bit about what I think about whilst designing YS syntax, semantics and features.</p> <p>The unwavering rule here is that YS needs to be written as valid YAML, and it needs to become valid Clojure.</p> <p>Those two things don't look much alike. However, remember that JSON is a subset of YAML and JSON does look a little bit more like a Lisp (Clojure is a Lisp). YAML's data model is a superset of JSON's data model. So there are pathways and connections to be made between YS and Clojure.</p> <p>Given that, my next move could have been to make YS be as close to Clojure as possible (while still satifying those constraints). I did try that for about 7 minutes... The results were just not \"feel good\".</p> <p>Time for Plan B.</p>"},{"location":"blog/2023-12-15/naughty-is-nice/#malys","title":"mal.ys","text":"<p>I mentioned this in my recent History Lesson... I had just finished my Perl implementation of Make a Lisp\u00a0  (mal) and I decided to try to make a YS version next even though there was no YS yet.</p> <p>Take a look at the implementation of Mal in Mal\u00a0 .</p> <p>As I said before when you complete the exercise of writing a version of Mal in the programming language of your choice, your final goal is to pass the Mal test suite by running the Mal implementation of Mal using your newly created Mal implementation.</p> <p>I'll admit that even now, that is a bit mind bending!</p> <p>I decided to port the Mal in Mal implementation (a Lisp) to YS. I revised it over and over until I liked how it looked and felt. Certainly I had to think about how my new creation would scale to other YS programming problems.</p> <p>Here's what I came up with on March 12th, 2023: yamlscript.ys\u00a0 .</p> <p>This code hurts my eyes now. YS has come a long way since then.</p> <p>The point here is that my modus operandi remained the same. Write programs in YS (often by porting them from existing Clojure programs) and make sure they don't suck. Keep refining the language until it feels right from all angles.</p>"},{"location":"blog/2023-12-15/naughty-is-nice/#breaking-the-rules","title":"Breaking the Rules","text":"<p>Clojure and Lisps in general have very simple syntax rules. Nested parens with a function name first, followed by arguments. When things don't feel right in certain cases, Lisps have their coveted macros to rearrange the things in parens to look nicer and work as intended.</p> <p>Lispers take pride in this simplicity and uniformity. They tend to look down on their bespoken cousins like Perl, Python and Ruby; even though those languages give much credit to Lisp for their dynamic natures.</p> <p>I'm new to Lisp, but as the author of a new programming language written entirely in a Lisp, I can honestly say that I enjoy it.</p> <p>That said, I embrace diversity and I enjoy many different styles of programming. I'm also not afraid to break a few rules when it makes sense.</p> <p>I guess if there's one technology that I know and am most known for, it's YAML. I'd like to think that I know what YAML users like and what things they desire that YAML doesn't provide.</p> <p>I should say \"didn't provide\", because YS is going to provide almost anything they could want.</p> <p>If I were to list the top 3 things that YAML users want:</p> <ul> <li>Composability via file inclusion</li> <li>String interpolation (aka templating)</li> <li>Simple composition and transformation functions:</li> <li>Map merging</li> <li>Sequence concatenation</li> <li>String manipulation</li> <li>etc.</li> </ul> <p>Technologies that have made major use of YAML, like Kubernetes, Ansible and OpenAPI, have all had to invent their own ways to provide these features.</p> <p>With YS, all the things they've done and more are available everywhere and work the same for everyone. And all without breaking the things those technologies already do.</p> <p>I suppose this is all to say that in general YS will follow Clojure's lead when its awesome, but will also look for cleaner ways to do things when it feels needed.</p> <p>Maybe you think I'm being Naughty. I am, but\u2026 Naughty is Nice!</p>"},{"location":"blog/2023-12-15/naughty-is-nice/#the-naughty-list-aka-the-nice-list-","title":"The Naughty List (aka The Nice List :- )","text":"<p>say what you want\u2026</p> <p>No, literally\u2026</p> <p><code>say</code> it!</p> <p>In Clojure you use <code>println</code> to print a string with a newline added to the end. In Python it's <code>print</code>. Ruby <code>puts</code> it out there. Perl people <code>say</code> things.</p> <p>I've always been a fan of doing more with less. Clojure code overall makes it easy to accomplish big things with less code. But from the word by word perspective, Clojure is a bit long-winded at times.</p> <p>YS has a <code>say</code> function in the standard library that does the same thing as <code>println</code> in Clojure (but with 4 less letters). But I didn't take <code>println</code> away from you either. That's your choice.</p> <p>YS is about choices. It embraces the TMTOWTDI\u00a0  philosophy. You saw yesterday how many different ways there are to call functions in YS. I tend to respect function names whose length is inversely proportional to how often they are used.</p> <p>Another good example is Clojure's <code>*command-line-args*</code> dynamic variable. YS calls it <code>ARGV</code>, a shorter name that is seen in other languages.</p> <p>I'm here, Doc!</p> <p>One thing that YAML has that Clojure doesn't is \"heredocs\". A heredoc is a way to write a multiline string without having to escape any of the characters in it. That means you can write almost any string in your program to look exactly like it would in a text file or printed out.</p> <p>Ruby has heredocs because it stole them from Perl who in turn stole them from Shell. YAML has literal scalars which are even better than heredocs because they have no ending marker. You can embed any text content simply by indenting it appropriately. YAML has this awesome feature because I loved it in Perl and wanted it in YAML! True story.</p> <p>YS extends YAML's literal scalars by adding interpolation to them. Using the <code>$some-var</code> or <code>$(some-expression)</code> inline syntax, YS will eval and insert the values just like you'd expect.</p> <p>This makes things like templating and testing multi-line output a breeze. In fact, the YS test suite (testing YS inputs, Clojure outputs, and intermediary stage forms) is based on YAML Literals\u00a0 .</p> <p>YeS, we can!</p> <p>We talked about the YeS Expression Syntax of YS a few days ago. One thing Lisps can't do is have real infix math expressions like: <code>(1 + 2 * 3)</code>. Macros can reorder things but the macro name has to be first. Thus you could do <code>(infix 1 + 2 * 3)</code> but at that point you've already lost.</p> <p>YS tries to support as much infix expressions as it can while still keeping things sane, readable and predictable. You can write <code>1 + 2</code> to mean <code>(+ 1 2)</code> and <code>1 + 2 + 3</code> to mean <code>(+ 1 2 3)</code>. But you can't write <code>1 + 2 * 3</code> because that involves precedence, and that's where things get messy.</p> <p>In a day or two I'll show you YS's path lookup syntax which looks like: <pre><code>val =: obj.foo.3.\"bar baz\".map(inc)\n</code></pre></p> <p>This a is very readable, obvious and powerful way to chain lookups and function calls together.</p> <p>But it's really just using the same infix syntax as above with the YS <code>.</code> chaining operator!</p> <p>How do you usually structure your programs?</p> <p>I'm a top-down kind of guy. I like to start with the main entry point function calling other functions and then define those functions (which use other functions to be defined later).</p> <p>Clojure is a bottom-up language by nature. You can't call a function until it's defined. Well, you can, but you have to use the <code>declare</code> function to do it. The Clojure people I've interacted so far tend to avoid <code>declare</code> and just go bottom-up.</p> <p>YS wants you to be you!</p> <p>You can write things in any order you want to.</p> <p>A big advantage of compiling to an existing language is that you are free to generate uglier output code (that is rarely seen) to support prettier input code (that you have to look at all the time).</p> <p>In this case, the YS compiler scans the AST near the end of the compilation and finds all the functions that were called before they were defined. It then inserts a <code>declare</code> expression for them at the top of the output code.</p> <p>Problem solved!</p> <p>Note</p> <p>If you are interested in why Clojure's author Rich Hickey chose to make Clojure \"bottom-up\", read about it here\u00a0 .</p> <p>Then read the rest of that page. It's full of great insights into the design of Clojure and programming in general.</p> <p>When I started designing the YAML language in 2001 the main goals were:</p> <ul> <li>Make something awesome (that my Mom could use)</li> <li>More content, less markup</li> <li>See/share data the same in any programming language</li> </ul> <p>The primary audience for YS is people who already use YAML and wish it could do more. Clojure and Lisp have so much to offer other programming languages. It's like a deep well of awesome that YS users can tap into when they are ready. But if they just want to <code>load</code> and <code>merge</code> some YAML files, like they saw their friends doing, they can stop there.</p> <p>I hope that gives you a taste of the kinds of things I think about when I'm designing YS. You can't please everyone, but if you give people choices, the only people that get upset are the ones who don't like choices. :- )</p> <p>See you tomorrow? That's Day 16 of the YS Advent 2023!!!</p>"},{"location":"blog/2023-12-16/let-lambda-come-over/","title":"Let Lambda Come Over","text":"<p>We know the names of Santa's reindeer: Dasher, Dancer, Prancer, Vixen, Comet, Cupid, Donner, Blitzen and Rudolph. And his elves: Alabaster Snowball, Bushy Evergreen, Pepper Minstix, Shinny Upatree, Sugarplum Mary, Wunorse Openslae, and the head elf, Bernard.</p> <p>But we don't know the names of Santa's lambda reindeer and elves. Why would we? They are anonymous! They're also the hardest working of the bunch.</p>"},{"location":"blog/2023-12-16/let-lambda-come-over/#welcome-to-day-16-of-the-ys-advent-calendar","title":"Welcome to Day 16 of the YS Advent Calendar","text":"<p>Today we're going to talk about YS lambdas and their frontman named \"let\".</p> <p>It's a kinda of a big deal in your programming journey when you realize the power of NOT naming things, especially functions. Next you learn about functions that take functions and turn them into other functions and your head explodes. (Not literally because then you are dead and can't enjoy the power of lambdas).</p> <p>A lambda is a general term for an anonymous function, ie one that is not named. In Clojure you create can create them in two different ways. Here's a simple lambda that squares a number:</p> <pre><code>;; Using the fn keyword\n(fn [x] (* x x))\n;; Using the #() reader macro\n#(* %1 %1)\n</code></pre> <p>Note: Clojure just calls them \"anonymous functions\".</p> <p>Here's both of those in YS:</p> <pre><code># Using the fn keyword\nfn(x): x * x\n# Using the #() reader macro\n\\(%1 * %1)\n</code></pre> <p>The latter method is shorter but the former is more flexible.</p> <p>Typically you use lambdas to return closures, which are functions that have access to the variables in the scope where they were created.</p> <p>Here's a function the returns a function that adds a number to another number:</p> <pre><code>defn adder(x): \\(%1 + x)\nadd-5 =: adder(5)\nadd-5: 10           # =&gt; 15\n</code></pre> <p>In the <code>adder</code> function, the <code>x</code> variable gets created in the scope of the function and is not available outside of it. But we returned a function that \"closed over\" it so that it could be used by the returned function later on.</p>"},{"location":"blog/2023-12-16/let-lambda-come-over/#let-in-the-lexicals","title":"let in the lexicals!","text":"<p>In the <code>adder</code> function, the <code>x</code> variable was a parameter to the function and created a lexical variable whose scope was the function body. How do we create more lexical variables in to use in a function?</p> <p>In Python you we get the lexicals <code>x</code>, <code>y</code> and <code>z</code> by defining them in the function body:</p> <pre><code>def foo(x):\n    y = x + 1\n    z = y / 2\n    return z\n</code></pre> <p>Pretty clean and simple.</p> <p>In Clojure we use the <code>let</code> keyword to create more lexical variables:</p> <pre><code>(defn foo [x]\n  (let [y (+ x 1)\n        z (/ y 2)]\n    z))\n</code></pre> <p>The <code>let</code> keyword takes a vector (array in <code>[]</code>) of bindings and then a body of code to execute. The binding vector contains one or more pairs of a name (symbol) and an expression that evaluates to a value.</p> <p>The Clojure code looks a little more complicated than the Python code. That's the price for needing to write everything the same way with parenthesized lists.</p> <p>Let's see how YS does it:</p> <pre><code>defn foo(x):\n  y =: x + 1\n  z =: y / 2\n  =&gt;: z\n</code></pre> <p>How can that be the same as the Clojure code?!?! There's no <code>let</code> keyword. Let's try compiling it and see what happens:</p> <pre><code>$ ys -c let.ys\n(defn foo [x] (let [y (_+ x 1) z (/ y 2)] z))\n</code></pre> <p>Well look at that! It generated the <code>let</code> keyword for us.</p> <p>The <code>a =: b</code> YS syntax has super powers. When used at th top level in a program it simply creates a <code>def</code> expression like <code>(def a b)</code>, but when used inside another YS mapping it turns into a <code>let</code>! Not only that, but when their are multiple <code>x := y</code> expressions in a row, they are all put into the same <code>let</code> binding vector, just like you'd do if you wrote the Clojure code by hand.</p> <p>The big win here is that the code you write looks clean like the Python code, but works perfectly as Clojure code. It's one of my favorite features of YS. The need for lexical variables is constant and this makes it painless.</p>"},{"location":"blog/2023-12-16/let-lambda-come-over/#lol","title":"LoL!!!","text":"<p>Let and Lambdas are 2 of the most important features for Lisp (thus Clojure) programmers. There's a famous book called \"Let Over Lambda\" that is a must read for any serious Lisp programmer. (I haven't read it yet, but I am serious, therefore it's a must!)</p> <p>Here's a great snippet from the book:</p> <p>Quote</p> <p>Sometimes it's called a closure, other times a saved lexical environment. Or, as some of us like to say, let over lambda. Whatever terminology you use, mastering this concept of a closure is the first step to becoming a professional lisp programmer. In fact, this skill is vital for the proper use of many modern programming languages, even ones that don't explicitly contain let or lambda, such as Perl or JavaScript.</p> <p>Let over Lambda (LoL!) is built around this simple Lisp idiom:</p> <pre><code>(let ((x 0))\n  (lambda () x))\n</code></pre> <p>But there' a little more to it than that. In most Lisps the <code>x</code> value is mutable. That means the lambda can change the value of <code>x</code> when it is called. This is a very powerful feature because it allows you to create functions that can hold state. You can use this to create iterators, generators, and even object oriented systems.</p> <p>But in Clojure all values are immutable. This is foundational to making Clojure a functional and thread safe language. But Clojure is also famous for being a practical (functional and thread safe) language. It has a kind of value that is mutable. These are called atoms.</p> <p>Let's make the quintessential LoL example, a counter, in Clojure:</p> <pre><code>(defn new-counter [n]\n  (let [x (atom n)]\n    (fn [] (swap! x inc))))\n(def counter (new-counter 10))\n(println (counter)) # =&gt; 11\n(println (counter)) # =&gt; 12\n(println (counter)) # =&gt; 13\n</code></pre> <p>Writing this in YS is a simple port:</p> <pre><code>!YS-v0\ndefn new-counter(n):\n  x =: atom(n)\n  =&gt;: \\(swap! x inc)\ncounter =: new-counter(10)\nsay: counter() # =&gt; 11\nsay: counter() # =&gt; 12\nsay: counter() # =&gt; 13\n</code></pre> <p>Someone told me the other day that YS was a \"lol language\". This must be what they meant.</p> <p>The lols continue tomorrow, on Day 17 of the YS Advent Calendar!</p>"},{"location":"blog/2023-12-17/rosetta-code/","title":"Rosetta Code","text":"<p>How does Santa read all the signs in all the languages of the world? That's a lot of languages to know on top of all the other things he has to do. Luckily he has his trusty polyglot elf, Rosetta, at his side. Bet you didn't know that!</p>"},{"location":"blog/2023-12-17/rosetta-code/#welcome-to-day-17-of-the-ys-advent-calendar","title":"Welcome to Day 17 of the YS Advent Calendar","text":"<p>A cool guy named Mike Mol made a website called Rosetta Code\u00a0  for programmers who want to learn all the programming languages of the world!</p> <p>It's a wiki that has well over 1000 programming tasks and almost 1000 programming languages. The idea is for people to contribute solutions to the tasks in as many languages as they can.</p> <p>I've been a fan of Rosetta Code for years. Here's one of my all time favorite programs from the site: FizzBuzz in SNUSP\u00a0 !!</p> <p>One thing people like to use Rosetta Code for is to show off a new language. YS is a new language, and I've put a few solutions up there myself:</p> <ul> <li>99 Bottles of Beer\u00a0 </li> <li>FizzBuzz\u00a0 </li> <li>Hello world/Text\u00a0 </li> <li>Factorial\u00a0 </li> <li>Fibonacci sequence\u00a0 </li> </ul> <p>Adding solutions to Rosetta Code is a one of the best ways I've found to figure out what YS needs to do and what it needs to do better.</p>"},{"location":"blog/2023-12-17/rosetta-code/#rosetta-code-data","title":"Rosetta Code Data","text":"<p>The Rosetta Code website is a great resource, but it's a bit clunky to use. It would be really cool if all the code examples were available in a nice Git repository.</p> <p>Well, it turns out that they are! You can clone over 100,000 code examples in a few seconds by running this command:</p> <pre><code>$ git clone https://github.com/acmeism/RosettaCodeData\n$ cd RosettaCodeData\n$ ls -l Lang/YAMLScript/\ntotal 8\n00-LANG.txt\n00-META.yaml\n99-bottles-of-beer -&gt; ../../Task/99-bottles-of-beer/YAMLScript/\nFactorial -&gt; ../../Task/Factorial/YAMLScript/\nFibonacci-sequence -&gt; ../../Task/Fibonacci-sequence/YAMLScript/\nFizzBuzz -&gt; ../../Task/FizzBuzz/YAMLScript/\nHello-world-Text -&gt; ../../Task/Hello-world-Text/YAMLScript/\n</code></pre> <p>The Rosetta Code Data Project is something I wrote almost 15 years ago. This last summer I was able to make it a lot easier to update.</p> <p>Let's try out the FizzBuzz example:</p> <pre><code>$ ys Task/FizzBuzz/YAMLScript/fizzbuzz.ys 16\n1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz\n16\n</code></pre> <p>Pretty cool, huh?</p>"},{"location":"blog/2023-12-17/rosetta-code/#rc-needs-more-ys","title":"RC Needs More YS!","text":"<p>Let's try adding a new YS solution to Rosetta Code.</p> <p>The first thing to do is to find a task that doesn't have a YS solution yet. You can find all the tasks listed here\u00a0 .</p> <p>Let's take the first one: 100 doors\u00a0 .</p> <p>What I like to do next is cheat! Clojure has solved most of the tasks on Rosetta Code, and YS is another way to write Clojure, so let's just pick a Clojure solution and translate it to YS.</p> <pre><code>(defn doors []\n    (reduce (fn [doors idx] (assoc doors idx true))\n            (into [] (repeat 100 false))\n            (map #(dec (* %1 %1)) (range 1 11))))\n\n(defn open-doors [] (for [[d n] (map vector (doors) (iterate inc 1)) :when d] n))\n\n(defn print-open-doors []\n  (println\n    \"Open doors after 100 passes:\"\n    (apply str (interpose \", \" (open-doors)))))\n\n(print-open-doors)\n</code></pre> <p>Here's a quick translation to YS:</p> <pre><code>!YS-v0\n\ndefn doors():\n  reduce:\n    fn(doors idx): assoc(doors idx true)\n    into []: repeat(100 false)\n    map \\(dec (%1 * %1)): 1 .. 10\n\ndefn open-doors():\n  for [d n] map(vector doors() iterate(inc 1)) :when d: n\n\ndefn print-open-doors():\n  say:\n    \"Open doors after 100 passes:\n    $(apply str interpose(\\\", \\\" open-doors()))\"\n\n=&gt;: print-open-doors()\n</code></pre> <p>Let's see if it works:</p> <pre><code>$ ys 100-doors.ys\nOpen doors after 100 passes: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100\n</code></pre> <p>Great! Now let's clean it up a bit:</p> <p>I'm just going to rename the <code>print-open-doors</code> function to <code>main</code> and move it to the top of the file. The <code>main</code> function (if defined) is called automatically when the script is run.</p> <pre><code>!YS-v0\n\ndefn main():\n  say:\n    \"Open doors after 100 passes:\n    $(apply str interpose(\\\", \\\" open-doors()))\"\n\ndefn open-doors():\n  for [d n] map(vector doors() iterate(inc 1)) :when d: n\n\ndefn doors():\n  reduce:\n    fn(doors idx): assoc(doors idx true)\n    into []: repeat(100 false)\n    map \\(dec (%1 * %1)): 1 .. 10\n</code></pre> <p>I also ordered the functions top-down in the order they are called since we know that YS will auto-declare them in the generated Clojure code.</p> <pre><code>$ time ys 100-doors.ys\nOpen doors after 100 passes: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100\n\nreal    0m0.041s\n</code></pre> <p>Still works! Pretty fast too! Let's add it to Rosetta Code!</p> <p>To do this you need to create an account on the site, login, and then click the \"Edit\" tab on the task page. It's a pretty terrible plain text editor, but scroll way down to where the YS solutions should go and add this:</p> <pre><code>=={&amp;lcub;header|YAMLScript}}==\n&amp;lt;syntaxhighlight lang=\"yaml\"&gt;\n!YS-v0\n\ndefn main():\n  say:\n    \"Open doors after 100 passes:\n    $(apply str interpose(\\\", \\\" open-doors()))\"\n\ndefn open-doors():\n  for [d n] map(vector doors() iterate(inc 1)) :when d: n\n\ndefn doors():\n  reduce:\n    fn(doors idx): assoc(doors idx true)\n    into []: repeat(100 false)\n    map \\(dec (%1 * %1)): 1 .. 10\n&amp;lt;/syntaxhighlight&gt;\n{&amp;lcub;out}}\n&amp;lt;pre&gt;\n$ ys 100-doors.ys\nOpen doors after 100 passes: 1, 4, 9, 16, 25, 36, 49, 64, 81, 100\n&amp;lt;/pre&gt;\n</code></pre> <p>Click \"Save changes\" and you're done!</p> <ul> <li>https://rosettacode.org/wiki/100_doors#YAMLScript\u00a0 </li> <li>https://github.com/acmeism/RosettaCodeData/blob/main/Task/100-doors/YAMLScript/100-doors.ys\u00a0 </li> <li>I updated the repo (not automatic yet)</li> </ul> <p>We did it!</p> <p>Don't wait for me to add more YS solutions to Rosetta Code. You can do it yourself! If you do, send me (<code>@ingydotnet</code>) a DM on the Rosetta Code Discord\u00a0  server and I'll update the Rosetta Code Data Project repo with your solutions.</p> <p>If you had never heard of Rosetta Code before, I hope you'll find it as interesting as I do.</p> <p>Check back tomorrow for Day 18 of the YS Advent Calendar!</p>"},{"location":"blog/2023-12-18/santas-in-dbuggy/","title":"Santa's in d'buggy","text":"<p>With one week to go, Santa's gotta get his sleigh in top shape. Can't have any breakdowns on the big night. His sleigh might look like a simple wooden buggy, but it's more temperamental and buggy than a 2023 Tesla!</p> <p>But this is Santa we're talking about. He's done this a few times, so he knows how to get the bugs out.</p>"},{"location":"blog/2023-12-18/santas-in-dbuggy/#welcome-to-day-18-of-the-ys-advent-calendar","title":"Welcome to Day 18 of the YS Advent Calendar","text":"<p>Today we're going to look at a few ways to debug YS programs. We'll also cover some of the common mistakes that you might make when writing YS code.</p> <pre><code># hello.ys\nsay: \"Hello, world!\"\n</code></pre> <p>Let's run this very simple program:</p> <pre><code>$ ys hello.ys\n$\n</code></pre> <p>Hmmm. Nothing happened. What's wrong?</p> <p>This first thing I do when my YS program doesn't work is see what the Clojure code that it compiled to looks like. We didn't get a compile error there when we ran <code>ys</code>, so let's look at the code we were running:</p> <pre><code>$ ys hello.ys -c\n{\"say\" \"Hello, world!\"}\n</code></pre> <p>Oh snap! We forgot to start the program with <code>!YS-v0</code>. The program started of in <code>bare</code> mode, which is just a YAML mapping.</p> <p>We also could have run the program with <code>--print</code> to see what it evaluated to:</p> <pre><code>$ ys hello.ys -p\n{\"say\" \"Hello, world!\"}\n</code></pre> <p>Same thing. Let's fix the program now:</p> <p><pre><code>!YS-v0\nsay: \"Hello, world!\"\n</code></pre> now: <pre><code>$ ys hello.ys\nHello, world!\n</code></pre></p> <p>That's better.</p> <p>Let's write a program to dynamically generate a list of numbers:</p> <pre><code># map.ys\n!YS-v0\nmap inc: [1 2 3]\n</code></pre> <p>This program doesn't <code>say</code> anything. That's because we are using it to generate data, so we'll <code>--load</code> it:</p> <pre><code>$ ys map.ys -l\nCompile error: Sequences (block and flow) not allowed in code mode\n</code></pre> <p>That's scary! And what's up with Java?! I don't think it even compiled.</p> <p>When this happens, I like to debug the 7 layers of YS compilation, with the <code>--debug-stage=all</code> option, aka <code>-d</code>:</p> <pre><code>$ ys map.ys -d\n</code></pre> <pre><code>$ ys map.ys -l -d\n*** parse output ***\n({:+ \"+MAP\", :! \"YS-v0\"}\n {:+ \"=VAL\", := \"map inc\"}\n {:+ \"+SEQ\", :flow true}\n {:+ \"=VAL\", := \"1 2 3\"}\n {:+ \"-SEQ\"}\n {:+ \"-MAP\"})\n\n*** compose output ***\n{:! \"YS-v0\", :% [{:= \"map inc\"} {:-- [{:= \"1 2 3\"}]}]}\n\nCompile error: Sequences (block and flow) not allowed in code mode\n</code></pre> <p>The 7 stages of YS compilation are: <code>parse</code>, <code>compose</code>, <code>resolve</code>, <code>build</code>, <code>transform</code>, <code>construct</code>, and <code>print</code>. It looks like we are getting an error in the <code>resolve</code> stage.</p> <p>The <code>-d</code> option means the same thing as <code>-Dparse -Dcompose -Dresolve -Dbuild -Dtransform -Dconstruct -Dprint</code>.</p> <p>So we parsed the YAML input into pieces and then composed a tree out of them. In the resolve stage we look at each node of the tree and figure out what it means semantically.</p> <p>YS doesn't allow sequences in code mode. And it doesn't allow any flow style collections <code>[] {}</code> in code mode either. But we wrote <code>[1 2 3]</code>, not <code>[1, 2, 3]</code>. To YAML, <code>[1 2 3]</code> is valid but it means <code>[\"1 2 3\"]</code>. We really meant this list to be a YS ysexpr vector not a YAML sequence.</p> <p>We wanted YAML to see the RHS as a scalar value, not a sequence. YAML plain (unquoted) scalars can't begin with certain characters, like <code>[</code>, <code>{</code>, <code>*</code>, <code>&amp;</code>, <code>!</code>, <code>|</code>, <code>&gt;</code>, <code>%</code>, <code>@</code>, <code>#</code> etc because they are YAML syntax. In YS when we want a ysexpr string that starts with one of these characters, we can escape it with a plus <code>+</code>.</p> <pre><code>!YS-v0\nmap inc: +[1 2 3]\n</code></pre> <p>And let's just check the resolve stage this time:</p> <pre><code>$ ys map.ys -l -Dresolve\n</code></pre> <pre><code>$ ys map.ys -l -Dresolve\n*** resolve output ***\n{:ysm [{:ysx \"map inc\"} {:ysx \"[1 2 3]\"}]}\n\n[2,3,4]\n</code></pre> <p>It resolved! And it worked! We got our list of numbers.</p> <p>Note</p> <p>The error message indicated a <code>java.lang.Exception</code>. Remember that YS is Clojure and Clojure is Java. The JVM is compiled out of the picture in YS, but the error message still comes from Java stuff.</p> <p>Here's a little program to calculate the factorial of a number:</p> <pre><code># factorial.ys\n!#/usr/bin/env ys-0\n\ndefn main(n):\n  say: factorial(n)\n\ndefn factorial(x):\n  apply *: 2 .. x\n</code></pre> <p>Let's see how it works:</p> <pre><code>$ ys factorial.ys\nError: Wrong number of args (0) passed to: sci.impl.fns/fun/arity-1--3508\n\n$ ys factorial.ys 10\n3628800\n$ ys factorial.ys 20\n2432902008176640000\n$ ys factorial.ys 30\nError: long overflow\n</code></pre> <p>Two of the four runs we got an error. Hopefully the errors are pretty obvious. The first time we forgot the number it wanted. The second time we tried to calculate a number that was too big for a 64 bit integer.</p> <p>This was a very small program, but when things blow up, it's nice to have a stack trace to see exactly where the error happened and what code path it took to get there. Especially when many library files are involved.</p> <p>You can see the stack trace on any error by using the <code>--stack-trace</code> option aka <code>-S</code>:</p> <pre><code>$ ys -S sample/rosetta-code/factorial.ys 30\nRuntime error:\njava.lang.ArithmeticException: long overflow\n at clojure.lang.Numbers.multiply (Numbers.java:1971)\n    clojure.lang.Numbers$LongOps.multiply (Numbers.java:503)\n    clojure.lang.Numbers.multiply (Numbers.java:175)\n    clojure.core$_STAR_.invokeStatic (core.clj:1018)\n    clojure.core$_STAR_.invoke (core.clj:1010)\n    clojure.lang.LongRange$LongChunk.reduce (LongRange.java:316)\n    clojure.core$reduce1.invokeStatic (core.clj:944)\n    clojure.core$_STAR_.invokeStatic (core.clj:1020)\n    clojure.core$_STAR_.doInvoke (core.clj:1010)\n    clojure.lang.RestFn.applyTo (RestFn.java:142)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:662)\n    sci.lang.Var.invoke (lang.cljc:202)\n    sci.impl.analyzer$return_call$reify__6143.eval (analyzer.cljc:1422)\n    sci.impl.fns$fun$arity_1__5030.invoke (fns.cljc:107)\n    sci.lang.Var.invoke (lang.cljc:200)\n    sci.impl.analyzer$return_call$reify__6139.eval (analyzer.cljc:1422)\n    sci.impl.analyzer$return_call$reify__6147.eval (analyzer.cljc:1422)\n    sci.impl.analyzer$return_call$reify__6139.eval (analyzer.cljc:1422)\n    sci.impl.fns$fun$arity_1__5030.invoke (fns.cljc:107)\n    clojure.lang.AFn.applyToHelper (AFn.java:154)\n    clojure.lang.AFn.applyTo (AFn.java:144)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    sci.impl.analyzer$analyze_fn_STAR_$reify__5779$f__5780.doInvoke (analyzer.cljc:538)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    clojure.core$apply.invokeStatic (core.clj:667)\n    clojure.core$apply.invoke (core.clj:662)\n    sci.lang.Var.invoke (lang.cljc:202)\n    sci.impl.analyzer$return_call$reify__6143.eval (analyzer.cljc:1422)\n    sci.impl.analyzer$return_call$reify__6139.eval (analyzer.cljc:1422)\n    sci.impl.interpreter$eval_form.invokeStatic (interpreter.cljc:40)\n    sci.impl.interpreter$eval_string_STAR_.invokeStatic (interpreter.cljc:66)\n    sci.core$eval_string_PLUS_.invokeStatic (core.cljc:276)\n    yamlscript.runtime$eval_string.invokeStatic (runtime.clj:209)\n    yamlscript.cli$do_run.invokeStatic (cli.clj:347)\n    yamlscript.cli$do_default.invokeStatic (cli.clj:410)\n    yamlscript.cli$do_main.invokeStatic (cli.clj:489)\n    yamlscript.cli$_main.invokeStatic (cli.clj:527)\n    yamlscript.cli$_main.doInvoke (cli.clj:506)\n    clojure.lang.RestFn.applyTo (RestFn.java:137)\n    yamlscript.cli.main (:-1)\n    java.lang.invoke.LambdaForm$DMH/sa346b79c.invokeStaticInit (LambdaForm$DMH:-1)\n\u2605```\n\nWell... You asked for it. :- )\n\n\n----\n\nPrint debugging is a great way to debug programs.\nYS provides some help here with it's `WWW` and `XXX` standard library\nfunctions.\nConceptually these come from an old Perl module I wrote years ago called\n[XXX](https://metacpan.org/pod/XXX).\n\n* `WWW` warns (prints to stderr) it's argument and returns it.\n* `XXX` dies (prints and then terminates) it's argument.\n\nHere's a contrived example that passes data through a pipeline of functions:\n\n```yaml\n# pipeline.ys\n!YS-v0\n-&gt;&gt; (1..10):\n  map: inc\n  filter: \\(= 0 (mod % 2))  # odd?\n  reduce: +\n  =&gt;: say\n</code></pre> <p>Check it:</p> <pre><code>$ ys pipeline.ys\n30\n</code></pre> <p>The <code>-&gt;&gt;</code> function is Clojure's threading macro. It lets you pass a value through a pipeline of transformation functions without having to reverse nest them in a ton of parentheses. It's quite nice and handy.</p> <p>Often times when I'm writing a pipeline like this, I want to see what the data looks like after a particular transformation or maybe after several of them. I almost always us <code>WWW</code> for this.</p> <pre><code>!YS-v0\n-&gt;&gt; (1..10):\n  WWW: \"before map\"\n  map: inc\n  WWW: \"after map\"\n  filter: \\(= 0 (mod % 2))  # odd?\n  WWW: \"after filter\"\n  reduce: +\n  WWW: \"after reduce\"\n  =&gt;: say\n  =&gt;: WWW\n</code></pre> <p>The <code>WWW</code> function can actually take multiple arguments. It prints them all and returns the last one. The <code>-&gt;&gt;</code> threading macro adds its value as the last argument to each function. So the way we did it here we are adding a label to each debugging section.</p> <p>I used <code>=&gt;: WWW</code> to show how to call it with no extra label argument. Remember that <code>=&gt;:</code> is the YS way to write a mapping pair when you only need one thing (the <code>WWW</code> function in this case).</p> <pre><code>$ ys pipeline.ys\n---\n(\"before map\" (1 2 3 4 5 6 7 8 9 10))\n...\n---\n(\"after map\" (2 3 4 5 6 7 8 9 10 11))\n...\n---\n(\"after filter\" (2 4 6 8 10))\n...\n---\n(\"after reduce\" 30)\n...\n30\n---\nnil\n...\n</code></pre> <p>Each WWW call wraps the output with a <code>---</code> and a <code>...</code> so you can see where the output starts and ends.</p> <p>I hope you enjoyed this little tour of YS debugging. There are many more ways to debug YS programs. Likely many than I've even thought of yet.</p> <p>See you tomorrow for Day 19 of the YS Advent Calendar.</p>"},{"location":"blog/2023-12-19/reindeer-all-the-way-down/","title":"Reindeer All The Way Down","text":"<p>Santa is in charge of Christmas. He's the one who makes sure that all the children get presents. But who is in charge of getting Santa his presents? That's where the reindeer come in. They are the ones who make sure that Santa gets his presents. But who is in charge of getting the reindeer their presents? More reindeer! But who is in charge of getting the reindeer's reindeer their presents? More reindeer! It's reindeer all the way down.</p>"},{"location":"blog/2023-12-19/reindeer-all-the-way-down/#welcome-to-day-19-of-the-ys-advent-calendar","title":"Welcome to Day 19 of the YS Advent Calendar","text":"<p>YS is a new programming language that is based on Clojure. It's written in Clojure and compiles to Clojure. In effect YS is Clojure. So if YS is written in Clojure, why not just use YS to write YS?</p> <p>Isn't there a chicken and egg problem here? Sure, but that's easy to solve.</p> <p>Once you have a stable version of YS, you can rewrite YS in YS. You just need to use a previously compiled version of YS to compile the new YS-in-YS with.</p> <p>This is called self-hosting and it's a common practice in the programming language world. Clojure itself is written in Clojure. Not all of it. It's also written in Java, since it runs on the JVM. But all the core libraries are written in Clojure.</p> <p>YS isn't quite ready to be self-hosted yet. But I was able to convert the <code>ys::std</code> library to YS and then build YS with it!</p> <p>Have a look at this gist\u00a0 .</p> <p>It has 3 files:</p> <ul> <li>orig-std.clj\u00a0    \u2014 The original Clojure version of <code>ys::std</code> as of today.</li> <li>std.clj\u00a0    \u2014 The compiled version of YS port of <code>ys::std</code>.</li> <li>std.ys\u00a0    \u2014 The YS port of <code>ys::std</code>.</li> </ul> <p>I don't know about you but I find the YS version much easier to read than the Clojure version.</p> <p>However since there's still a lot of work left to do on YS, before the first stable release, some of the YS code is a bit ugly.</p> <p>Let's look at a few ugly forms and think about how to make them better.</p> <p>Let's start with the <code>ns</code> declaration at the top of the file:</p> <pre><code>ns ys::std:\n  (:require\n   [yamlscript::debug]\n   [clojure::pprint]\n   [clojure::string])\n  (:refer-clojure :exclude [print])\n</code></pre> <p>Soon we'll have a YS macro system for making certain calls look better than they do with the base syntax. The future <code>ns</code> declaration might look like this:</p> <pre><code>ns ys::std:\n  require:\n    yamlscript::debug:\n    clojure::pprint: pp\n    clojure::string:\n  refer-clojure:\n    exclude: print\n</code></pre> <p>That looks pretty nice!</p> <p>How about this ugly multi-arity defn:</p> <pre><code>defn toMap:\n  +[]: +{}\n  +[x]:\n    apply: hash-map x\n  +[k v &amp; xs]:\n    apply: hash-map k v xs\n</code></pre> <p>Here we needed to plus-escape the <code>[]</code> keys. I'd rather see like:</p> <pre><code>defn toMap:\n  (): hash-map()\n  (x):\n    apply: hash-map x\n  (k v *xs):\n    apply: hash-map k v xs\n</code></pre> <p>Parentheses are just normal characters in YAML so we don't need to escape them. And we already use parens in <code>defn foo(bar): baz</code> so it's consistent.</p> <p>One of the more problematic forms in this file is the macro definition:</p> <pre><code>defmacro each [bindings &amp; body]:\n  +`(do\n      (doall\n        (for [~@bindings] (do ~@body)))\n      nil)\n</code></pre> <p>I pretty much had to leave the original Clojure syntax alone here. The backtick is a reserved character in YAML so we had to plus-escape it.</p> <p>There's actually quite a few problems that macros cause for YS. I won't bore you with the details. We'll figure out a good way to code macros in YS but I can't say that I have it figured out yet.</p> <p>At this point I'd say that about 80% of Clojure code ports nicely to YS. The other 20% is a bit of a struggle. But that's stuff I want to improve before the first stable release.</p> <p>I hope you enjoyed today's post. It was a little shorter than usual. But YS is keeping me very busy and I was a little short on time today.</p> <p>I have something really special planned for tomorrow. But I need to make it work first! Fingers crossed.</p> <p>Come back tomorrow for Day 20 of the YS Advent Calendar.</p>"},{"location":"blog/2023-12-20/godspeed/","title":"Godspeed","text":"<p>I wonder if Santa has a Hemi? Supercharged, Turbocharged? Maybe a Nitro Burning Funny Sleigh? Dude's got to get around the world in one night. Godspeed, my festive friend!</p>"},{"location":"blog/2023-12-20/godspeed/#welcome-to-day-20-of-the-ys-advent-blog","title":"Welcome to Day 20 of the YS Advent Blog!","text":"<p>Are YS programs compiled or interpreted? The answer is yes.</p> <p>Clojure (thus YS) is a very dynamic language. Clojure code gets compiled to Java bytecode just in time. The JVM compiles the bytecode to machine code just in time. Libraries that Clojure uses are compiled ahead of time. The whole YS runtime was compiled by GraalVM native-image into a native binary so there is no JVM involved for us in the end.</p> <p>It's all pretty complicated.</p> <p>But I was talking about YS programs being run by the YS CLI <code>ys</code>. You can think of <code>ys</code> as an interpreter like Python, Perl, Ruby or Java. Sure, those languages compile to an intermediate AST/opcode-tree to be faster, but the programs are still interpreted (not binary compiled).</p> <p>What if you could compile your YS program to a native binary? Like an ELF file on Linux or a Mach-O file on macOS.</p> <p>Can you guess why I like Linux better this time of year? :- )</p> <p>As of today, you can natively compile YS programs!!</p> <p>Merry, Merry!</p> <p>Let's check it out. Remember our favorite drinking song from Day 9? Here it is again:</p> <pre><code>#!/usr/bin/env ys-0\n# 99-bottles.ys\n\ndefn main(number=99):\n  each n (number .. 1):\n    say: paragraph(n)\n\ndefn paragraph(num): |\n  $bottles(num) of beer on the wall,\n  $bottles(num) of beer.\n  Take one down, pass it around.\n  $bottles(num - 1) of beer on the wall.\n\ndefn bottles(n):\n  cond:\n    n == 0 : \"No more bottles\"\n    n == 1 : \"1 bottle\"\n    else   : \"$n bottles\"\n</code></pre> <p>Let's see how long it takes to drink 3 bottles:</p> <pre><code>$ time ys 99-bottles.ys 3\n3 bottles of beer on the wall,\n3 bottles of beer.\nTake one down, pass it around.\n2 bottles of beer on the wall.\n\n2 bottles of beer on the wall,\n2 bottles of beer.\nTake one down, pass it around.\n1 bottle of beer on the wall.\n\n1 bottle of beer on the wall,\n1 bottle of beer.\nTake one down, pass it around.\nNo more bottles of beer on the wall.\n\nreal    0m0.075s\n</code></pre> <p>75 milliseconds. Not bad. Let's see if we can drink a little faster, shall we?</p> <pre><code>$ ys --binary 99-bottles.ys\n* Compiling YS '99-bottles.ys' to '99-bottles' executable\n* Setting up build env in '/tmp/tmp.wpt7O1KsWg'\n* This may take a few minutes...\n[1/8] Initializing              (5.0s @ 0.08GB)\n[2/8] Performing analysis               (20.7s @ 0.35GB)\n[3/8] Building universe         (3.3s @ 0.35GB)\n[4/8] Parsing methods           (2.3s @ 0.61GB)\n[5/8] Inlining methods          (2.0s @ 0.44GB)\n[6/8] Compiling methods         (22.2s @ 0.42GB)\n[7/8] Layouting methods         (1.7s @ 0.44GB)\n[8/8] Creating image            (2.3s @ 0.51GB)\n* Compiled YS '99-bottles.ys' to '99-bottles' executable\n$ ls -lh 99-bottles*\n-rwxr-xr-x 1 ingy ingy 13M Dec 19 18:14 99-bottles*\n-rwxr-xr-x 1 ingy ingy 468 Dec 19 18:10 99-bottles.ys*\n</code></pre> <p>It appears that we have birthed a new beer singer! What goes better with beer than race cars?</p> Answer  Almost anything.  <p></p> <pre><code>$ time ./99-bottles 3\n3 bottles of beer on the wall,\n3 bottles of beer.\nTake one down, pass it around.\n2 bottles of beer on the wall.\n\n2 bottles of beer on the wall,\n2 bottles of beer.\nTake one down, pass it around.\n1 bottle of beer on the wall.\n\n1 bottle of beer on the wall,\n1 bottle of beer.\nTake one down, pass it around.\nNo more bottles of beer on the wall.\n\nreal    0m0.016s\n</code></pre> <p>Woah! 16 milliseconds! Now we're drinking with gas! Errr... never mind.</p> <p>You may have noticed that the native binary is 13 megabytes. That's because it contains the entire YS runtime. Hopefully we can get that down to a smaller size in the future.</p> <p>Also did you notice that it took an annoying amount of time to compile?</p> <p>Let's time native compiling a minimal program:</p> <pre><code>$ time ys -be 'say: \"Hello, world!\"'\n* Compiling YS '-e' to './EVAL' executable\n* Setting up build env in '/tmp/tmp.mahWVLE9gi'\nCould not find main function in '-e'\n\nreal    0m0.103s\n</code></pre> <p>I forgot to mention. In order to <code>--binary</code> compile a YS program, it must have a <code>main</code> function. That's an easy fix:</p> <pre><code>$ time ys -be 'defn main(): say(\"Hello, world!\")'\n* Compiling YS '-e' to './EVAL' executable\n* Setting up build env in '/tmp/tmp.1zpmh6L1jM'\n* This may take a few minutes...\n[1/8] Initializing              (4.4s @ 0.17GB)\n[2/8] Performing analysis               (17.4s @ 0.30GB)\n[3/8] Building universe         (2.4s @ 0.53GB)\n[4/8] Parsing methods           (2.4s @ 0.49GB)\n[5/8] Inlining methods          (1.4s @ 0.63GB)\n[6/8] Compiling methods         (20.4s @ 0.42GB)\n[7/8] Layouting methods         (1.6s @ 0.46GB)\n[8/8] Creating image            (2.5s @ 0.40GB)\n* Compiled YS '-e' to './EVAL' executable\n\nreal    0m59.855s\n</code></pre> <p>Isn't that pretty cool? You can native compile a <code>-e</code> one liner!</p> <p>Since the output file needs a name, <code>ys</code> uses <code>./EVAL</code> when you use <code>-e</code>. You can use the <code>-o</code> option to to name the file explicitly. Otherwise it defaults to the name of the YS file with the <code>.ys</code> extension removed.</p> <p>The bad news is that it took almost a minute to compile. Currently that's the price you pay for a one-liner race car!</p> <p>Let's see if this little guy has the juice:</p> <pre><code>$ time ./EVAL\nHello, world!\n\nreal    0m0.010s\n</code></pre> <p>Godspeed, you little global greeter!</p> <p>The YS <code>--binary</code> compiler is based on GraalVM's <code>native-image</code> tool. The same process that is used to compile the <code>ys</code> CLI binary.</p> <p>I wish it were faster to compile to binary, but at least now we can be fast while developing our YS programs and then compile them to native binaries when we are ready to ship them.</p> <p>Let's look at where YS is at now from a high level view:</p> <ul> <li>We have a new language that feels clean like Python</li> <li>It is actually a functional language adding reliability</li> <li>It's really Clojure so very complete and powerful</li> <li>It's embeddable in YAML so you can enhance existing YAML files</li> <li>It's a better YAML loader for plain old YAML with no magics</li> <li>It's quite fast when run with the YS CLI <code>ys</code></li> <li>It's even faster when compiled to a native binary</li> </ul> <p>I think we have a winner here!</p> <p>There's still a long way to go on many fronts, but all of the above is true today. Full disclosure: I only came up the the <code>--binary</code> idea 2 days ago.</p> <p>Climb aboard and let's fly this baby to the moon!</p> <p>Come back tomorrow for Day 21 of the YS Advent Blog!</p>"},{"location":"blog/2023-12-21/yaml-python-and-the-holy-graal/","title":"YAML, Python and the Holy Graal","text":"<p>Which has a greater airspeed velocity... an unladen swallow or Santa's sleigh?</p> <p>Well, that depends... are we talking about an African or European swallow?</p> <p> </p> Huh?"},{"location":"blog/2023-12-21/yaml-python-and-the-holy-graal/#welcome-to-day-21-of-the-ys-advent-blog","title":"Welcome to Day 21 of the YS Advent Blog!","text":"<p>So far we've been using the YS CLI <code>ys</code> to run (or load) our YS programs. YAML users are used to using a YAML framework module inside their programs. For example, in Python you might do:</p> <pre><code>import yaml\n\nyaml_text = \"\"\"\n- 40\n- 50\n- 60\n\"\"\"\n\ndata = yaml.safe_load(yaml_text)\n\nprint(data)\n# =&gt; [40, 50, 60]\n</code></pre> <p>Wouldn't it be nice if we could do the same thing in YS? As of today, we can!</p> <pre><code>import yamlscript\n\nyaml_text = \"\"\"\n- 40\n- 50\n- 60\n\"\"\"\n\ndata = yamlscript.YAMLScript().load(yaml_text)\n\nprint(data)\n# =&gt; [40, 50, 60]\n</code></pre> <p>The only thing that changed was the name of the module.</p> <p>But this module has super powers.</p> <pre><code>import yamlscript\n\nyaml_text = \"\"\"\n!YS-v0\nmapv \\(% * 10): 4..6\n\"\"\"\n\ndata = yamlscript.YAMLScript().load(yaml_text)\n\nprint(data)\n# =&gt; [40, 50, 60]\n</code></pre> <p>We can use YS functions in our YAML text to generate or manipulate data.</p> <p>That example was a bit contrived, but I just wanted to show how easy it is to load plain old YAML or super powered YAML with the new <code>yamlscript</code> Python module.</p> <p>Here's an example that might be more exciting.</p> <p>Say we have this normal YAML file with some data in it:</p> <pre><code># db.yaml\ncars:\n- make: Ford\n  model: Mustang\n  year: 1967\n  color: red\n- make: Dodge\n  model: Charger\n  year: 1969\n  color: orange\n- make: Chevrolet\n  model: Camaro\n  year: 1969\n  color: blue\n</code></pre> <p>We could have another YAML file that uses YS:</p> <pre><code># racers.yaml\n!YS-v0\n\ndb =: load(\"db.yaml\")\n\n=&gt;: !\n- name: Ingy d\u00f6t Net\n  car:: db.cars.0\n- name: Santa Claus\n  car:: db.cars.1\n- name: Sir Lancelot\n  car:: db.cars.2\n</code></pre> <p>Then we could load the data into Python and print it out:</p> <pre><code># race-report.py\nimport yaml, yamlscript\n\ndata = yamlscript.load('racers.yaml')\n\nprint(yaml.dump(data))\n</code></pre> <p>And we get:</p> <pre><code>- car:\n    color: red\n    make: Ford\n    model: Mustang\n    year: 1967\n  name: Ingy dot Net\n- car:\n    color: orange\n    make: Dodge\n    model: Charger\n    year: 1969\n  name: Santa Claus\n- car:\n    color: blue\n    make: Chevrolet\n    model: Camaro\n    year: 1969\n  name: Sir Lancelot\n</code></pre> <p>Pretty cool, huh?</p> <p>There's no end to the things you can do with this.</p> <p>Today we're showing off the Python YS module\u00a0  but soon this module will be available in every language that has a need for it.</p>"},{"location":"blog/2023-12-21/yaml-python-and-the-holy-graal/#installing-the-yamlscript-python-module","title":"Installing the <code>yamlscript</code> Python Module","text":"<p>Normally to install a Python module you would do:</p> <pre><code>pip install a-python-module\n</code></pre> <p>With YS, you do the same:</p> <pre><code>pip install yamlscript\n</code></pre> <p>But you also need to install the <code>libyamlscript</code> shared library.</p> <p>You can do that with:</p> <pre><code>curl https://yamlscript.org/install | bash\n</code></pre> <p>That will install the latest version of <code>libyamlscript</code> for your platform in <code>/usr/local/lib</code>. You'll need to have root access to do this.</p> <p>If you want to install it somewhere else, you can set the <code>PREFIX</code> option:</p> <pre><code>curl https://yamlscript.org/install | PREFIX=~/ys bash\n</code></pre> <p>But then you'll need to set the <code>LD_LIBRARY_PATH</code> environment variable to point to it:</p> <pre><code>export LD_LIBRARY_PATH=~/ys/lib\n</code></pre> <p>Eventually we may package the yamlscript.py module with wheels (binary assets) for libyamlscript, but for now you'll need to install it yourself.</p> <p>If you're a polyglot like me, at least you only have to install it once. :- )</p>"},{"location":"blog/2023-12-21/yaml-python-and-the-holy-graal/#the-holy-graal","title":"The Holy Graal","text":"<p>This magic is all possible because of the GraalVM\u00a0  project. Not only does GraalVM's <code>native-image</code> tool compile to binary executables, it also can compile to shared libraries.</p> <p>YS generates and publishes the <code>libyamlscript</code> shared library and then offers binding modules for it in many languages.</p> <p>I hope you are starting to see the power of YS. Not only as a new programming language, but also as a new way to work with YAML files that you already have.</p> <p>Join me tomorrow for Day 22 of the YS Advent Blog!</p>"},{"location":"blog/2023-12-22/flip-flops/","title":"Flip Flops","text":"<p>Can you imagine Santa walking around in flip flops? I've never been up to the North Pole, but I'm pretty sure there's no beaches. I always pictured Santa wearing moon boots around the workshop.</p> <p>YS on the other hand, is all about flip flops!</p>"},{"location":"blog/2023-12-22/flip-flops/#welcome-to-day-22-of-the-ys-advent-blog","title":"Welcome to Day 22 of the YS Advent Blog!","text":"<p>Remember way back in Day 6 when we talked about the 3 different YS modes? They were bare, data and code. The bare mode was what you got then you ran (or loaded) a YS program with no <code>!YS-v0</code> tag at the top. It just meant that you were effectively stuck in data mode, with no possibility of executing any code.</p> <p>There's actually comfort in bare mode. You are using YS to process your data because it is one of the best YAML loaders available, but you don't have to worry about any code being run accidentally.</p> <p>Today's post is about the other two modes. Either you are writing a program (thus starting in code mode) or you are doing cool stuff with your data files (thus starting in data mode).</p> <p>In either case you are going to want to switch modes at various places in your YS. We learned before that you could switch modes by using the <code>!</code> tag. This is the smallest possible tag and we use it for the most common need.</p> <p>Here's an example of using YS to generate data to be loaded. We'll start in code mode by using <code>!YS-v0</code>:</p> <pre><code>!YS-v0\n\nvars =: !\n  colors:\n  - red\n  - ! (\"gre\" + \"en\")\n  - blue\n  numbers: !\n    vec:\n      map \\(% * 10): ! [1, 2, 3]\n  awesome: { yaml: true, xml: ! (1 &gt; 2) }\n\n=&gt;: !\n- ! \"$(vars.colors.1) with envy\"\n- ! \"Four score and $(vars.numbers.1) years ago\"\n- ! \"Santa wears flip flops. $(vars.awesome.yaml) or $(vars.awesome.xml)?\"\n</code></pre> <p>That's more bangs than a fireworks show in a barbershop!</p> <p>This was just a crazy way to get the following data:</p> <pre><code>- green with envy\n- Four score and 20 years ago\n- Santa wears flip flops. true or false?\n</code></pre> <p>Every time you see a <code>!</code> tag, it means that we are switching modes from <code>code</code> to <code>data</code> or vice versa.</p> <p>Let's walk through it:</p> <ul> <li><code>!YS-v0</code> - This tag starts the program in <code>code</code> mode. If we wanted to   start in <code>data</code> mode, we would use <code>!YS-v0:</code>.</li> <li><code>vars =: !</code> - We are setting the value of a variable named <code>vars</code> to the some   data we want to write in plain old YAML. Before we can do that, we need to   switch to <code>data</code> mode.</li> <li><code>! (\"gre\" + \"en\")</code> - This is a YS expression that evaluates to the string   <code>green</code>. To let YS know that we want to evaluate this expression, we switch   back to <code>code</code> mode.</li> <li><code>numbers: !</code> - Even though we just switched to <code>code</code> mode,   in the previous point, it was only for that scalar / expression.   We need to do it again since the mapping we are in is in data mode.</li> </ul> <p>And so on. Note that when we switch modes we do it only for that node, not for the whole rest of the document.</p>"},{"location":"blog/2023-12-22/flip-flops/#a-better-flip-flop-syntax","title":"A Better Flip Flop Syntax","text":"<p>The <code>!</code> tag is ok for switching modes, but even though it's one character, I find it a bit noisy. Here's another way to switch modes:</p> <pre><code>!YS-v0\n\nvars =::\n  colors:\n  - red\n  - ! (\"gre\" + \"en\")\n  - blue\n  numbers::\n    vec:\n      map \\(% * 10):: [1, 2, 3]\n  awesome: { yaml: true, xml:: (1 &gt; 2) }\n\n=&gt;::\n- ! \"$(vars.colors.1) with envy\"\n- ! \"Four score and $(vars.numbers.1) years ago\"\n- ! \"Santa wears flip flops. $(vars.awesome.yaml) or $(vars.awesome.xml)?\"\n</code></pre> <p>When a <code>!</code> tag follows a <code>:</code> key/value separator, we can use a <code>::</code> instead to mean the same thing.</p> <p>There are still bangs in there because they didn't follow a <code>:</code>.</p> <p>I find the <code>::</code> syntax to be a bit more readable.</p> <p>Note that this isn't a special new YAML syntax. It's simply an unquoted key that ends with a colon.</p> <p>This trick works from both code and data modes. It does not work from bare mode. You'll just have a mapping key that ends with a colon.</p> <p>It might seem like using the <code>!</code> or <code>::</code> as a toggle could get confusing because you need to keep track of which mode you are in.</p> <p>But typically it's pretty obvious for a person reading the YAML. Machines need to be more exact.</p> <p>I suspect that I'll introduce the <code>!code</code> and <code>!data</code> tags in the future, for when you feel the need to be explicit.</p> <p>That was a quick post but also an important one for learning how to write better YS.</p> <p>See you tomorrow for Day 23 of the YS Advent Blog!</p>"},{"location":"blog/2023-12-23/perl-to-rust/","title":"Perl to Rust","text":"<p>When Santa is doing his job in the Luxembourg area, I've always wondered how he gets from Perl to Rust.</p> <p>Maybe he takes this route\u00a0 !</p>"},{"location":"blog/2023-12-23/perl-to-rust/#welcome-to-day-23-of-the-ys-advent-blog","title":"Welcome to Day 23 of the YS Advent Blog!","text":"<p>A couple of days ago we showed you how to use YS from Python.</p> <p>One language binding down, forty-one to go!</p> <p>Today we'll show you how to use YS with 3 new programming language bindings: Perl, Rust and Raku (aka Perl 6).</p> <p>YS gets by with a little help from its friends:</p> <ul> <li>@tony-o\u00a0  - Raku binding</li> <li>@ethiraric\u00a0  - Rust binding</li> <li>@jjatria\u00a0  - Perl binding</li> <li>@vendethiel\u00a0  - Polyglot extraordinaire</li> </ul> <p>These guys are awesome!</p>"},{"location":"blog/2023-12-23/perl-to-rust/#i-heard-a-rumor","title":"I Heard a Rumor!","text":"<p>Let's make up a little YS program that we can run from all the new YS bindings:</p> <pre><code># hearsay.ys\n\n# ys --load hearsay.ys | jq -r .\n\n!YS-v0\n\nhackers =::\n- ethiraric\n- ingydotnet\n- jjatria\n- tony-o\n\nlanguages =::\n- Perl\n- Python\n- Raku\n- Rust\n\n=&gt;: \"I heard that @$rand-nth(hackers) uses YS\n    in their $rand-nth(languages) code!\"\n</code></pre> <p>Now run (actually \"load\") this a few times using the YS <code>ys --load</code> command:</p> <pre><code>$ ys --load hearsay.ys | jq -r .\nI heard that @tony-o uses YS in their Rust code!\n$ ys --load hearsay.ys | jq -r .\nI heard that @ethiraric uses YS in their Python code!\n$ ys --load hearsay.ys | jq -r .\nI heard that @jjatria uses YS in their Rust code!\n$ ys --load hearsay.ys | jq -r .\nI heard that @ingydotnet uses YS in their Perl code!\n$ ys --load hearsay.ys | jq -r .\nI heard that @vendethiel uses YS in their Raku code!\n$\n</code></pre> <p>Works like a charm!</p> <p>Now let's load this program from each of the new language bindings!</p>"},{"location":"blog/2023-12-23/perl-to-rust/#perl","title":"Perl","text":"<p>I've been programming Perl for a very long time. 25 years actually. I've published over 200 Perl modules on CPAN. My first one was called Inline::C\u00a0  which makes it trivial to write C bindings in Perl.</p> <p>That's exactly what I needed to get done today to write this blog post about it. Ironically, I've forgotten how to use Inline::C, so I asked an AI to do it for me. It gave me something reasonable looking, but I couldn't get it working.</p> <p>But the best part of Perl is its community! My good Perl friend Olaf\u00a0  told me to seek out a Perl programmer named JJ\u00a0 . I did and he was happy to help. He got it done in no time, and now I'm writing about it!!!</p> <p>JJ used the newer Perl FFI binding framework called FFI::Platypus\u00a0 .</p> <p>Let's use the new YS CPAN module <code>YAMLScript.pm</code> to run our <code>hearsay.ys</code> program:</p> <pre><code># hearsay.pl\nuse v5.16.0;\nuse YAMLScript;\nuse Slurp;\nmy $program = slurp 'hearsay.ys';\nsay YAMLScript-&gt;new-&gt;load($program);\n</code></pre> <pre><code>$ perl hearsay.pl\nI heard that @ethiraric uses YS in their Rust code!\n$ perl hearsay.pl\nI heard that @ingydotnet uses YS in their Python code!\n</code></pre> <p>Just like the Python binding, the Perl module has a <code>load</code> method that takes a YS program as a string and returns the result as a Perl data structure.</p> <p>Install <code>YAMLScript.pm</code> with:</p> <pre><code>$ cpanm YAMLScript\n</code></pre> <p>Also like the Python binding, the Perl module (and all the other bindings) currently requires that you install <code>libyamlscript.so</code> yourself.</p> <p>You can do this easily with:</p> <pre><code>$ curl https://yamlscript.org/install | bash\n</code></pre> <p>Remember that this installs to <code>/usr/local/lib</code> by default, so you'll need to run this as root. (Or use the PREFIX option and set <code>LD_LIBRARY_PATH</code> yourself.)</p>"},{"location":"blog/2023-12-23/perl-to-rust/#rust","title":"Rust","text":"<p>@ethiraric is a Rust programmer who dropped by the YAML matrix chat\u00a0  a couple of weeks ago looking to improve Rust's YAML support. I told him about YS and suggested he write a Rust binding for it since it's just one FFI call.</p> <p>He did and today we get to show it off.</p> <p>Rust needs a bit more setup than Perl, but it's still pretty easy.</p> <p>First run <code>cargo new hearsay</code> to create a new Rust project. Then edit <code>hearsay/Cargo.toml</code> to look like this:</p> <pre><code>[package]\nname = \"hearsay\"\nversion = \"0.1.0\"\nedition = \"2021\"\n[dependencies]\nyamlscript = \"0.1.2\"\n</code></pre> <p>Then edit <code>hearsay/src/main.rs</code> to look like this:</p> <pre><code>fn main() {\n    let input = std::fs::read_to_string(\"hearsay.ys\").unwrap();\n    let output = yamlscript::load(&amp;input).unwrap();\n    println!(\"{output}\");\n}\n</code></pre> <p>Now run <code>cargo run</code> and you should see something like this:</p> <pre><code>$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.01s\n     Running `target/debug/hearsay`\n{\"data\":\"I heard that @ethiraric uses YS in their Python code!\"}\n</code></pre> <p>That's not quite right, but that's where things are at this moment. The <code>load</code> function is returning a JSON string, but it should be returning a Rust data structure for whatever was under the <code>\"data\"</code> JSON key. I'm sure @ethiraric will fix it soon!!!</p> <p>It's actually fortunate that the Rust binding is not working yet, because it shows us how libyamlscript actually works.</p> <p>The libyamlscript library currently has a single function that takes a YS string and returns a JSON string. Internally it compiles the YS to Clojure and evaluates the code using SCI. Then it converts the result to JSON and returns it. If the evaluation fails it returns JSON with all the error information under an <code>\"error\"</code> key. If successful, it returns JSON with all the result information under a <code>\"data\"</code> key.</p> <p>The above call was successful, so that's why we see our expected result under the <code>\"data\"</code> key.</p>"},{"location":"blog/2023-12-23/perl-to-rust/#raku","title":"Raku","text":"<p>Raku is the new name for Perl 6. It's a completely different language than Perl 5, but it's still a lot like Perl.</p> <p>@tony-o is a Raku programmer and my personal friend IRL for many years now. He really loves YS and wants to work on the language as a whole. Writing a Raku binding was a perfect way to get him started.</p> <p>You can install the Raku binding with:</p> <pre><code>$ zef install YAMLScript\n</code></pre> <p>Here's the example Raku program:</p> <pre><code>use YAMLScript;\nmy $program = slurp 'hearsay.ys';\nmy YAMLScript $ys .= new;\nsay $ys.load($program);\n</code></pre> <p>Then you can run our hearsay program like this:</p> <pre><code>$ LD_LIBRARY_PATH=/usr/local/lib raku hearsay.raku\nI heard that @tony-o uses YS in their Python code!\n</code></pre> <p>The Raku effort was a two person job. A big shout out to @vendethiel for helping @tony-o get the Raku binding working right.</p> <p>Ven, as we call him, is someone I've known of and highly respected for many years. He was a major contributor to both CoffeeScript and Raku which have permanent places in my heart. He's Polyglot to the core and possibly more Acmeist\u00a0  than Ingy!</p> <p>But my biggest thanks to Ven is for being my daily sounding board and protaganist for YS. He encourages my good ideas even when they are ambitious and crazy sounding. Every time he's disagreed with me, he's been right... Even if it sometimes takes me a while to see it.</p> <p>Everyone in this penuiltimate advent blog post is a hero to me and definitely on Santa's nice list!!! (as far as I'm concerned)</p> <p>Please do join me tomorrow for the final post of the YS Advent Blog 2023!</p>"},{"location":"blog/2023-12-24/wrapped-and-ready/","title":"Wrapped and Ready","text":"<p>The Elves have everything wrapped up.</p> <p>Literally!</p> <p>Tonight's the big night.</p> <p>It's Time to Deliver!</p>"},{"location":"blog/2023-12-24/wrapped-and-ready/#welcome-to-day-24-of-the-ys-advent-calendar","title":"Welcome to Day 24 of the YS Advent Calendar","text":"<p>It's also time to wrap up this year's YS advent holiday season. Let's put a bow on it and deliver it to the world.</p> <p>First we should take a moment to reflect on what we've learned this month. We can also take a look forward to what's coming up in the New Year.</p>"},{"location":"blog/2023-12-24/wrapped-and-ready/#the-50000-foot-view","title":"The 50,000 Foot View","text":"<p>We'll start with a high level look at the landscape YS promises to be.</p> <ul> <li>YS is new programming language</li> <li>You write YS in YAML</li> <li>JSON is also YAML</li> <li>All JSON and most YAML is valid YS</li> <li>YS compiles to Clojure</li> <li>Clojure is a Lisp and a Functional Programming (FP) language</li> <li>YS a functional language with a Lisp model</li> <li>YS ia a complete language (since Clojure is)</li> <li>YS's engine is a native binary executable</li> <li>No JVM involved; no slow startup</li> <li>YS starts fast and runs fast</li> <li>YS programs can compile to binary executables</li> <li>YS has a clean syntax that feels Pythonic</li> <li>YeS-Expressions offer infix operators and prefix function calls</li> <li>Can also be written in a full-Lisp style</li> <li>Or full-non-Lisp or anywhere in between</li> <li>There are many ways to write the same expression in YS</li> <li>YS embeds cleanly into existing YAML files</li> <li>Good for simplifying and enhancing existing YAML files</li> <li>Include parts of other YAML files into any part of a YAML file</li> <li>Map, filter and transform YAML data to more YAML data</li> <li>YS can use libraries written in Clojure or YS</li> <li>Lots of existing Clojure libraries will work with YS</li> <li>YS libraries can be written in YS</li> <li>YS can be used as a scripting language</li> <li>YS provides the <code>ys</code> command line tool</li> <li>Compile YS files to Clojure code</li> <li>Compile YS files to native binary executables</li> <li>Convert between YAML, JSON and EDN</li> <li>Eval YS expressions from the command line</li> <li>YS provides the <code>libyamlscript</code> shared library</li> <li>Bindable to most programming languages</li> <li>Growing number of languages have YS binding modules</li> <li>Load plain old YAML files more correctly</li> <li>Load YAML files with embedded transformation code</li> <li>Run subtasks written in YS from another language</li> </ul>"},{"location":"blog/2023-12-24/wrapped-and-ready/#the-state-of-the-ys","title":"The State of the YS","text":"<p>YS is a year and a half old from inception, but it really found its direction in July 2023.</p> <p>It is now a working programming language with:</p> <ul> <li>A compiler</li> <li>A mature runtime</li> <li>A mature standard library</li> <li>Binding modules in several programming languages</li> <li>Regular binary releases for Linux, Mac (x64 and ARM)</li> <li>Simple one-line installer commands</li> <li>Example programs on Rosetta Code</li> </ul> <p>Many things remain to be done:</p> <ul> <li>Windows support</li> <li>Finish the v0 compiler</li> <li>Test suite with complete coverage</li> <li>User documentation and tutorials</li> <li>Binding modules for most modern programming languages</li> <li>A YS module registry</li> </ul> <p>to name a few.</p>"},{"location":"blog/2023-12-24/wrapped-and-ready/#what-lies-ahead","title":"What Lies Ahead","text":"<p>The complete scope and trajectory of YS is unknown. I'm confident that it will be used in ways I can't even imagine.</p> <p>This notion is built into the design of YS. Stating the explicit API version (<code>v0</code>) is a mandatory part of the writing and using YS code. Version 1 can completely break away from version 0, and no existing code will be affected.</p> <p>I already have exciting plans queued up for the next year:</p> <ul> <li>IDE support (Calva + source maps)</li> <li>nREPL server support</li> <li>Top notch error messages</li> <li>Cross language shared library auto-binding</li> <li>Use case tutorials and examples</li> <li>Simplifying massive YAML deployment files</li> <li>Using YS for better CI/CD workflows</li> <li>Task automation with YS</li> </ul>"},{"location":"blog/2023-12-24/wrapped-and-ready/#the-end-of-an-advent","title":"The End of an Advent","text":"<p>I hope you've enjoyed this year's YS Advent Blog. I enjoyed writing it but I'm relieved that it's finally over. It's one thing to write a blog post every day and another to be working around the clock trying to implement everything you're writing about.</p> <p>Those things I've listed above deserve more explanation. Perhaps they each deserve their own blog post! I look forward to telling you about each of them in detail. But...</p> <p>I'm going to take the rest of the year off from blogging about YS. I'll keep working on the language itself because that's just pure fun for me. (Usually.)</p> <p>I'll be back in January and I'll try to put out a blog post every week or two. From now on I don't have to blog about things that I just barely got working after burning the midnight oil.</p> <p>I'm so excited about this language!!!</p> <p>I knew that doing this advent calendar was going to be a huge challenge, but I also knew that it was just the thing to drive YS forward. The alternative was to wait a full year for Advent 2024. Thank goodness for my ADD. (Advent Driven Development)</p> <p>Happy Holidays to you and yours.</p> <p>I'll see you in the future.</p> <p>Don't forget your sunglasses.</p> <p>The future is bright!!!</p> <p>\u2014 Ingy d\u00f6t Net and the YS Elves</p>"},{"location":"blog/2024-03-14/ys-firsts/","title":"YS Firsts","text":""},{"location":"blog/2024-03-14/ys-firsts/#remember-your-first-time","title":"Remember Your First Time?","text":"<p>Do you remember the first time you wrote a program in a new language? For YS, mine was yesterday!</p> <p>This is my first post of 2024. I've been working on YS non-stop since the last YS Advent 2023 post. Too busy to write a blog post, I guess.</p> <p>Yesterday something awesome happened.</p> <p>Putting out a YS release is a complicated process. It takes me about an hour to do it. Of course I plan to automate it fully but I just haven't had the tuits.</p> <p>For the last several releases, I've had a text file that listed all the steps so that I wouldn't forget anything. Yesterday I automated that list...</p> <p>...you guessed it...</p> <p>...in YS!</p>"},{"location":"blog/2024-03-14/ys-firsts/#the-10-step-program","title":"The 10 Step Program","text":"<p>Of course I have been writing test programs in YS for a while now. This was the first time that I wrote a YS program that actually does something I need to do on a regular basis.</p> <p>Without further ado, here is the YS Release Automation Program\u00a0 .</p> <p>It's a 10 step program that does everything I used to do manually. I think it turned out pretty nice.</p> <p>Judge for yourself but let me tell you a bit about it first.</p> <ul> <li>There are 10 steps to perform.</li> <li>If a step fails you can run it again.</li> <li>You can indicate which steps to start and end at.</li> <li>Reports information about each step as it goes.</li> <li>Has a verbose mode that shows you what it has done to various files.</li> <li>Has a dry-run mode that shows you what it would do without doing anything.</li> <li>Validates its inputs and tries to doublecheck its work.</li> <li>Everything is broken up into short and simple functions.</li> <li>Execution starts with the main function at the top.</li> <li>Shells out to common CLI commands to get things done.</li> <li>Uses multiline literal scalars with interpolation to make changelog entries.</li> <li>Fairly well documented internally with comments.</li> </ul> <p>It's pretty much like a shell script, but written in YS. Given that YS is a functional language with immutable data, perhaps it's more reliable than a shell script. Time will tell.</p> <p>I also added a Makefile rule to run the program. It supports several variables to control the program and writes the output to stdout and a log file.</p> <p>Here's the output from a dry-run:</p> <pre><code>$ make release-yamlscript o=0.1.42 n=0.1.43 v=1 d=1\n./util/release-yamlscript 0.1.42 0.1.43  2&gt;&amp;1 | tee -a release-0.1.43.log\n\nReleasing YS v0.1.43 at Thu Mar 14 07:28:19 AM PDT 2024\n\n\nStep 1) Update '.version.sh' file\n+ git -P diff .version.sh\n\nStep 2) Run 'make bump'\n+ make bump\n+ git -P diff\n\nStep 3) Update the 'Changes' file\n+ grep -F -B999 '0.1.42' Changes\n\nStep 4) Update the Change Log files for the binding modules\n\nStep 5) Commit the release changes to git\n+ git commit -a -m 'release: 0.1.43'\n\nStep 6) Add git tag for the new version\n+ git tag 0.1.43\n\nStep 7) Push the git commit and tag\n+ git push\n+ git push --tags\n\nStep 8) Run 'make release'\n+ make release\n\nStep 9) Run 'make release' for each language binding library\n+ make -C clojure release\n+ make -C go release\n+ make -C java release\n+ make -C julia release\n+ make -C nodejs release\n+ make -C perl release\n+ make -C perl-alien release\n+ make -C python release\n+ make -C raku release\n+ make -C ruby release\n+ make -C rust release\n+ git -P diff\n\nStep 10) Publish the yamlscript.org website\n+ make -C www realclean publish\n</code></pre> <p>Maybe it's time for you to write your first YS program!</p> <p>If you do, drop me a line and tell me how it went. YS is still a young language and I'm always looking for feedback.</p>"},{"location":"blog/2024-03-14/ys-firsts/#other-firsts","title":"Other Firsts","text":"<p>Last Monday someone published the first article about YS\u00a0 .</p> <p>It was based on YAML core team member Tina M\u00fcller\u00a0 's recent talk about YAML\u00a0  at the FOSDEM 2024\u00a0  which had a section about YS.</p> <p>The article was accurate and well researched which is a rare thing for YAML in my experience.</p> <p>Also last week I gave the first 2024 public talk about YS at the Seajure Meetup\u00a0  in Seattle. Seajure is a Seattle based Clojure meetup that I started attending last year. The talk was well received and I got some good feedback. The video should be available soon.</p> <p>Next month YS will be presented at its first conference talk of 2024\u00a0  at the Linux Foundation's Open Source Summit North America\u00a0 . I hope to see you there!</p>"},{"location":"blog/2024-03-14/ys-firsts/#future-firsts","title":"Future Firsts","text":"<p>There's a few big things in the works for YS this year worth mentioning:</p> <ul> <li>A YAML Schema DSL that will be used to validate YS evaluation results.</li> <li>Compiler source maps for IDE integration and better error messages.</li> <li>YS User Documentation (finally).</li> </ul> <p>I'll be back here next week to tell you about all the things that have happened with YS in the last 3 months. So much good stuff. Stay tuned!</p> <p>YS We Can! \u2014 Ingy d\u00f6t Net</p>"},{"location":"blog/2024-04-16/ys-spring-update/","title":"YS Spring Update","text":"<p>It's been a while since I let you know what's been happening with YS. I've been busy working on it every day this year and I have a lot to tell you about!</p>"},{"location":"blog/2024-04-16/ys-spring-update/#ys-activity-in-2024","title":"YS Activity in 2024","text":"<p>Let me start by telling you about some of the events that have happened in the YS world recently.</p> <ul> <li>Seajure Talk\u00a0  -   I gave a talk at the Seajure (Seattle Clojure) Meetup in March.</li> <li>YS Article\u00a0  -   The New Stack published an article about YS in March</li> <li>YS Podcast\u00a0  -   I was interviewed on the \"The REPL\" by Daniel Compton in April.</li> </ul> <p>Finally I'm presenting a talk about YS at the Open Source Summit North America\u00a0  this Thursday, April 18th. Super excited about that!</p>"},{"location":"blog/2024-04-16/ys-spring-update/#ys-progress-since-the-advent-series","title":"YS Progress Since the Advent Series","text":"<p>I blogged about YS every day in December 2023. That was something. We were madly trying to implement all the stuff I was talking about. I may have told a few small lies along the way, but I'm happy to say that everything I talked about is now implemented and working.</p> <p>And of course we've added a lot more since then.</p> <p>Let's talk about some of the highlights.</p>"},{"location":"blog/2024-04-16/ys-spring-update/#more-ys-yamlscript-language-binding-libraries","title":"More YS (YAMLScript) Language Binding Libraries","text":"<p>We've added 4 new binding libraries for YS in 2024, bringing the total to 8: Clojure\u00a0  (new), Java\u00a0  (new), NodeJS\u00a0  (new), Perl\u00a0 , Python\u00a0 , Raku\u00a0 , Ruby\u00a0  (new) and Rust\u00a0 .</p> <p>The idea is to eventually have binding libraries for every language where YAML is currently used. I expect more to come soon. If you see a missing language that you want (and you are handy with FFI), please consider writing a binding library for it and submitting a PR to the YS Mono Repository.</p> <p>All the libraries are a small amount of code and are easy to write.</p> <p>If you need help, please stop by the YS Matrix Chat Room\u00a0  and we'll get you what you need.</p>"},{"location":"blog/2024-04-16/ys-spring-update/#new-dot-chaining-operator","title":"New Dot Chaining Operator","text":"<p>In Clojure you can write:</p> <pre><code>(take 5\n  (shuffle\n    (filter even?\n      (range 100))))\n</code></pre> <p>This evaluates to something like: <code>[94 36 4 70 74]</code></p> <p>Often people like to use Clojure's threading macro (<code>-&gt;</code>) to make this more readable:</p> <pre><code>(-&gt;&gt; (range 100)\n     (filter even?)\n     (shuffle)\n     (take 5))\n</code></pre> <p>Let's look at the same thing in YS in various styles.</p> <p>Basic block style:</p> <pre><code>take 5:\n  shuffle:\n    filter even?:\n      range: 100\n</code></pre> <p>Yes Expression style:</p> <pre><code>take(5\n  shuffle(\n    filter(even?\n      range(100))))\n</code></pre> <p>Clojure threading style:</p> <pre><code>-&gt;&gt; range(100):\n  filter(even?)\n  shuffle\n  take(5)\n</code></pre> <p>And now with the new dot chaining operator:</p> <pre><code>range(100)\n  .filter(even?)\n  .shuffle()\n  .take(5)\n</code></pre> <p>Or all on one line:</p> <pre><code>$ ys -e 'say: range(100).filter(even?).shuffle().take(5)'\n</code></pre>"},{"location":"blog/2024-04-16/ys-spring-update/#more-about-the-dot-chaining-operator","title":"More about the Dot Chaining Operator","text":"<p>Above we used the dot operator to chain function calls together. But it's even more useful than that.</p> <p>Consider:</p> <pre><code>a.b.3.c().d(e).f(g _).$h\n</code></pre> <p>If <code>a</code> is a mapping, the <code>\"b\"</code> (or <code>:b</code> or <code>'b</code>) key is looked up. <code>3</code> is the 4th element of the list that <code>b</code> resolves to. <code>c</code> is called as a function with the result of <code>3</code> as an argument. <code>d</code> is called as a function with the result of <code>c</code> and <code>e</code> as arguments. <code>f</code> is called as a function with <code>g</code> and the result of <code>d</code> as arguments. Finally the key in variable <code>h</code> is looked up in the result of <code>f</code>.</p> <p>One common idiom is looking up environment variables. For example: <code>ENV.HOME</code> or <code>ENV.USER.str/upper-case()</code>.</p>"},{"location":"blog/2024-04-16/ys-spring-update/#new-operators-and-syntax","title":"New Operators and Syntax","text":"<p>In the last section we saw the new chaining operator: <code>.</code>.</p> <p>The interesting thing to note here is that <code>.</code> already had a meaning in Clojure. It's the namespace separator, as in <code>clojure.core/println</code>.</p> <p>YS uses <code>::</code> for that separator instead, so we'd say <code>clojure::core/println</code>.</p> <p>In a similar switch-up, we added the <code>%</code> and <code>%%</code> operators. <code>(a % b)</code> compiles to the Clojure code <code>(rem a b)</code>, and <code>(a %% b)</code> compiles to <code>(mod a b)</code>; 2 slightly different math functions.</p> <p>In Clojure, <code>%</code> was already a shorthand for the <code>%1</code> argument in anonymous functions.</p> <p>In YS, you'll need to use <code>%1</code> for that:</p> <pre><code>square =: \\(%1 * %1)\n</code></pre> <p>Next we added <code>**</code> for exponentiation. So <code>2 ** 3</code> compiles to <code>(pow 2 3)</code>. We also added <code>pow</code> to the <code>ys::std</code> YS standard library, so you can say <code>pow(2 3)</code> instead of <code>math/pow(2 3)</code>. More about the standard library in a bit.</p> <p>We added the Perl style regex operators <code>=~</code>, <code>!~</code> and regex literal <code>/.../</code>.</p> <pre><code>if peanut-butter =~ /chocolate/:\n  say: \"You've got chocolate in my peanut butter!\"\n</code></pre> <p>You might have noticed that YS uses <code>\\( ... )</code> for anonymous functions, where Clojure uses <code>#( ... )</code>. Things starting with <code>#</code> are comments in YAML, so that's problematic.</p> <p>We decided the <code>\\</code> would be a general purpose escape character, but Clojure already uses <code>\\</code> for escaping character literals.</p> <p>YS now uses <code>\\\\</code> for that purpose: <code>str(\\\\a \\\\b \\\\c)</code> would evaluate to <code>\"abc\"</code>.</p> <p>In Clojure you see <code>'foo</code> used extensively for quoting symbols. In YAML, single quotes are used for string literals, and I felt it was important to keep that distinction.</p> <p>Luckily in Clojure you can use <code>(quote foo)</code> for the same thing. In YS you can use <code>quote(foo)</code>. We added the shorthand <code>q(foo)</code> as well as <code>\\'foo</code> for quoting.</p> <p>Finally, we added <code>foo*</code> splatting.</p> <p>It is common in Clojure to use <code>apply</code> to call a function with a list of arguments: <code>(apply f [1 2 3])</code> is the same as <code>(f 1 2 3)</code>. So if <code>xs</code> is a sequence of numbers, you'd say <code>(apply f xs)</code>.</p> <p>In YS you can say <code>f(xs*)</code> instead.</p> <p>But it gets better. You can you use <code>xs*</code> anywhere in a list of arguments: <code>f(1 xs* 3 ys* 5)</code>.</p>"},{"location":"blog/2024-04-16/ys-spring-update/#standard-global-variables","title":"Standard Global Variables","text":"<p>Clojure has dynamic variables like <code>*out*</code> and <code>*command-line-args*</code>.</p> <p>YS now has a few of these, but we decided to use symbols with <code>ALL-CAPS</code> instead of <code>*earmuffs*</code> for these. We also made them shorter in some cases.</p> <ul> <li><code>ARGV</code> - Command line arguments</li> <li><code>ARGS</code> - Like <code>ARGV</code> but numbers are converted to numeric values</li> <li><code>ENV</code> - Environment variable mapping</li> <li><code>CWD</code> - Current working directory</li> <li><code>FILE</code> - Path to the current file being processed</li> <li><code>INC</code> - The YS module include path</li> <li><code>VERSIONS</code> - Mapping of versions of key components in YS</li> </ul> <p>We'll be adding more of these as needed.</p>"},{"location":"blog/2024-04-16/ys-spring-update/#the-ysstd-ys-standard-library","title":"The <code>ys::std</code> YS Standard Library","text":"<p>We added many libraries that are automatically available in every YS program:</p> <ul> <li><code>ys::std</code> - The standard library (also available <code>std</code>)</li> <li><code>clojure::str</code> - available as <code>str</code></li> <li><code>clojure::math</code> - available as <code>math</code></li> <li><code>clojure::tools::cli</code> - available as <code>cli</code></li> <li><code>babashka::fs</code> - avaiable as <code>fs</code></li> <li><code>babashka::http</code> - available as <code>http</code></li> </ul> <p>and more.</p> <p>The <code>ys::std</code> library is the most important one. We can see all the functions available in it by running:</p> <pre><code>$ ys -e 'say: q(std).ns-publics().keys().sort().vec()' | zprint '{:width 40}'\n[$$ *_ +++ +++* +_ =-- _&amp; _* _** _T __\n _dot abspath curl cwd die dirname each\n err exec join new num omap out pow pp\n pretty print process q rng say sh shell\n sleep throw toBool toFloat toInt toMap\n toStr use-pod warn www xxx yyy zzz]\n</code></pre> <p>You might note that the <code>print</code> function is part of <code>clojure::core</code> and YS offers all of that by default. In a few places we decided to replace Clojure functions with our own versions. But we also added a <code>ys::clj</code> library that has all the original versions of the replaced Clojure functions in it.</p> <p>So if you really need <code>clojure::core/print</code>, you can say <code>clj/print</code>.</p> <p>Here are the functions in <code>ys::clj</code>:</p> <pre><code>$ ys -e 'say: q(clj).ns-publics().keys().sort().vec()' | zprint '{:width 40}'\n[compile load load-file num print use]\n</code></pre> <p>Not too many.</p> <p>We'll look at <code>use</code> in the next section.</p>"},{"location":"blog/2024-04-16/ys-spring-update/#including-ys-libraries-and-modules","title":"Including YS Libraries and Modules","text":"<p>I'll start by saying we made the <code>require</code> function nice to use in YS.</p> <p>The best way to describe it is to show you the actual test case for it:</p> <pre><code>- name: Various require transformations in one pair\n  yamlscript: |\n    !YS-v0\n    require:\n      foo::aaa: =&gt; fa\n      foo::bbb: one\n      foo::ccc: one two\n      foo::ddd:\n        =&gt; fd\n        one two\n      foo::eee:\n      foo::fff: :all\n  clojure: |\n    (require\n      '[foo.aaa :as fa]\n      '[foo.bbb :refer [one]]\n      '[foo.ccc :refer [one two]]\n      '[foo.ddd :as fd :refer [one two]]\n      'foo.eee\n      '[foo.fff :refer :all])\n</code></pre> <p>That's how we write tests for the YS compiler.</p> <p>I think it explains how <code>require</code> works in YS pretty well.</p> <p>The <code>require</code> function is used for including Clojure libraries. We've also added support for writing libraries in YS itself. We'll call them \"modules\" to distinguish them from Clojure libraries.</p> <p>To use a module in YS, you use the <code>use</code> function.</p> <pre><code>use: 'my-module'\n</code></pre> <p>This will look for a file called <code>my-module.ys</code> in the <code>INC</code> path.</p> <p>The <code>INC</code> path is a list of directories that YS will look in for and it defaults to the current directory. You can override the <code>INC</code> path by setting the <code>YSPATH</code> environment variable.</p> <p>YS also added support for Babashka Pods\u00a0 . You can use a pod in YS like this:</p> <pre><code>use-pod: \"org.babashka/go-sqlite3\" \"0.1.0\"\n</code></pre>"},{"location":"blog/2024-04-16/ys-spring-update/#multi-doc-and-anchor-alias-support","title":"Multi-doc and Anchor / Alias Support","text":"<p>This is the last topic for today, but it's a big one.</p> <p>Anchors and aliases are an important feature of YAML. They let you mark a node with a name and then refer to that node by name later.</p> <p>Until now, YS has not supported anchors and aliases. Supporting them is critical because YS should be able to load all existing YAML config files, and config files often use anchors and aliases.</p> <p>Well not only did we add support, we took them to the next level!</p> <p>YAML has the concept of multiple documents in a single file. Unfortunately, this is not very useful in the real world; at least not for config files. One problem is that YAML doesn't allow you to make an anchor in one document and use an alias to it in another document.</p> <p>YS makes great use of multi-doc combined with anchors and aliases.</p> <p>Here's an example YS file <code>file.ys</code> that is part of my upcoming talk at Open Source Summit North America on Thursday\u00a0 :</p> <pre><code>!YS-v0\n\n--- !data\n\n- &amp;data !\n  yaml/load: read('data.yaml')\n\n- &amp;map1\n  key: value\n\n- &amp;seq1\n  - one\n  - two\n\n- &amp;dogs !\n  yaml/load:\n    curl:: https://yamlscript.org/dogs.yaml\n\n--- !data\n\nsome: plain data string\nnumber: 42\n\nsentence::\n  \"$(*data.name) likes\n  $(*data.langs.rand-nth())!!!\"\n2 dogs:: .*dogs.big.shuffle().take(2)\n\nsequence: !concat*:\n- *seq1\n- [three, four]\nmapping: !merge*:\n- this: that\n- *map1\n</code></pre> <p>The <code>data.yaml</code> file that gets loaded looks like this:</p> <pre><code>name: Ingy\nlangs:\n- Bash\n- Clojure\n- CoffeeScript\n- Perl\n- YS\n</code></pre> <p>When you run <code>ys -Y file.ys</code> you get:</p> <pre><code>some: plain data string\nnumber: 42\nsentence: Ingy likes CoffeeScript!!!\n2 dogs:\n- Saint Bernard\n- Great Dane\nsequence:\n- one\n- two\n- three\n- four\nmapping:\n  this: that\n  key: value\n</code></pre> <p>Note</p> <p>I really do like CoffeeScript! A lot!!</p> <p>I'll let you figure out what's happening here. It should be fairly obvious and I think it's all pretty cool.</p>"},{"location":"blog/2024-04-16/ys-spring-update/#moving-forward","title":"Moving Forward","text":"<p>That was a lot of information, I know. I haven't really found the time to blog about these changes on a regular basis.</p> <p>Hopefully I'll be able to do that more in the future.</p> <p>Cheers!</p>"},{"location":"blog/2024-06-20/dr-strangeyaml-or-how-i-learned-to-stop-worrying-and-love-the-llm/","title":"Dr. StrangeYAML or How I Learned to Stop Worrying and Love the LLM","text":"<p>Well now, what happened is, uh, one of our data scientists, uh, well, he went a little funny in the head. You know. Just a little funny. And uh, he went and did a silly thing.</p> <p>Well, I'll tell you what he did. He started chatting with computers... in YAML.</p> <p>Well, let me finish, Elon.</p> <p>Let me finish, Elon.</p> <p>Well, listen, how do you think I feel about it?</p> <p>A couple weeks ago my old friend Paul Prescod\u00a0  asked me if there was a simple subset of YAML that could be used to communicate with LLM\u00a0 s.</p> <p>I was a bit aghast at the notion for 2 reasons.</p> <p>The first was that simplifying YAML is a bit like simplifying a black hole. (GitHub Copilot wrote that line for me but I like it.) It's just not something you (ergo I) want to do.</p> <p>The second reason was that surely something simpler like JSON would be a better choice for this kind of thing.</p> <p>But then I thought \"Black holes? Meh.\", so I listened to Paul's idea.</p> <p>His notion was that LLMs only have 3 major, text-based, structured data formats to train on: XML, JSON, and YAML. The internet is crammed full of these files. He said it turns out that YAML is the most efficient when combined with current LLM tokenization techniques.</p> <p>It seems Paul may be right:</p> <ul> <li>OpenAI co-founder Andrej Karpathy on YAML vs JSON for LLMs\u00a0 </li> <li>YAML vs. JSON: Which Is More Efficient for Language Models?\u00a0 </li> </ul> <p>Why is this important? The only thing that people really seem to care about:</p> <p>Money.</p> <p>LLM pricing models are based on token usage.</p> <p>DO THE MATH.</p> <p>Over the next few weeks Paul and I are planning to experiment in depth and hopefully either prove or disprove that this is a good idea.</p>"},{"location":"blog/2024-06-20/dr-strangeyaml-or-how-i-learned-to-stop-worrying-and-love-the-llm/#can-ys-help-with-this","title":"Can YS Help with This?","text":"<pre><code>$ yamllm 'Be Dr Strangelove discovering YAMLScript (https://yamlscript.org)'\n\nllama3-70b-8192:\n(Maniacal laughter) Ahahahahah! Oh, the beauty of it! The sheer genius!\nYAMLScript, you say? (Strokes chin) I must admit, I am intrigued. A language\nthat combines the simplicity of YAML with the power of a scripting language?\n(Giggles) It's like a Strangelovian dream come true!\n\n(Reading from the YAMLScript website) \"YAMLScript is a scripting language that\nallows you to write scripts in YAML, with a syntax similar to Ansible\nplaybooks.\" Ah, yes! The elegance of YAML, married to the flexibility of a\nscripting language. It's like a match made in heaven! (Chuckles) And the best\npart? It's designed for automation, just like my beloved Doomsday Device!\n\n(Excitedly) Oh, the possibilities! With YAMLScript, I can automate the\ndeployment of my Doomsday Device, ensuring that the world is destroyed in a most\nefficient and elegant manner! (Maniacal laughter) And the syntax, oh the syntax!\nSo simple, so intuitive. Even a General Turgidson could understand it!\n(Chuckles)\n\n(Reading further) \"YAMLScript has built-in support for popular automation tools\nlike Ansible, SaltStack, and Puppet.\" Ah, yes! The trifecta of automation! With\nYAMLScript, I can orchestrate the destruction of the world with ease!\n(Diabolical laughter)\n\n(Strokes chin thoughtfully) But, I must admit, there is one drawback. It's not\nas... flashy as my beloved COBOL. (Smirks) But, I suppose, in the world of\nautomation, simplicity and elegance can be just as deadly as a well-placed COBOL\nprogram.\n\n(Concludes) Ah, YAMLScript, you are a worthy addition to my arsenal of doomsday\ndevices! Together, we shall bring about a new era of automated destruction!\n(Maniacal laughter)\n</code></pre> <p>One of the emerging features in YS implementation\u00a0  design is the ability to script its internals with YAML itself! Think about that. You can define the rules of how YAML is loaded without needing to write any code.</p> <p>For example, if you wanted the YAML files for your application not to contain anchors or aliases (just like GitHub Actions' YAML loader does), that's just a line or 2 of YAML.</p> <p>Maybe you like the \"Norway Problem\" so much that you want to treat your users to the \"Slovenia Problem\"! The Norway Problem (fixed in 2009 in the YAML 1.2 spec) is where the plain scalar <code>no</code> (also the Norway country code) is interpreted as the boolean <code>false</code> in YAML 1.1. With just a dash of YAML you can tell YS to treat <code>si</code> as the boolean <code>true</code>!</p> <p>So back to Paul's query. Yes, by using (a future version of) YS as your YAML loader, it would be easy for any application to define a subset of YAML that is more suitable for their LLM needs. And since the subset is defined in YAML, it can be easily shared and understood.</p> <p>Importantly, at no point is there the risk of a subset becoming invalid YAML. There's a limit to this fine tuning of YAML behavior; it all has to play within the rules of YS (which itself has to play within the rules of YAML).</p>"},{"location":"blog/2024-06-20/dr-strangeyaml-or-how-i-learned-to-stop-worrying-and-love-the-llm/#how-i-learned-to-stop-paying-for-chatgpt-and-love-the-yamllm","title":"How I learned to stop paying for ChatGPT and love the YAMLLM","text":"<p>YS is turning out to be my favorite programming language.</p> <p>Up until a couple weeks ago my only interaction with LLMs was using GitHub's Copilot to help me write blog posts like this one, and paying $20USD/month for a ChatGPT subscription I almost never used.</p> <p>When Paul and I started talking, I decided to write some programs to play around with various (free) LLM APIs like Ollama\u00a0  and Groq\u00a0 . Of course I used YS to write the programs. You saw this program in action above with the <code>yamllm</code> command asking Dr. Strangelove\u00a0  about YS. The results of my scripting efforts are pretty awesome to me. Both in how much fun it is to interact with LLMs directly using code and how clean the YS code ends up being.</p> <p>Note</p> <p>Full Disclosure: The YS code is clean because when it's not I can (and do) fix the language. Honestly, I think this is a very important point and should be a goal of any new programming language. Implementing a sizable number of Rosetta Code Tasks\u00a0  should be a prerelease milestone.</p>"},{"location":"blog/2024-06-20/dr-strangeyaml-or-how-i-learned-to-stop-worrying-and-love-the-llm/#show-me-the-code","title":"Show me the code!","text":"<p>The GitHub repository for the YAMLLM script is at https://github.com/yaml/yamllm\u00a0 .</p> <p>It should take you about 60 seconds to get it running\u00a0  on your machine (Linux or MacOS).</p> <p>The main YS source file is at https://github.com/yaml/yamllm/blob/main/bin/yamllm.ys\u00a0 .</p> <p>Give it a look and let me know what you think\u00a0 .</p> <p>Note</p> <p>Note that at 140 lines of YS, the code might seem big at first, but realize that (aside from the JSON, YAML and HTTP libraries that are embedded in the YS runtime) this is all the source code in one file. No external dependencies.</p> <p>Sometimes I wonder if it's all worth it\u2026 Let me ask a friend:</p> <pre><code>$ yamllm 'Do you think YAMLscript (yamlscript.org) will be a success?'\n\nllama3-70b-8192:\nWhat a fascinating question!\n\nYAMLscript (yamlscript.org) is an interesting project that aims to create a\nscripting language that uses YAML as its syntax. The idea is to make scripting\nmore accessible and easier to read/write, leveraging the simplicity and\nfamiliarity of YAML.\n\nTo predict its success, let's consider a few factors:\n\n**Pros:**\n\n1. **Simplification**: YAMLscript's syntax is designed to be easy to read and\n   write, which could attract users who find traditional programming languages\n   intimidating.\n2. ** Familiarity**: YAML is already widely used in many industries, so the\n   learning curve might be shorter for developers already familiar with YAML.\n3. **Interoperability**: YAMLscript's ability to integrate with existing YAML\n   tools and workflows could lead to a seamless adoption process.\n\n**Cons:**\n\n1. **Competition**: The scripting language landscape is crowded, with\n   established players like Python, JavaScript, and PowerShell.\n2. **Adoption**: YAMLscript will need to gain significant traction and adoption\n   to become a viable alternative to existing scripting languages.\n3. **Ecosystem**: Building a comprehensive ecosystem of libraries, frameworks,\n   and tools will take time and effort.\n\n**Success factors:**\n\n1. **Community involvement**: If YAMLscript can build a strong, engaged\n   community that contributes to its development, it will increase its chances\n   of success.\n2. **Use cases**: Identifying specific use cases where YAMLscript shines, such\n   as data processing or automation, could help it gain traction.\n3. **Innovation**: Continuous innovation and improvement of the language and its\n   ecosystem will be crucial to stay competitive.\n\n**Conclusion:**\n\nWhile it's difficult to predict the future, YAMLscript has an interesting value\nproposition. If it can build a strong community, identify compelling use cases,\nand continuously innovate, it has a chance to succeed. However, it will need to\novercome the challenges mentioned above to gain significant traction in the\nscripting language market.\n\nWhat do you think about YAMLscript? Do you see any potential use cases or\nadvantages that could contribute to its success?\n</code></pre> <p>Huh. They answered a question with a question\u2026 Smart little (er, large) language model.</p> <p>I'll have to answer them in another post!</p> <p></p>"},{"location":"blog/2024-06-20/dr-strangeyaml-or-how-i-learned-to-stop-worrying-and-love-the-llm/#ps-perl-strangelove","title":"PS (Perl Strangelove???)","text":"<p>I should mention that I'm giving a couple talks about YS at The Perl and Raku Conference\u00a0  in Las Vegas next week.</p> <p>Hope to see you there!!!</p>"},{"location":"blog/2024-07-17/go-julia/","title":"Go Julia!","text":"<p>Last week two new language bindings were added to the YS family: Go\u00a0  and Julia\u00a0 .</p>"},{"location":"blog/2024-07-17/go-julia/#go","title":"Go","text":"<p>The Go\u00a0  binding has been a long time coming. Several people have been working on it this year but it was Andrew Pam\u00a0  who finally got it over the finish line.</p> <p>Go is a big user of the YAML data language, so we're happy to be able to provide this library and hope to see it used in many Go projects.</p>"},{"location":"blog/2024-07-17/go-julia/#julia","title":"Julia","text":"<p>The Julia\u00a0  binding was a bit more of a recent surprise addition. A few weeks ago a Julia hacker dropped by the YAML Chat Room\u00a0  to ask some questions about YAML. I ended up asking him more about Julia and if he could help write a YS binding.</p> <p>He invited Kenta Murata\u00a0  to the chat room and Kenta said he could do it for us. Then Kenta disappeared for a few weeks. Last week he came back with a fully working Julia binding for YS!</p> <p>Fun fact: Julia is Clark Evans\u00a0  favorite programming language! Clark is one of the original authors of the YAML data language.</p>"},{"location":"blog/2024-07-17/go-julia/#ys-loader-libraries","title":"YS Loader Libraries","text":"<p>These YS language bindings are intended to be an alternative YAML loader library for the respective languages. They can load normal existing YAML files in a consistent way, and common API across all languages. They can also load YAML files with embedded YS code, to achieve data importing, transformation, interpolation; anything a programming language can do.</p> <p>The current list of YS loader libraries is:</p> <ul> <li>Clojure\u00a0 </li> <li>Go\u00a0 </li> <li>Java\u00a0 </li> <li>Julia\u00a0 </li> <li>NodeJS\u00a0 </li> <li>Perl\u00a0 </li> <li>Python\u00a0 </li> <li>Raku\u00a0 </li> <li>Ruby\u00a0 </li> <li>Rust\u00a0 </li> </ul>"},{"location":"blog/2024-07-17/go-julia/#join-the-fun","title":"Join the Fun!","text":"<p>If your language is missing a YS binding or you want to help improve one, please drop by the YS Chat Room\u00a0  and we'll get you started.</p> <p>All of the bindings are part of the YS Mono-Repo\u00a0  on GitHub. If you look at the existing bindings, you'll see that they are all quite small. You'll need to learn about basic FFI (Foreign Function Interface) for your language, to make calls to the YS shared library <code>libyamlscript</code>, but that's about it.</p> <p>It's a great way to get started with a new language project.</p>"},{"location":"blog/2024-07-17/go-julia/#some-future-plans","title":"Some Future Plans","text":"<p>There's a lot of upcoming work planned for YS. I've mapped some of it out in the YS Roadmap\u00a0 .</p> <p>Currently YS (written in Clojure\u00a0 , which compiles to JVM bytecode, which\u2026) compiles to a native binary interpreter using the GraalVM <code>native-image</code> compiler\u00a0 . This is great for performance and distribution, but it's not great for portability, limiting it to Linux, MacOS and Windows.</p> <p>The JVM is a great platform for portability, so we're planning to make a JVM version of the <code>ys</code> YS interpreter. Of course, having YS available as a JVM language is also a good thing for Linux, MacOS and Windows users.</p> <p>We also want to make WebAssembly\u00a0 , JavaScript and C++ versions of the YS interpreter.</p> <p>And of course we still want to get to our goal of 42 language bindings!!!</p> <p>Lots of fun stuff to explore!</p>"},{"location":"blog/2024-10-05/the-fall-of-yamlscript/","title":"The Fall of YAMLScript!","text":""},{"location":"blog/2024-10-05/the-fall-of-yamlscript/#or-exciting-ys-news-for-fall-2024","title":"(or Exciting YS News for Fall 2024!)","text":"<p>Greetings!</p> <p>It's been over 3 months since the last blog post here.</p> <p>Just to be clear, the YS/YAMLScript project is alive and fantastic!</p> <p>We've just been busy as hell on 2 very big things: Exercism  and KubeCon .</p> <p>To be successful in both of these endeavors, YS needed to be amazing both as a programming language (Exercism) and as a data language (KubeCon).</p> <p>There's so much new stuff to talk about, and I promise to write about all of it after things get back to a normal pace.</p> <p>Today let's talk about Exercism, KubeCon and the positive impacts they've had on YS.</p>"},{"location":"blog/2024-10-05/the-fall-of-yamlscript/#exercism","title":"Exercism","text":"<p>When I learned about the \"free programming language learning website\" called Exercism\u00a0  in June, it supported 71 language tracks\u00a0 . I hoped that YS/YAMLScript could become number 72.</p> <p>I was in Las Vegas at The Perl and Raku Conference\u00a0  where I met Daniel Mita who is a maintainer of the Perl\u00a0  and Raku\u00a0  tracks on Exercism. Over breakfast, he told me all about the Exercism platform and and it sounded great. I asked him if it would be possible to add a YS track to Exercism.</p> <p>Some hours later he had started the process to make that happen...</p> <p>Fast forward to mid September; the YAMLScript track is live as number 74 !</p> <p>The YAMLScript track\u00a0  currently offers 60 exercises of varying difficulty levels. Try it out and let us know what you think!</p>"},{"location":"blog/2024-10-05/the-fall-of-yamlscript/#how-exercism-made-ys-better","title":"How Exercism Made YS Better","text":"<p>To get the YS track launched it was required that at least 20 exercises be set up. We launched with 42, of course!</p> <p>To set up an exercise for a track, you need to write a program that passes a series of tests that are provided for the exercise. Personally I wanted these YS solutions to be as simple and beautiful as possible.</p> <p>The main way YS has grown as a language is from actually writing code with it and seeing what works beautifully and what doesn't. If something can be done to make the language better, we do it.</p> <p>I can confidently say that YS produces some of the most beautiful solutions to the Exercism exercises. In fact I wrote a program\u00a0  (in YS) that compares the YS solutions to all the other languages on Exercism as a markdown page and then posts it as a GitHub gist page.</p> <p>I won't share these gists here, because that would be a spoiler for the Exercism platform. But since all these solutions are publicly available and open source, you can run that program yourself and see the results.</p> <p>However I did think of a way to do something similar that I can share here...</p> <p>I wrote a another (nearly identical) program\u00a0  that compares YS solutions to other languages for the massive open source code site Rosetta Code\u00a0 .</p> <p>Here's a few example gists that compare Rosetta Code YS solutions to those in the Exercism set of languages:</p> <ul> <li>99-bottles-of-beer\u00a0 </li> <li>FizzBuzz\u00a0 </li> <li>Floyds-triangle\u00a0 </li> <li>Rot-13\u00a0 </li> </ul> <p>As you can see, YS programs turn out to to be very clean, simple and easy to read.</p> <p>If you are going to enhance your YAML files with functional logic, it's reassuring to know that YS has the full power of a mature programming language behind it (Clojure), presented in a way that is not only as easy to read as YAML, but is actually 100% valid YAML.</p> <p>Let's segue to KubeCon, where we focus on YS as a way to tame large YAML configuration files for Kubernetes and other software frameworks.</p>"},{"location":"blog/2024-10-05/the-fall-of-yamlscript/#kubecon","title":"KubeCon","text":"<p>In early June I proposed a 90 minute YS tutorial for KubeCon and it was accepted! I'll be presenting it a week from this Friday (November 15th in Salt Lake City). If you are going to be at the conference, I hope we get a chance to talk.</p> <p>The YS needs for Kubernetes\u00a0  (and other) config files are very different from its needs for Exercism. Kubernetes is configured with YAML, as are many other software frameworks used by Cloud Native\u00a0  programmers.</p> <p>While YS is a great as a programming language, one of its main goals has always been to fix as many of the problems people have with YAML as possible.</p> <p>Of course, we are aware that there are already lots of tools that help with managing large YAML files for various applications. YS is not trying to replace those tools, but to augment them.</p> <p>For instance, many people use Helm\u00a0  to manage their Kubernetes. Helm is a complete package manager for Kubernetes, that comes with a Go based templating system.</p> <p>YS can be used instead of (or in combination with) Helm's templating system.</p> <p>Let's look at an example of using YS in a Helm chart template.</p> <p>Here's a snippet of a template file created by <code>helm create mychart</code>:</p> <pre><code>  {%- raw -%}\n  spec:\n    {{- with .Values.volumes }}\n    volumes:\n      {{- toYaml . | nindent 8 }}\n    {{- end }}\n    {{- with .Values.nodeSelector }}\n    nodeSelector:\n      {{- toYaml . | nindent 8 }}\n    {{- end }}\n  {% endraw %}\n</code></pre> <p>With YS, you can write this as:</p> <pre><code>  spec:\n    :when+ Values.volumes.?:: {volumes:: _}\n    :when+ Values.nodeSelector.?::\n     nodeSelector:: _\n</code></pre> <p>Not only is the YS version much shorter and easier to read, its also valid YAML. That means it can be maintained using other YAML tools, like <code>yamllint</code>. It also gets rid of the need for the <code>nindent</code> explicit indenting function, which is a common source of errors in Helm templates.</p> <p>If you want to see an entire Helm chart written converted to YS, we made a repository\u00a0  with 2 commits: one with the original Helm chart and one after the conversion.</p> <p>Or you can simply look at this gist\u00a0  which shows the changed files side by side. This gist was also generated by a new YS program called sbs\u00a0  (side by side).</p>"},{"location":"blog/2024-10-05/the-fall-of-yamlscript/#how-kubecon-made-ys-better","title":"How KubeCon Made YS Better","text":"<p>Just because YS is a great programming language, and embeddable in YAML, doesn't mean that it will be a natural fit for every common config file need.</p> <p>As we reviewed the needs for using YS in Helm charts, we found a couple things that could be improved.</p> <p>The first was being able to load external data and define variables in a file that is just data.</p> <p>As you might recall, to use YS in a YAML file, you need to use the special <code>!YS-v0:</code> tag at the top. Note the difference between that tag and the <code>!YS-v0</code> tag that we need to start a YS program.</p> <p>The trailing slash means to start off in \"data mode\" instead of \"code mode\". This means the the unquoted word <code>foo</code> is a string, not a variable or function.</p> <p>But say you want to load another file and use its contents as data (without having any effect on the YAML data you are defining in the current file).</p> <p>Now you can do that (at any lexical level) with a normal YS assignment.</p> <pre><code>!YS-v0:\n\ndefault =: load('defaults.yaml')\n\nfoo:: default.foo.take(3)\nbar:\n  more =: load('more.yaml')\n  baz:: more.stuff * default:count\n</code></pre> <p>The <code>=:</code> pairs are code expressions that define new variables. The first one above applies to the entire file and the second one applies only to the map that contains it.</p> <p>Another thing we found was that we needed a way to conditionally include key/value pairs in a YAML map.</p> <p>We added a general <code>::</code> form that evaluates any code. If the evaluation result is a map, it is merged into the current map at the current position. If it evaluates to <code>nil</code>, nothing is added.</p> <pre><code>!YS-v0:\n\nfoo: 1\n::\n  when rand(2) &gt; 1::\n    bar: 2\nbaz: 3\n</code></pre> <p>This is a very powerful way to conditionally add data using any logic you want.</p> <p>However its a bit verbose for simple cases. Consider this:</p> <pre><code>!YS-v0:\n\ndata =: load('data.yaml')\n\nfoo: 1\n::\n  when data.key1::\n    bar: data.key1\nbaz: 3\n</code></pre> <p>We added a shorthand for this common case:</p> <pre><code>:when data.key1::\n bar: data.key1\n</code></pre> <p>You can collapse the <code>::</code> and the <code>when</code> function line into a single line.</p> <p>But notice the glaring redundancy of needing to write <code>data.key1</code> twice?</p> <p>We addressed that with the new <code>when+</code> function.</p> <pre><code>:when+ data.key1::\n bar: _\n</code></pre> <p>It sets the <code>_</code> variable to the value of its condition expression <code>data.key1</code>.</p> <p>Finally we can collapse that to a single line by simply using YAML's flow style:</p> <pre><code>:when+ data.key1.?:: {bar: _}\n</code></pre>"},{"location":"blog/2024-10-05/the-fall-of-yamlscript/#conclusion","title":"Conclusion","text":"<p>This Fall, the YS project is in a really good place. It's both a great programming language and a great data language. While it is already extremely capable, we are always looking for ways to make it better.</p> <p>I'm very excited to present all this next week at KubeCon. And again, I hope to see you there!</p>"},{"location":"blog/2024-11-29/the-kubernetes-effect/","title":"The Kubernetes Effect","text":"<p>In my many years of creating Open Source software and talking about it at conferences, some of the most productive development times are often those leading up to the presentation.</p> <p>In the last post, I mentioned that I was going to present a 90 minute YS tutorial\u00a0  at KubeCon (November 15th in Salt Lake City)\u00a0 .</p> <p>The conference was amazing and the YS tutorial was a huge success. I came away with the feeling that YAML and YS had found their community. KubeCon felt like YAMLCon!</p> <p>But today's post is about the work leading up to the conference and the new data oriented features that were added to YS as a result.</p> <p>At the start of October we realized there were a few things we wanted to add to the language to make it great for defining dynamic data in YAML files.</p> <p>YS is a complete programming language and while you could already do almost anything with it, we knew that it had blend smoothly into the existing YAML files that people use for Kubernetes and other uses. We started by focusing on Helm charts, and seeing how well YS could fit along side the Go templating system (or replace it entirely). In the end it all worked out very well, but a few things needed to be added before tutorial time.</p> <p>Note</p> <p>TL;DR for Helm Users: https://yamlscript.org/doc/helmys\u00a0 </p> <p>In this post I want to cover some of the new (and old) features of YS that you can use to do cool things in your YAML files that are not possible with YAML alone. And remember, your YAML files are already valid YS files; but if you load them (or preprocess them) with YS, you can do a lot more in there.</p>"},{"location":"blog/2024-11-29/the-kubernetes-effect/#what-yaml-can-do-now","title":"What YAML Can Do Now","text":"<p>YAML 1.2 has a few things that let you do things a bit fancier than with a data only format like JSON:</p> <ul> <li>YAML has anchors and aliases for reusing specific nodes by naming them, and   then later referring to them by name.</li> <li>YAML has a special <code>&lt;&lt;</code> \"merge key\" that you can use to merge mappings.   This was actually removed from the 1.2 spec but many popular implementations   still support it (albeit with inconsistent behavior between implementations).</li> <li>YAML allows you to tag nodes and this can sometimes be used creatively, though   not consistently across different YAML implementations.</li> <li>YAML supports multiple \"documents\" in a single file or stream, although   unfortunately the spec doesn't allow you to alias nodes across documents.</li> </ul> <p>YS supports all of these features too. It needs to since it claims to support the current YAML files of the world. But YS being a complete programming language lets you go so much further!</p> <p>Let's take a closer look\u2026</p>"},{"location":"blog/2024-11-29/the-kubernetes-effect/#external-and-internal-data-sources","title":"External (and Internal) Data Sources","text":"<p>Even though YAML lets you reuse nodes by name, those nodes need to be part of your YAML document. Say you have a section at the top of your YAML file that defines some default values and names them with anchors, to be aliased later throughout the file.</p> <p>This is problematic because the node of defaults is also going to be a part of your data when you load it. It would be nice if you could have 2 documents in a YAML file where you define the data sources to be referred to in the first document, and then refer to them in the second document. If the loader returned the final (second) document then you could get the data you wanted without also getting the data that you don't.</p> <p>Let's try it out:</p> <pre><code># file.yaml\n---\n- &amp;map1\n  name: Bobbi Datamon\n- &amp;list1\n  - fun\n  - games\n- more: stuff\n\n--- !YS-v0:\nperson:\n  &lt;&lt;: *map1\n  likes: *list1\n</code></pre> <p>Now we can load it with the YS command line interpreter, <code>ys</code>:</p> <pre><code>$ ys --load file.yaml\n{\"person\":{\"name\":\"Bobbi Datamon\",\"likes\":[\"fun\",\"games\"]}}\n</code></pre> <p>Looks like it worked, but <code>ys --load</code> prints the result in compact JSON. Before we discuss what happened, let's show the result in YAML:</p> <pre><code>$ ys --load --yaml file.yaml\nperson:\n  name: Bobbi Datamon\n  likes:\n  - fun\n  - games\n</code></pre> <p>Nice! <code>ys --load</code> gave us the data from the final document that included data from the first document.</p> <p></p> More about loading YS <p>You can just use <code>ys --yaml</code> (or even <code>ys -Y</code>) instead of <code>ys --load --yaml</code>. Use <code>-J</code> (for <code>--json</code>) to format <code>--load</code> output as a prettier JSON.</p> <p>The YS \"load\" operation defaults to JSON because it is designed to output data in an interoperable form. JSON is very interoperable and the JSON data model is a subset of the YAML data model.</p> <p>Instead of using <code>ys</code> to load YAML/YS files, you can use a YS library to replace other YAML loaders in 10 (and counting) common programming languages, including Python, Go, Ruby, Rust, Java and JavaScript.</p> <p>For example, in Python you could do this:</p> <pre><code>from yamlscript import YAMLScript\nys = YAMLScript()\ntext = open(\"db-config.yaml\").read()\ndata = ys.load(text)\n</code></pre> <p>and similar in any other language that has a YS binding library.</p> <p><p></p></p> <p>The careful reader will have noticed that we broke the rules of YAML. We aliased  nodes that were anchored in a different document. What's up?</p> <p>Well, the two YS documents each have a different YS mode and that makes things work differently.</p> <p>The first document has no <code>!YS-v0</code> tag and thus is in \"bare mode\". In bare mode all the rules are the same as YAML 1.2 (using the Core schema).</p> <p>The second document has the <code>!YS-v0:</code> tag. The <code>!YS-v0</code> tag tells YS that the document is in \"code mode\" (the content starts as code but can switch to data mode at any time). The <code>:</code> in <code>!YS-v0:</code> tells YS to switch to data mode right away.</p> <p>In code mode and data mode, aliases are very different than in bare mode. They can access anchored nodes in the same document or any previous document. Not only that, you can access parts of the anchored node with a path syntax. For instance <code>*map1.name</code> would produce the string \"Bobbi Datamon\" and <code>*list1.1</code> would produce the string \"games\".</p> <p>That means that this works the same way as the previous example:</p> <pre><code>--- &amp;data\nmap1:\n  name: Bobbi Datamon\nlist1:\n- fun\n- games\nmore: stuff\n\n--- !YS-v0:\nperson:\n  &lt;&lt;:: -*data.map1\n  likes:: -*data.list1\n</code></pre> <p>Here we only anchored the entire first document and then used the path syntax to access the parts we wanted. Note that to do this we used <code>::</code> to switch to code mode and we also needed to used <code>-</code> to escape the values and have them be treated as YS expressions.</p> <p>YS has special <code>+++</code> symbol that evaluates to an array of all the prior documents in the stream. That means we don't need anchors at all:</p> <pre><code>map1:\n  name: Bobbi Datamon\nlist1:\n- fun\n- games\nmore: stuff\n\n--- !YS-v0:\nperson:\n  &lt;&lt;:: +++.last().map1\n  likes:: +++.$.list1\n</code></pre> <p>The <code>+++.last()</code> function returns the last document in the stream so far (the first document in this case) The <code>+++.$</code> is a shorthand for <code>+++.last()</code>.</p> <p>Another approach to take here is to make the first document use YS in code mode and define variables to use in the second document:</p> <pre><code>--- !YS-v0\nmap1 =::\n  name: Bobbi Datamon\nlist1 =::\n- fun\n- games\n\n--- !YS-v0:\nperson:\n  &lt;&lt;:: map1\n  likes:: list1\n</code></pre> <p>We use <code>=:</code> for assignment expressions in YS. And <code>=::</code> does the same thing but toggles the mode of the value.</p> <p>What if <code>list1</code> was a huge list and you really wanted to keep it in a separate file?</p> <p>No problem:</p> <pre><code># big-list.yaml\n- fun\n- games\n# ...\n</code></pre> <p>Now we just change the first document to load the list from the file:</p> <pre><code>--- !YS-v0\nmap1 =::\n  name: Bobbi Datamon\nlist1 =: load('big-list.yaml')\n</code></pre> <p>Not only can we access external data from a file, YS supports fetching data from the web with the <code>curl</code> function and also getting data from databases!</p>"},{"location":"blog/2024-11-29/the-kubernetes-effect/#inline-code-in-data-mode","title":"Inline Code in Data Mode","text":"<p>We can do the same things in a single data mode document. The trick is that we need to have a way to evaluate code in a way that doesn't affect the data.</p> <p>The <code>::</code> syntax is our new friend here.</p> <p>This lets us do code things like define variables and even define new functions in a way that doesn't affect the data we are defining.</p> <pre><code>--- !YS-v0:\n::\n  defn flip(array):\n    reverse: array\n\n  map1 =::\n    name: Bobbi Datamon\n  list1 =: load(\"big-list.yaml\")\n\nperson:\n  &lt;&lt;:: map1\n  likes:: list1:flip\n</code></pre> <p>We defined a new function called <code>flip</code> which is a bit contrived since we could have called <code>reverse</code> directly; but it proves the point.</p> <p>We also defined our data variables. We can actually define variables without <code>::</code>:</p> <pre><code>--- !YS-v0:\nmap1 =::\n  name: Bobbi Datamon\nlist1 =: load(\"big-list.yaml\")\n\nperson:\n  &lt;&lt;:: map1\n  likes:: list1\n</code></pre> <p>In a big document, it's sometimes nice to define the data variables closer to where they are used.</p> <pre><code>--- !YS-v0:\nmap1 =::\n  name: Bobbi Datamon\n\nperson:\n  &lt;&lt;:: map1\n  list1 =: load(\"big-list.yaml\")\n  likes:: list1\n</code></pre> <p>In fact, since we only use <code>map1</code> and <code>list1</code> once, we could have just inlined them:</p> <pre><code>--- !YS-v0:\nperson:\n  &lt;&lt;:\n    name: Bobbi Datamon\n  likes:: load(\"big-list.yaml\")\n</code></pre>"},{"location":"blog/2024-11-29/the-kubernetes-effect/#how-do-i-merge-thee","title":"How Do I <code>merge</code> Thee?","text":"<p>Let me count the ways :)</p> <p>We are still using the <code>&lt;&lt;</code> merge key to merge mappings, but YS has a standard <code>merge</code> function (among 100s of others).</p> <pre><code>--- !YS-v0:\nmap1 =::\n  name: Bobbi Datamon\nlist1 =: load(\"big-list.yaml\")\n\nperson::\n  merge::\n  - ! map1\n  - likes:: list1\n</code></pre> <p>Note the <code>!</code> in front of <code>map1</code>. It toggles from data mode to code mode. We need to use <code>!</code> for that purpose in data mode sequences. For mappings we can use <code>key:: variable</code> but it is just a shorthand for <code>key: ! variable</code>.</p> <p>Another way to write that is:</p> <pre><code>person::\n  merge map1::\n    likes:: list1\n</code></pre> <p>Since the <code>merge</code> key is already in code mode we can just put the <code>map1</code> variable there.</p> <p>Sometimes you want to use a function like <code>merge</code> without needing to further indent the data you are applying the function to.</p> <p>YS lets you put a function in a tag if you prefix it with a<code>:</code>:</p> <pre><code>--- !YS-v0:\nmap1 =::\n  name: Bobbi Datamon\nlist1 =: load(\"big-list.yaml\")\n\nperson: !:merge\n- ! map1\n- likes:: list1\n</code></pre>"},{"location":"blog/2024-11-29/the-kubernetes-effect/#conditional-insertions-in-mappings-and-sequences","title":"Conditional Insertions in Mappings and Sequences","text":"<p>A big missing feature (and one definitely needed for Helm charts) was the ability to conditionally insert key/value pairs into mappings depending on some value being true or false.</p> <p>Functionally that's a bit weird for a data language. You can always apply any function to any data node to change its value, but how do you make it control whether or not it exists at all?</p> <p>You really need to apply a function to its parent mapping to make that happen\u2026</p> <p>\u2026or do you?</p> <p>YS ended up solving this using the <code>::</code> syntax, with a special rule.</p> <pre><code>!YS-v0:\nfoo: 111\n::\n  when a &gt; b::\n    bar: 222\nbaz: 333\n</code></pre> <p>The rule is that if the code under <code>::</code> evaluates to nil then ignore it. If it evaluates to a mapping then merge it into the parent mapping.</p> <p>Note</p> <p>The <code>when</code> function returns nil if the condition is false, and the body evaluation value if it is true.</p> <p>To best understand this we can simply compile this YS to Clojure code.</p> <pre><code>$ ys -U --compile file.yaml  # or -c\n(merge {\"foo\" 111} (merge (when (&gt; a b) {\"bar\" 222}) {\"baz\" 333}))\n</code></pre> <p>Note</p> <p>You should know by now that every YS program is compiled to Clojure code and then evaluated. Well, data files that use YS are no different!</p> <p>Given that <code>merge</code> ignores nil values, this is exactly what we want.</p> <p>As we worked through the standard Helm templates we found that while this worked just fine, it was a bit verbose. We \"fixed\" that by letting you put the condition test \"inside\" the <code>::</code> key:</p> <pre><code>!YS-v0:\nfoo: 111\n:when rand(100) &gt; 50::\n  bar: 222\nbaz: 333\n</code></pre> <p>I've changed <code>a &gt; b</code> here to something you could actually run yourself. Note that before we never defined <code>a</code> or <code>b</code>, so that would have failed.</p> <p>We can even get this into a single line by using YAML's flow style:</p> <pre><code>!YS-v0:\nfoo: 111\n:when rand(100) &gt; 50:: {bar: 222}\nbaz: 333\n</code></pre> <p>Nice!</p> <p>Now that you are up to speed, take a look at this page that shows how to completely convert a stock Helm chart to use YS instead of Go templating: https://yamlscript.org/doc/helmys\u00a0 </p> <p>After the KubeCon we realized that this was also needed for sequences. You should be able to conditionally insert items into a sequence at any point.</p> <p>All you need to do is use all of the above on a <code>- ...</code> sequence entry (returning a sequence or nil):</p> <pre><code>!YS-v0:\n- aaa\n- :when rand(100) &gt; 50::\n  - foo\n  - bar\n- zzz\n</code></pre> <p>Again let's compile this to Clojure code to see exactly what it does:</p> <pre><code>$ ys -c file.yaml\n(concat [\"aaa\"] (concat (when (&gt; (rand 100) 50) [\"foo\" \"bar\"]) [\"zzz\"]))\n</code></pre> <p>Similar to the mapping case, but we get <code>concat</code> instead of <code>merge</code> to do the right thing with sequences.</p> <p>Now we run it a couple times:</p> <pre><code>$ ys -Y file.yaml\n- aaa\n- zzz\n$ ys -Y file.yaml\n- aaa\n- foo\n- bar\n- zzz\n</code></pre> <p>and Voil\u00e0!</p>"},{"location":"blog/2024-11-29/the-kubernetes-effect/#conclusion","title":"Conclusion","text":"<p>I hope this post gave you some good ideas about how cleanly you can extend your YAML data files with YS. And also how this is applicable today in major YAML consumers like Helm.</p> <p>Please let us know\u00a0  where YS can be made even better.</p> <p>That's our goal!</p>"},{"location":"blog/2025-03-10/yamlscript-is-ys/","title":"YAMLScript is YS!","text":"<p>Greetings! And welcome back to YAMLScript\u00a0  in 2025!</p> <p>Or as we now say, YS in '25!.</p> <p>It's been a minute since our last update, but we've been working super hard to make YS the best it can be.</p> <p>Oh\u2026 What's \"YS\", you say?</p> <p>Well, don't say \"Y-S\"\u2026</p>"},{"location":"blog/2025-03-10/yamlscript-is-ys/#say-wise","title":"Say \"Wise\"!","text":"<p>Think of YS as the plural of \"Y\".</p> <p>The more Ys, the better!</p> Why didn't the owl ask Y?  <p>  She was 2 YS!</p> <p>YS is the new nickname for YAMLScript. It's shorter, easier to write, and kinda fun to say. It's even more fun to add it to the start or end of a word. like \"PennyYS\" (\"Pennywise\") or \"YSAcre\".</p> <p>We have quite a few little projects already that use YS and have it in their names. Like these:</p> <ul> <li>HelmYS (Helmwise) -   A project to use YS for Kubernetes Helm charts templates.</li> <li>SchemaYS - A new schema language project for YAML created with YS.</li> <li>MarkdownYS\u00a0  -   A Markdown preprocessor that uses inline YS and YAML to generate repetitive   content from data.   Click View (eye icon) at the top of the YS Standard Library doc to see it in action.</li> </ul> <p>We even have a short new domain name \"getys.org\" for YS downloads/installs: <pre><code>curl -s https://getys.org/ys | bash  # Install the latest YS\n</code></pre></p>"},{"location":"blog/2025-03-10/yamlscript-is-ys/#love-at-second-site","title":"Love at Second Site","text":"<p>Check out our new yamlscript.org website\u00a0 !</p> <p>Material for MkDocs\u00a0  is so great. We love it!</p> <p>I honestly don't think there will ever be a better framework for making static websites. It's so feature rich and all the features actually work together. Almost every feature is configured with a line or two of YAML. What could be better than that?</p> <p>We even added a few new YS features in places where we needed them, and there was very little work to do it.</p> <p>I'll write a full blog post about the new website soon, (the blog plugin makes it so easy to write and publish posts), but for now, here's a few highlights:</p> <ul> <li>Almost every page has a \"View Source\", \"Edit this Page\", or \"Discuss this   Page\" button at the top.   Including this one!   Try them out.</li> <li>All pages are written in Markdown or MarkdownYS, so it should be trivial for   you to contribute if you want to add, fix or discuss something.</li> <li>Everything on the site is part of the YS Open Source Mono-Repo\u00a0  in the <code>www</code> directory   on the <code>website</code> branch.</li> </ul>"},{"location":"blog/2025-03-10/yamlscript-is-ys/#so-many-ys-bits-to-share","title":"So Many YS Bits to Share\u2026","text":"<p>I'm really looking forward to sharing all the new YS features with you. Now that we have the perfect platform for writing and publishing, I expect to be writing a whole lot more very soon.</p> <p>Until then, take care and be YS!</p>"},{"location":"blog/2025-03-24/run-a-yaml-file-with-bash/","title":"Run a YAML File with Bash!","text":"<p>Wait, what?!!?</p> <p>Run a YAML file?</p> <p>And with Bash?</p> <p>How is that possible?</p>"},{"location":"blog/2025-03-24/run-a-yaml-file-with-bash/#step-0","title":"Step 0","text":"<p>Let's run this simple YAML <code>file.yaml</code>:</p> <pre><code>name: Fido\nage: 3\ndog years: age * 7\n</code></pre> <p>When we run this file, we'd like to see this JSON output:</p> <pre><code>{\n  \"name\": \"Fido\",\n  \"age\": 3,\n  \"dog years\": 21\n}\n</code></pre> <pre><code>$ bash file.yaml\nfile.yaml: line 1: name:: command not found\nfile.yaml: line 2: age:: command not found\nfile.yaml: line 3: dog: command not found\n</code></pre> <p>Well that didn't work...</p> <p>Let's not give up yet.</p>"},{"location":"blog/2025-03-24/run-a-yaml-file-with-bash/#step-1","title":"Step 1","text":"<p>Let's forget about Bash for a moment and just load the YAML file with YS\u00a0 :</p> <pre><code>$ ys -J file.yaml\n{\"name\":\"Fido\", \"age\":3, \"dog years\":\"age * 7\"}\n</code></pre> <p>Close, but look at the <code>dog years</code> value. It's just a string.</p> <p>We need to tell YS to evaluate the expression <code>age * 7</code> as a math expression.</p> <p>YS won't do any evaluation unless we tell it to with the <code>!YS-v0:</code> tag. Then we need to tell YS that just the <code>dog years</code> value should be evaluated. We do that with the <code>::</code> syntax:</p> <pre><code>!YS-v0:\nname: Fido\nage: 3\ndog years:: age * 7\n</code></pre> <p>Let's run it:</p> <pre><code>$ ys -J file.yaml\nError: Could not resolve symbol: age\n</code></pre> <p>Oh, right. The <code>age</code> symbol is not defined here. Luckily we can define it inline:</p> <pre><code>!YS-v0:\nname: Fido\nage =: 3\nage:: age\ndog years:: age * 7\n</code></pre> <p>Again:</p> <pre><code>$ ys -J file.yaml\n{\"name\":\"Fido\", \"age\":3, \"dog years\":21}\n</code></pre> <p>Sweet! We have the JSON output we wanted.</p> <p>Note: We could do the same thing with an anchor and alias:</p> <pre><code>!YS-v0:\nname: Fido\nage =: &amp;age 3\ndog years:: 7 * *age\n</code></pre>"},{"location":"blog/2025-03-24/run-a-yaml-file-with-bash/#now-back-to-bash","title":"Now Back to Bash","text":"<p>OK. But this YAML file is definitely not a Bash script.</p> <p>But maybe we can make it one?</p> <p>Let's try this:</p> <pre><code>#!/usr/bin/env ys-0\nsource &lt;(echo 'export YS_FORMAT=json' &amp;&amp; curl '-s' 'https://getys.org/run') \"$@\":\n---\n!YS-v0:\nname: Fido\nage: &amp;age 3\ndog years:: 7 * *age\n</code></pre> <p>Now:</p> <pre><code>$ bash file.yaml\n{\"name\":\"Fido\", \"age\":3, \"dog years\":21}\n</code></pre> <p>Woah! It worked! We just ran a YAML file with Bash!</p> <p>But how?</p> <p>Well I cheated a bit and showed you the second time I ran it. The first time I ran it, I got this:</p> <pre><code>$ bash file.yaml\nInstalling YS CLI '/tmp/yamlscript-run-ys/bin/ys-0.1.95' now...\nCtl-C to abort\nSee https://yamlscript.org/doc/run-ys for more information.\n\nInstalled /tmp/yamlscript-run-ys/bin/ys - version 0.1.95\n--------------------------------------------------------------------------------\n{\"name\":\"Fido\", \"age\":3, \"dog years\":21}\n</code></pre> <p>The first time you run the file, it installs YS under <code>/tmp</code> and then runs the file with YS. The second time you run it, it just runs the file with YS.</p>"},{"location":"blog/2025-03-24/run-a-yaml-file-with-bash/#the-polyglot-magic","title":"The Polyglot Magic","text":"<p>It turns out that the first two lines of the file are both valid Bash and valid YS!</p> <p>The first line is a Bash shebang that invokes YS, but we ran the file with Bash.</p> <p>Let's change the shebang to call Bash instead:</p> <pre><code>#!/usr/bin/env bash\nsource &lt;(echo 'export YS_FORMAT=json' &amp;&amp; curl '-s' 'https://getys.org/run') \"$@\":\n---\n!YS-v0:\nname: Fido\nage: &amp;age 3\ndog years:: 7 * *age\n</code></pre> <p>Then let's make the file executable, and run it:</p> <pre><code>$ chmod +x file.yaml\n$ ./file.yaml\n{\"name\":\"Fido\", \"age\":3, \"dog years\":21}\n</code></pre> <p>Works like a charm!</p> <p>Ok so what about the second line?</p> <p>For YS, the <code>source</code> command is a no-op. A function that ignores its arguments and returns nothing.</p> <p>For Bash, we are sourcing a \"process substitution\" that curls a tiny script that will install a YS binary under <code>/tmp</code> and use it to run that file.</p> <p>We also set the <code>YS_FORMAT</code> environment variable to <code>json</code>, which tells YS to <code>--load</code> the file starting in data mode.</p> <p>Update</p> <p>It seems that you can't source a process substitution in Bash 3.2 (the default <code>/bin/bash</code> on MacOS). Fortunately, this variation works on all the versions of Bash used on Linux and MacOS:</p> <pre><code>source /dev/stdin &lt;&lt;&lt;\"$(echo 'export YS_FORMAT=json' &amp;&amp; curl '-s' 'https://getys.org/run')\" \"$@\":\n</code></pre> How can that be valid YS? <p>Again, this is both valid Bash and valid YS! Here's how YS compiles the <code>source</code> line to Clojure code:</p> <pre><code>$ ys -c -\n!YS-v0\nsource /dev/stdin &lt;&lt;&lt;\"$(echo 'export YS_FORMAT=json' &amp;&amp; curl '-s' 'https://getys.org/run')\" \"$@\":\n\n(source\n#\"dev\"\nstdin\n&lt;&lt;&lt;\n(echo \"export YS_FORMAT=json\" &amp;&amp; curl \"-s\" \"https://getys.org/run\")\n\"$@\")\n</code></pre> <p>The YS <code>source</code> function ignores its arguments, but those arguments need to be valid YS code. Ironically here <code>/dev/stdin</code> compiles as the regex form <code>/dev/</code> followed by the symbol <code>stdin</code>! Also <code>&lt;&lt;&lt;</code> is valid syntax for a YS operator, but currently there is no operator called <code>&lt;&lt;&lt;</code> in YS.</p>"},{"location":"blog/2025-03-24/run-a-yaml-file-with-bash/#but-why","title":"But Why?","text":"<p>Ok, neat trick, but how is this useful in the real world?</p> <p>First off it's a great way to write a YS program for someone who might not have YS installed. You don't even need to tell them about YS at all.</p> <p>But for data files there's a more interesting use case.</p> <p>Say you have a <code>config.yaml</code> config file for some service that you'd like to be able to use YS for instead of plain YAML. If that service already used YS to load its YAML configs then you'd be all set. But most services don't. Yet!</p> <p>What if you could put a <code>config.ys</code> file in the same directory as the <code>config.yaml</code> file and made it executable? And what if the <code>config.ys</code> file wrote its output to the <code>config.yaml</code> file when it was run? As long as you could set things up to make sure the <code>config.ys</code> file was run whenever it (or one of its dependencies) changed, you'd have a generated <code>config.yaml</code> file that would do everything you wanted it to do.</p> <p>Let's try it out. We'll make a <code>config.ys</code> file that loads an <code>other.yaml</code> file and uses environment variables to set some values:</p> <pre><code>!YS-v0:\nname: My Thing\nstuff:: load('other.yaml').stuff\n:when ENV.DEBUG.?::\n  environment:: ENV\n</code></pre> <p>And an <code>other.yaml</code> file:</p> <pre><code>stuff:\n  some: data\n</code></pre> <p>If we load it with YS we get:</p> <pre><code>$ ys -Y config.ys\nname: My thing\nstuff:\n  some: data\n</code></pre> <p>This pulled in a part of the <code>other.yaml</code> file. It also would add a map of all your environment variables if <code>DEBUG</code> was set.</p> <p>Let's add 2 lines to make it write to <code>config.yaml</code>: <pre><code>!YS-v0:\nname: My thing\nstuff:: load('other.yaml').stuff\n:when ENV.DEBUG.?::\n  environment:: ENV\n\n--- !YS-v0\nwrite FILE.replace(/\\.ys$/ '.yaml'): _:yaml/dump\n</code></pre></p> <p>Now we can run it:</p> <pre><code>$ ys config.ys &amp;&amp; cat config.yaml\nname: My thing\nstuff:\n  some: data\n</code></pre> <p>Perfect! Since YS evaluates to the last document in a multi-document file, we get what we want by running it.</p> <p>The only remaining problem is that we need to have <code>ys</code> installed to run this...</p> <p>Or do we?</p> <p>Let's try it with Bash:</p> <pre><code>#!/usr/bin/env bash\nsource &lt;(curl '-s' 'https://getys.org/run') \"$@\":\n--- !YS-v0:\n\nname: My thing\nstuff:: load('other.yaml').stuff\n:when ENV.DEBUG.?::\n  environment:: ENV\n\n--- !YS-v0\nwrite FILE.replace(/\\.ys$/ '.yaml'): _:yaml/dump\n</code></pre> <p>Now:</p> <pre><code>$ chmod +x config.ys\n$ ./config.ys &amp;&amp; cat config.yaml\nname: My thing\nstuff:\n  some: data\n</code></pre> <p>Voila! We just replaced a <code>config.yaml</code> file with a <code>config.ys</code> file for any YAML configured service.</p> <p>A More Solid Approach</p> <p>The strategy for using YS files to generate YAML files is solid. But you probably don't want to actually run them (with Bash or YS).</p> <p>A better way is to simply configure your pipeline to install YS and then run <code>ys -Y config.ys &gt; config.yaml</code> at the appropriate time.</p>"},{"location":"blog/2025-03-24/run-a-yaml-file-with-bash/#conclusion","title":"Conclusion","text":"<p>I hope you've enjoyed this little journey into the world YS, YAML, and Bash.</p> <p>Hopefully it gives you some interesting ideas for how to use YS in your own projects.</p> <p>Please let us know if you come up with any super cool uses for this technique.</p> <p>Happy YAMLing!</p> <p>PS Ingy (that's me!) will be at KubeCon in London\u00a0  next week.</p> <p>Let's talk about YS, HelmYS, or whatever you'd like!</p>"},{"location":"blog/2025-06-01/the-summer-of-ys/","title":"The Summer of YS","text":"<p>Today starts a 3 month long, daily summertime journey into the intricacies of YAML and the wisdom of YS! Put on your favorite pair of coding sunglasses, grab a refreshing config drink, and let's get started!</p> <p>Back in March I promised to start writing more often about all the ways that YS can help you out day-to-day with your YAML interactions. When I last posted here it was barely Spring and now Spring is turning into Summer.</p> <p>Seasonal turning points be damned, I think of Summer as June, July, and August. In other words...</p> <p>It's Summer dammit!</p> <p>Let's declare this Summer, The Summer of YS!</p>"},{"location":"blog/2025-06-01/the-summer-of-ys/#summertime-and-the-yamls-easy","title":"Summertime... and the YAML's Easy","text":"<p>Wanna learn 92 cool things about YAML and YS this Summer? That's one per day, for 3 months!</p> <p>I've attempted some crazy things in my days (with both success and failure), and this feels pretty crazy, but I'm gonna give it a shot.</p> <p>I'll post one (mostly short) blog post here each day until the end of August (mostly) about YAML and/or YS.</p>"},{"location":"blog/2025-06-01/the-summer-of-ys/#todays-handy-tip","title":"Today's Handy Tip","text":"<p>I'm not gonna just announce this fiasco and leave you hanging until tomorrow for your first tip. Let's get into it.</p> <p>I like to keep the lines of most of my text files (including the markdown of this very blog post) at 80 characters or less. You might have a different preference (I still love you) but that's how I roll.</p> <p>YAML is pretty good at letting you wrap long strings at places of your choosing.</p> <pre><code>phrase1: The quick brown fox jumped up and down\n  and all around while the lazy dog just lay\n  all day with nothing to say.\nphrase2:\n  The quick brown fox jumped up and down and all\n  around while the lazy dog just lay all day\n  with nothing to say.\nphrase3: \"The quick brown fox jumped up and down and all around while the lazy dog just lay all day with nothing to say.\"\nphrase4: \"\\\n  The quick brown fox jumped up and down and all around\n  while the lazy dog just lay all day with nothing to say.\"\nphrase5: &gt;\n  The quick brown fox jumped up and down and all around\n  while the lazy dog just lay all day with nothing to say.\n</code></pre> <p>These values are all the same. They just use different YAML syntax to wrap the string. YAML generally wraps multiline strings, by collapsing a newline (and leading whitespace) into a single space.</p> <p>But what if you have a long string with no whitespace at all? This is a common problem when you have long URLs in your YAML files.</p> <p>There is a way to split these long strings in YAML, and it only works with double quoted scalars.</p> <pre><code>loong: https://gist.githubusercontent.com/ingydotnet/2e5a79b0b29e548a39a90dba10846042/raw/c05feff49521caf004b5656dcb0e94715a30fffd/stdin\nshort: \"https://gist.githubusercontent.com/\\\n        ingydotnet/\\\n        2e5a79b0b29e548a39a90dba10846042/\\\n        raw/\\\n        c05feff49521caf004b5656dcb0e94715a30fffd/\\\n        stdin\"\n</code></pre> <p>Just use a backslash at the end of each line in a double quoted scalar and it will collapse without a space.</p> <p>Are these 2 values exactly the same?</p> <p>I don't have a magic 8-ball, so let's use (wise ol') YS to find out!</p> <pre><code>$ ys -pe '_.short == _.loong' - &lt;&lt;'...'\nloong: https://gist.githubusercontent.com/ingydotnet/2e5a79b0b29e548a39a90dba10846042/raw/c05feff49521caf004b5656dcb0e94715a30fffd/stdin\nshort: \"https://gist.githubusercontent.com/\\\n        ingydotnet/\\\n        2e5a79b0b29e548a39a90dba10846042/\\\n        raw/\\\n        c05feff49521caf004b5656dcb0e94715a30fffd/\\\n        stdin\"\n...\ntrue\n</code></pre> <p>YS Replies:</p>"},{"location":"blog/2025-06-01/the-summer-of-ys/#it-is-decidedly-so","title":"It is decidedly so!","text":""},{"location":"blog/2025-06-01/the-summer-of-ys/#see-you-tomorrow","title":"See You Tomorrow!","text":"<p>One down, 91 to go!</p> <p>How hard can this be?</p> <p>Tomorrow I think I'll show you how to use variables in YAML. You always wanted to know, right?</p>"},{"location":"blog/2025-06-02/yaml-variables/","title":"YAML Variables","text":"<p>YAML itself isn't a functional programming language, but advanced users are probably aware of YAML's anchors, aliases and the merge key.</p> <p>The merge key is YAML's one functional thing, and it's actually not even part of the YAML 1.2 spec\u00a0 . However, people find it useful and many YAML implementations (including YS) support it.</p> <p>The merge key (<code>&lt;&lt;</code>) is a special key that allows you to merge the contents of one mapping into another.</p> <p>Today we'll explore the merge key a bit and show how variables can make it nicer to use.</p>"},{"location":"blog/2025-06-02/yaml-variables/#the-merge-key","title":"The Merge Key","text":"<p>Consider the following YAML file:</p> <pre><code># shoes.yaml\n- &amp;defaults\n  size: 10\n  color: blue\n\n- name: sneaker\n  &lt;&lt;: *defaults\n  color: red\n\n- name: boot\n  &lt;&lt;: *defaults\n  color: black\n\n- name: sandal\n  size: 8\n  &lt;&lt;: *defaults\n</code></pre> <p>We can convert it to JSON with YS:</p> <pre><code>$ ys -J shoes.yaml\n[{\"size\":10, \"color\":\"blue\"},\n {\"name\":\"sneaker\", \"color\":\"red\", \"size\":10},\n {\"name\":\"boot\", \"color\":\"black\", \"size\":10},\n {\"name\":\"sandal\", \"size\":8, \"color\":\"blue\"}]\n</code></pre> <p>Here we define a mapping of default values with an anchor name of <code>&amp;defaults</code>, and then we merge it into each of the other mappings using the merge key <code>&lt;&lt;</code> and a value alias of <code>*defaults</code>.</p> <p>This works out ok but it has a problem. Can you see it?</p> <p>We've defined a sequence of 3 shoe mappings, but we have 4 things in the sequence. The defaults mapping itself is a (probably unwanted) part of the sequence.</p> <p>The problem with this common scenario is that there is no way in YAML itself to declare the thing that is to be merged, but not have it be part of the result.</p>"},{"location":"blog/2025-06-02/yaml-variables/#ys-variables-to-the-rescue","title":"YS Variables to the Rescue","text":"<p>There are so many things I could show you about YS using this example, but today I'll just use it to introduce you to YS variables. (Remember, I have at least 90 more posts to write this summer!)</p> <p>Let's change the YAML file to use a variable to store the default values. Here's one way to do that:</p> <pre><code>!YS-v0\n\ndefaults =::\n  size: 10\n  color: blue\n\n=&gt;::\n- name: sneaker\n  &lt;&lt;:: defaults\n  color: red\n\n- name: boot\n  &lt;&lt;:: defaults\n  color: black\n\n- name: sandal\n  size: 8\n  &lt;&lt;:: defaults\n</code></pre> <p>Let's load that and see what we get:</p> <pre><code>$ ys -J shoes2.yaml\n[{\"name\":\"sneaker\", \"color\":\"red\", \"size\":10},\n {\"name\":\"boot\", \"color\":\"black\", \"size\":10},\n {\"name\":\"sandal\", \"size\":8, \"color\":\"blue\"}]\n</code></pre> <p>That's more like it!</p>"},{"location":"blog/2025-06-02/yaml-variables/#ys-syntax-review","title":"YS Syntax Review","text":"<p>Let's take a moment to review the YS syntax we used here.</p> <p>Note</p> <p>I'll probably say it a lot this summer, but I'll say it now:</p> <p>YAML with YS is always 100% valid YAML. It literally has to be. That topic should be an interesting post.</p> <p>Maybe mid-July...</p> <ol> <li>We start with <code>!YS-v0</code> to indicate that we want this file to be able to use    code features like variables.</li> <li>We define a variable called <code>defaults</code> with a value of our default values.</li> <li>We use <code>::</code> instead of <code>:</code> when we need to switch from code mode to data    mode (or vice versa).    More on that in a future post.</li> <li>The <code>::</code> after the merge key means that the value word <code>defaults</code> is a    variable (not the string <code>\"defaults\"</code>).</li> <li>We use the dummy key <code>=&gt;</code> to evaluate everything as a sequence rather than a    mapping (because the YAML document was already a mapping due to the variable    assignment).</li> </ol>"},{"location":"blog/2025-06-02/yaml-variables/#see-you-tomorrow","title":"See You Tomorrow!","text":"<p>There is sooo much more that I could tell you about YAML and YS just in the context of this little example. But I'm going to pace myself and take it slow.</p> <p>After all, it's Summertime. </p> <p>See ya tomorrow!</p>"},{"location":"blog/2025-06-03/ys-yaml-documents/","title":"YS YAML Documents","text":"<p>YAML files (aka YAML streams) can contain multiple \"documents\".</p> <p>A YAML document is a top level mapping or sequence \"node\". Most YAML files contain a single document, but YAML files can contain multiple (or zero!) documents. New documents are started with a line of three dashes: <code>---</code>.</p> <p>YS can put these documents to all kinds of good use.</p> <p>When you \"load\" a YAML file with YS, the result is the evaluation of the final document (by default). But since YS is functional, it can access any of the other documents.</p> <p>Let's continue with yesterday's shoes example.</p>"},{"location":"blog/2025-06-03/ys-yaml-documents/#anchors-up","title":"Anchors Up","text":"<p>One of the (unfortunate, imho) rules of YAML is that you can't use aliases to reference anchored nodes in other documents.</p> <pre><code>$ ys -Y - &lt;&lt;&lt;'\n--- &amp;number 7\n---\nlucky: *number\n'\nError: Anchor not found: &amp;number\n</code></pre> <p>Since YS follows the the rules of the YAML 1.2 spec, it can't do what we want here. This is just a plain old YAML \"stream\" (complete YAML file or string).</p> <p>What happens if we supercharge things with the YS <code>!YS-v0</code> tag?</p> <pre><code>$ ys -Y - &lt;&lt;&lt;'\n--- &amp;number 7\n--- !YS-v0:\nlucky: *number\n'\nlucky: 7\n</code></pre> <p>Nice!</p> <p>Enabling YS for a document allowed us to play by YS rules and access (alias) anchored nodes in other documents. That's handy.</p> <p>But wait. Why did we use <code>!YS-v0:</code> instead of just <code>!YS-v0</code>?</p> <ul> <li><code>!YS-v0</code> - This document is YS code. (start in code mode)</li> <li><code>!YS-v0:</code> - This doc is data, but YS magics are enabled. (start in data mode)</li> <li>Documents without either are just plain YAML. No YS magics. (bare mode)</li> </ul> <p>We'll talk more about mode setting tags in a future post.</p>"},{"location":"blog/2025-06-03/ys-yaml-documents/#new-shoes","title":"New shoes!","text":"<p>Let's take what we just learned and refactor our shoes example.</p> <pre><code># shoes.yaml\n--- &amp;defaults\nsize: 10\ncolor: blue\n\n--- !YS-v0:\n- name: sneaker\n  &lt;&lt;: *defaults\n  color: red\n\n- name: boot\n  &lt;&lt;: *defaults\n  color: black\n\n- name: sandal\n  size: 8\n  &lt;&lt;: *defaults\n</code></pre> <p>And now load it:</p> <pre><code>$ ys -J shoes.yaml\n[{\"name\":\"sneaker\", \"color\":\"red\", \"size\":10},\n {\"name\":\"boot\", \"color\":\"black\", \"size\":10},\n {\"name\":\"sandal\", \"size\":8, \"color\":\"blue\"}]\n</code></pre> <p>That's cleaner than yesterday's examples.</p>"},{"location":"blog/2025-06-03/ys-yaml-documents/#docs-and-variables","title":"Docs and Variables","text":"<p>Anchors are OK, but they're a bit noisy compared to variables.</p> <p>For fun, let's try using both with multiple documents.</p> <pre><code>---\n- &amp;size 10\n- &amp;color blue\n\n--- !YS-v0\ndefaults =::\n  color: *color\n  size: *size\n\n--- !YS-v0:\n- name: sneaker\n  &lt;&lt;:: defaults\n  color: red\n\n- name: boot\n  &lt;&lt;:: defaults\n  color: black\n\n- name: sandal\n  size: 8\n  &lt;&lt;:: defaults\n</code></pre> <p>Then:</p> <pre><code>$ ys -J shoes.yaml\n[{\"name\":\"sneaker\", \"color\":\"red\", \"size\":10},\n {\"name\":\"boot\", \"color\":\"black\", \"size\":10},\n {\"name\":\"sandal\", \"size\":8, \"color\":\"blue\"}]\n</code></pre> <p>This example is somewhat contrived, but it shows off most everything we've talked about so today.</p> <p>We have 3 documents here.</p> <p>In the first document, instead of anchoring the defaults mapping, we anchored the size and color values. This document had no starting tag, so it's plain old YAML (bare mode).</p> <p>Next, we used a code mode document to define a variable named <code>defaults</code> which contains the size and color values. It got the values by aliasing the size and color values from a different document. Note the use of <code>=::</code> (extra colon) to switch to data mode to define the mapping.</p> <p>Finally we have our data mode document that produces the mapping we want. It references the <code>defaults</code> variable we defined in the previous document by using <code>::</code> to switch over to code mode when needed.</p> <p>Pretty cool.</p>"},{"location":"blog/2025-06-03/ys-yaml-documents/#walking-in-these-shoes","title":"Walking in these Shoes","text":"<p>There's a few more interesting topics we can get into using the shoes example.</p> <p>If this is all seeming too simple, believe me, we'll be getting into some deep waters this summer. Patience, young hacker.</p> <p>A YS guy once said:</p> <p>\"The journey of 92 days begins with a few steps in these shoes.\"</p> <p>See you tomorrow!</p>"},{"location":"blog/2025-06-04/load-and-compose-your-yaml-files/","title":"Load and Compose your YAML Files","text":"<p>Probably the biggest problem people have with YAML is that everything has to be in one file. Things start off nice and clean, but as requirements grow, so do your files!</p> <p>What if you could compose your YAML documents like you compose your code? Lots of small, single-purpose, possibly reusable files that you can load and compose together into the thing you need?</p> <p>That's what YS is all about. As you know, YS is a functional language, and it has quite a few ways to load data (and code too, since Code is Data\u2122!) from external sources.</p> <p>Today we'll be looking at how to load things from disk files, including:</p> <ul> <li>Other YS files</li> <li>YAML files (YAML is YS)</li> <li>JSON files (JSON is YAML)</li> </ul> <p>You can also load things from CSV/TSV files, shell commands, databases, APIs, environment variables, and the web, but those are topics for another day.</p>"},{"location":"blog/2025-06-04/load-and-compose-your-yaml-files/#loading-yaml-files","title":"Loading YAML Files","text":"<p>YS has a standard library function called <code>load</code> that can load YS files.</p> <p>Since YAML is YS, you can load YAML files with <code>load</code>. And since JSON is YAML, you can also load JSON files with <code>load</code>.</p> <p>Let's try on some new shoes!</p> <p>We'll put each shoe in its own file.</p> <pre><code># shoe1.yaml\nname: sneaker\ncolor: red\n</code></pre> <pre><code># shoe2.json\n{\n  \"name\": \"boot\",\n  \"color\": \"black\"\n}\n</code></pre> <pre><code># shoe3.ys\n!YS-v0:\nname: sandal\nsize:: 2 * 2 * 2\n</code></pre> <p>I got a little cheeky on that third shoe. I used a YS expression to calculate the size! That's just to show that YS expressions evaluate on load.</p> <p>Let's load them all together.</p> <pre><code># shoes.yaml\n!YS-v0:\n- ! load('shoe1.yaml')\n- ! load('shoe2.json')\n- ! load('shoe3.ys')\n</code></pre> <p>Notice the <code>!</code> there? Remember the <code>::</code> mode switcher?</p> <p>Well <code>::</code> is just a nice shorthand for <code>!</code>. It works great with mapping pairs, but for sequence entries, there's no way to use it, so we need to use <code>!</code> instead.</p> <pre><code>$ ys -Y shoes.yaml\n- name: sneaker\n  color: red\n- name: boot\n  color: black\n- name: sandal\n  size: 8\n</code></pre> <p>It works, but we don't have the defaults in there.</p> <p>We'll make a defaults file like this:</p> <pre><code># defaults.yaml\nsize: 10\ncolor: blue\n</code></pre> <p>Now we could use the merge key (<code>&lt;&lt;</code>) to add it to the YAML and YS files, but that would never work in a JSON file.</p> <p>Fortunately, YS is a functional language with 100s of functions. Surely it has a <code>merge</code> function!</p> <pre><code># shoes.yaml\n!YS-v0:\n- ! merge(load('defaults.yaml'), load('shoe1.yaml'))\n- ! merge(load('defaults.yaml'), load('shoe2.json'))\n- ! merge(load('defaults.yaml'), load('shoe3.ys'))\n</code></pre> <p>And then:</p> <pre><code>$ ys -Y shoes.yaml \n- size: 10\n  color: red\n  name: sneaker\n- size: 10\n  color: black\n  name: boot\n- size: 8\n  color: blue\n  name: sandal\n</code></pre> <p>There we go!</p>"},{"location":"blog/2025-06-04/load-and-compose-your-yaml-files/#theres-more-than-one-way-to-do-it","title":"There's More Than One Way To Do It","text":"<p>I was raised by Perl wolves! (well, Monks in wolf's clothing)</p> <p>As we progress through the Summer of YS, you'll notice Perlisms showing up here and there. For all its warts, Perl is has a lot of gems. Maybe that's what Matz was thinking when he created Ruby and based so much of it on Perl? I've stolen many of those shiniest gems for YS.</p> <p>Anyway, in YS\u2026 TMTOWTDI!</p> <p>Let's rearrange our new shoes a bit:</p> <pre><code>--- !YS-v0\ndefaults =:\n  load: 'defaults.yaml'\n\n--- !YS-v0:\n- ! defaults.merge(load('shoe1.yaml'))\n- !\n  merge defaults:\n    load: 'shoe2.json'\n- !:merge*\n  - ! defaults\n  - ! load('shoe3.ys')\n</code></pre> <p>And we get:</p> <pre><code>$ ys -Y shoes.yaml \n- size: 10\n  color: red\n  name: sneaker\n- size: 10\n  color: black\n  name: boot\n- size: 8\n  color: blue\n  name: sandal\n</code></pre> <p>That's a lot of new YS syntax to unpack, but the surf's up! </p> <p>See you again tomorrow!</p>"},{"location":"blog/2025-06-05/ys-curling-up-north/","title":"YS Curling (up North)","text":"<p>Ever been to Manitoba? I went there once when my flight from Seattle to Toronto diverted to Winnipeg because the plane's toilets stopped working! That's when I learned about the World's Largest Curling Rock\u00a0 .</p> <p>Toronto DevOps Meetup</p> <p>Speaking of Toronto, I'll be giving a talk called \"The YS way to YAML\"\u00a0  at the Toronto DevOps Meetup on June 12th. That's one week from today!</p> <p>If you're in town I hope to see you there!</p> <p>Today we'll be doing a little curling with YS.</p>"},{"location":"blog/2025-06-05/ys-curling-up-north/#curling-web-data-in-ys","title":"Curling Web Data in YS","text":"<p>Yesterday we learned how load data from other files.</p> <p>Today we'll go a bit further on that and also learn how to load data from the web.</p> <p>We have some nice shoes but we don't have anyone to wear them. We can fix that. I know of a big list of people who would love to try them on, and the list is a JSON array on the web\u00a0 !</p> <p>Let's use YS to play around with that list.</p> <pre><code>$ ys -J -e '\nurl =:\n  \"https://github.com/dominictarr/random-name/raw/master/first-names.json\"\njson =: curl(url)\nlist =: json/load(json)\npeople =:\n  take 3: list\nsay: count(list)\nsay: people\n'\n4946\n(Aaren Aarika Abagael)\n</code></pre> <p>It looks like the \"curling\" function is called <code>curl</code> and it's built in. There's also a JSON loading built-in and a few other handy functions like <code>take</code> and <code>count</code>.</p> <p>4946 is a lot of people! But why limit ourselves to the first 3? A random selection of 3 is a lot more fun!</p> <pre><code>$ ys -J -e '\nurl =:\n  \"https://github.com/dominictarr/random-name/raw/master/first-names.json\"\njson =: curl(url)\nlist =: json/load(json)\npeople =: list.shuffle().take(3)\nsay: people\n'\n(Johnna Korrie Elayne)\n</code></pre> <p>I like that better.</p> <p>Did you notice the new function chaining syntax in <code>list.shuffle().take(3)</code>? We'll get into that a lot more later on, but let's have a little fun with it right now.</p> <pre><code>$ ys -J -e 'ARGS.0.curl().json/load().shuffle().take(3).say()' \\\n-- https://github.com/dominictarr/random-name/raw/master/first-names.json\n(Madlen Joete Daveta)\n</code></pre> <p>That's pretty cool. We did everything in a single (chained) expression. Chaining functions together is one of the most powerful features of YS.</p>"},{"location":"blog/2025-06-05/ys-curling-up-north/#put-your-shoes-on","title":"Put Your Shoes on!","text":"<p>We have a list of people and a list of shoes. Let's pair them up!</p> <pre><code>$ ys -e '\nurl =:\n  \"https://github.com/dominictarr/random-name/raw/master/first-names.json\"\n\npeople =: url.curl().json/load().shuffle().take(3)\nshoes =: read(\"shoes.yaml\").yaml/load()\n\nsay: str(people.0, \" wears size \", shoes.0.size, \" \", join([shoes.0.name, \"s\"]))\nsay: str(people.1, \" wears size \", shoes.1.size, \" \", join([shoes.1.name, \"s\"]))\nsay: str(people.2, \" wears size \", shoes.2.size, \" \", join([shoes.2.name, \"s\"]))\n'\nShanon wears size 10 sneakers\nHenrie wears size 10 boots\nSybil wears size 8 sandals\n</code></pre> <p>Looking good!</p> <p>The shoes I mean. The code could be be way nicer. It will, but not today.</p> <p>Notice that instead of using <code>load</code> on <code>shoes.yaml</code> we used <code>read</code> and <code>yaml/load</code>. TMTOWTDI strikes again!</p>"},{"location":"blog/2025-06-05/ys-curling-up-north/#programming-with-ys","title":"Programming with YS","text":"<p>So far we've been using YS to enhance YAML files. But can we use YS to write programs?</p> <p>Well, we just did exactly that!</p> <p>I wasn't expecting to show you that today, but that's just how it worked out. And we did all of it using YS <code>-e</code> one liners.</p> <p>That last program is just begging to use loops and string formatting, right?</p> <p>We'll get there, but for now let's get out in the sun and do some curling!</p>"},{"location":"blog/2025-06-06/loops-and-strings/","title":"Loops and Strings","text":"<p>Yesterday I left you with a program that really needed to \"YS up\"!</p> <pre><code>$ ys -e '\nurl =:\n  \"https://github.com/dominictarr/random-name/raw/master/first-names.json\"\n\npeople =: url.curl().json/load().shuffle().take(3)\nshoes =: read(\"shoes.yaml\").yaml/load()\n\nsay: str(people.0, \" wears size \", shoes.0.size, \" \", join([shoes.0.name, \"s\"]))\nsay: str(people.1, \" wears size \", shoes.1.size, \" \", join([shoes.1.name, \"s\"]))\nsay: str(people.2, \" wears size \", shoes.2.size, \" \", join([shoes.2.name, \"s\"]))\n'\n</code></pre> <p>Let's make this awesome!</p>"},{"location":"blog/2025-06-06/loops-and-strings/#ys-interpolation","title":"YS Interpolation","text":"<p>Great interpolation is something I want in every language I program in. I don't always get it, but if I'm going to invent a new language, it's a must.</p> <p>Interpolation is the ability to expand variables or expressions into a string, in place.</p> <p>Here's a quick example of both in YS:</p> <pre><code># File 'add'\n!YS-v0\na b =: ARGS\nsay: \"$a + $b = $(a + b)\"\n</code></pre> <p>When we run it like this:</p> <pre><code>$ ys add 16 26\n16 + 26 = 42\n</code></pre> <p>That's so simple. Both to write and for others to understand.</p> <p>YS allows interpolation in double quoted strings and also literal strings (the <code>|</code> syntax) when the string is in \"code mode\". Just use <code>$var</code> or <code>$(expr)</code> to evaluate and expand them in place.</p> <p>Let's use interpolation in our shoes program.</p> <pre><code>$ ys -e '\nurl =:\n  \"https://github.com/dominictarr/random-name/raw/master/first-names.json\"\n\npeople =: url.curl().json/load().shuffle().take(3)\nshoes =: read(\"shoes.yaml\").yaml/load()\n\nsay: \"$(people.0) wears size $(shoes.0.size) $(shoes.0.name)s\"\nsay: \"$(people.1) wears size $(shoes.1.size) $(shoes.1.name)s\"\nsay: \"$(people.2) wears size $(shoes.2.size) $(shoes.2.name)s\"\n'\nRebecca wears size 10 sneakers\nDian wears size 10 boots\nIolande wears size 8 sandals\n</code></pre> <p>Better!</p> <p>Let's make it better still!</p>"},{"location":"blog/2025-06-06/loops-and-strings/#loops","title":"Loops","text":"<p>We could make this better if only YS had loops!</p> <p>Pffft. We got your looping constructs right here! Several of them!</p> <p>Let's use the <code>each</code> looping function for this.</p> <pre><code>$ ys -e '\nurl =:\n  \"https://github.com/dominictarr/random-name/raw/master/first-names.json\"\n\npeople =: url.curl().json/load().shuffle().take(3)\nshoes =: read(\"shoes.yaml\").yaml/load()\n\neach i range(people.count()):  # (0, 1, 2)\n  person =: people.$i\n  shoe =: shoes.$i\n  say: \"$person wears size $(shoe.size) $(shoe.name)s\"\n'\nMyrtle wears size 10 sneakers\nPhillis wears size 10 boots\nEvonne wears size 8 sandals\n</code></pre> <p>I like it!</p>"},{"location":"blog/2025-06-06/loops-and-strings/#take-your-shoes-off","title":"Take your shoes off!","text":"<p>By this time I bet you're getting tired of seeing programs about shoes.</p> <p>Me too. Tomorrow will be different. Promise.</p> <p>It's Summertime, let's go barefoot!</p>"},{"location":"blog/2025-06-07/tmtowtdi-for-ys-expressions/","title":"TMTOWTDI for YS Expressions","text":"<p>Like I said before, in YS, There's More Than One Way To Do It.</p> <p>This is especially true for YS expressions.</p> <p>Later on you'll learn that YS is a Lisp in disguise. In Lisp, an expression is a list consisting of a function and its arguments inside a set of parentheses.</p> <p>Consider this Python code:</p> <pre><code>name = \"World\"\nprint(\"Hello, \" + name + \"!\")\n</code></pre> <p>In a Lisp, this would be written as:</p> <pre><code>(def name \"World\")\n(println (str \"Hello, \" name \"!\"))\n</code></pre> <p>In YS, this could be written as:</p> <pre><code>name =: 'World'\nsay: str('Hello, ' name '!')\n</code></pre> <p>I say could because... TMTOWTDI!</p> <p>Today I'm going to show you many of the ways to DO IT in YS.</p>"},{"location":"blog/2025-06-07/tmtowtdi-for-ys-expressions/#how-ys-relates-to-yaml","title":"How YS Relates to YAML","text":"<p>The first thing to remember is that all YS code has to be 100% valid YAML. So essentially we need to be able to write any possible Lisp code as YAML!</p> <p>Since YS wants to be clean like YAML is clean, it offers you several ways to write the same Lisp expression, make it look clean and still be valid YAML.</p> <p>Note</p> <p>The YS compiler's first job is to \"parse\" the YAML input. \"Parse\" doesn't mean the entire operation of turning YAML into a data structure. YAML calls that operation \"loading\" and it consists of many steps, the first of which is to \"parse\" the YAML into a stream of events (structs).</p> <p>The YS compiler is literally a YAML loader. Writing a YAML parser is by far the most complex part of writing a YAML loader, so YS uses a third-party parser for that part. Therefore anything that is not valid to that parser is not valid YS code! We'll talk about the YS compiler in detail later this summer.</p> <p>YS only uses YAML block mappings (the normal indented mapping style) and YAML scalars to represent code.</p> <p>Handy Tip</p> <p>If you ever see a YAML block sequence (the stuff that starts with <code>-</code>) or a YAML flow collection (the <code>{...}</code> or <code>[...]</code> stuff), it's not YS \"code\", it's just normal YAML\"data\". In other words that YS node is in \"data mode\" not \"code mode\".</p> <p>In code mode, a mapping is a set of expressions, where each key/value pair is an expression.</p> <p>Consider this YS code:</p> <pre><code>$ ys -e '\nname =: \"World\"\nsay:\n  str: \"Hello, \", name, \"!\"\n'\nCompile error: while parsing a block mapping\n in reader, line 5, column 3:\n      str: \"Hello, \", name, \"!\"\n      ^\nexpected &lt;block end&gt;, but found ','\n in reader, line 5, column 17:\n      str: \"Hello, \", name, \"!\"\n</code></pre> <p>What went wrong?</p> <p>Look at this code as regular YAML. You can't have any text after a double quoted string, right? This is a parser error.</p> <p>To get around this, YS has a special escape character. <code>+ \"Hello, \" + name + \"!\"</code> turns that whole value code into a plain (unquoted) YAML scalar. The <code>+</code> is removed and the rest gets compiled as part of an expression.</p> <p>Let's try again:</p> <pre><code>$ ys -e '\nname =: \"World\"\nsay:\n  str: + \"Hello, \", name, \"!\"\n'\nHello, World!\n</code></pre> <p>Better.</p>"},{"location":"blog/2025-06-07/tmtowtdi-for-ys-expressions/#commas-aside","title":"Commas Aside","text":"<p>Time to let you in on a little secret.</p> <p>In YS code, Commas are Whitespace!</p> <p>The commas separating the arguments above were not necessary.</p> <pre><code>$ ys -e '\nname =: \"World\"\nsay:\n  str: \"Hello, \" name \"!\"\n'\nHello, World!\n</code></pre> <p>Commas are necessary in YAML flow collections though.</p> <p>It is idiomatic YS to not use commas in code mode unless they really add clarity.</p> <p>That way, when you do see commas, you'll know you are likely in data mode.</p>"},{"location":"blog/2025-06-07/tmtowtdi-for-ys-expressions/#more-ways-to-do-it","title":"More Ways to Do It","text":"<p>Let's look at several ways to write that \"say Hello World\" expression.</p> <pre><code>$ ys -e '\nname =: \"World\"\n\n# Block form\nsay:\n  str: + \"Hello, \" name \"!\"\n\n# Lisp form\nsay: (str \"Hello, \" name \"!\")\n\n# YS call form\nsay: str(\"Hello, \" name \"!\")\n\n# Chained form\n=&gt;: str(\"Hello, \" name \"!\").say()\n\n# Chained colon form\n=&gt;: str(\"Hello, \" name \"!\"):say\n\n# Tag function form\n=&gt;: !:say\n  str: + \"Hello, \" name \"!\"\n\n# Or\n=&gt;: !:say\n  str(\"Hello, \" name \"!\")\n'\nHello, World!\nHello, World!\nHello, World!\nHello, World!\nHello, World!\nHello, World!\nHello, World!\n</code></pre> <p>I'll explain each of these forms more as we go.</p> <p>For now, 2 things.</p> <p><code>foo:bar:baz</code> is shorthand for <code>foo.bar().baz()</code>. You can optionally use <code>:xyz</code> instead of <code>.xyz()</code> when chaining a function call that takes no arguments.</p> <p>And what's the <code>=&gt;</code> thing?</p> <p>Remember, YS is YAML and we are in a YAML block mapping. We can't use expressions where some are key/value pairs and some are plain scalars. When we have something that is just a scalar, we can make it a pair by adding the <code>=&gt;</code> placeholder key.</p> <p>OK! It's time to get on with my Summer weekend!</p> <p>See you next time!</p>"},{"location":"blog/2023-10-26/welcome-to-the-ys-blog/","title":"Welcome to the YS Blog","text":"<p>Greetings!</p> <p>Welcome to the YS blog.</p> <p>This is where we will introduce you to novel concepts about YS as the language evolves.</p>"},{"location":"community/","title":"YS Community","text":"<p>YS is a community-driven, Open Source Programming Language, with a focus on making YAML better everywhere.</p> <p>While YS is a \"full\" programming language, it is far from complete. There's so much interesting stuff to work on. We welcome your participation and contributions.</p> <p>Here are some ways you can get involved:</p> <ul> <li>Be Social</li> <li>Improve the Docs</li> <li>Contribute to YS</li> </ul>"},{"location":"contrib/","title":"Contribute to YS","text":"<p>YS is an open-source project and we welcome contributions from the community. There are many ways to contribute, from writing tutorials or blog posts, improving the documentation, submitting bug reports and feature requests or writing code which can be incorporated into YS itself.</p> <p>Want to help out with YS? Great! Here are some ways you can contribute:</p> <ul> <li>Use YS \u2014   The more people that use YS, the more feedback we get, and the better   the language becomes.</li> <li>Report Bugs\u00a0  \u2014   If you find a bug in YS, please report it.</li> <li>Request Features\u00a0  \u2014   If you have an idea for a feature in YS, please let us know.</li> <li> <p>Submit Pull Requests \u2014   If you know your way around Clojure\u00a0  a bit (or are willing to learn),   try improving YS by submitting a code pull request.</p> <p>Adding a new function or fixing a bug in the YS Standard Library\u00a0  is a great way to start.</p> </li> <li> <p>Write Documentation \u2014   Go here to learn how to contribute to the YS documentation.</p> </li> <li>Write Tests \u2014   Have a look at these tests:<ul> <li>YS Compiler/Core Tests\u00a0 </li> <li>YS Runtime Tests\u00a0 </li> </ul> </li> </ul> <p> </p> <p> </p> <p> </p> <p> </p>"},{"location":"doc/","title":"Welcome to the YS Documentation","text":"<p>YS is a still a fairly new language, and this documentation is a work in progress.</p> <p>While we hope that you find the information you came looking for here, we know that there are still many gaps in the documentation.</p> <p>The good news is \"You Can Help!\".</p> <p>Writing great documentation is a team effort, and we are trying to make it as easy as possible for you to contribute.</p> <p>Almost every page on this site (including this one!!) has an \"Edit this page\" button at the top:</p> <p></p> <p>As you read the documentation, if you find a typo or something that is unclear, you can click the \"Edit this page\" button, make the changes, and submit a pull request.</p> <p>Furthermore, most pages (and all the documentation pages) have a \"Discuss this page\" button at the top:</p> <p></p> <p>If you have ideas on how to improve the page or have questions about the content, this will take you to a YS GitHub Discussions\u00a0  discussion about the page (or to instructions on how to start a new discussion for a page that doesn't have one yet).</p> <p>We look forward to this YS journey together and hope that you will help us make the documentation the best it can be!</p>"},{"location":"doc/4clojure/","title":"YS for Clojurians","text":"<p>If you happen to already be fluent in the Clojure programming language, you have a huge head start for learning YS; at least for reading and understanding YS code.</p> <p>For the most part understanding YS code is a matter is simply understanding a bunch of simple transformations that turn it into Clojure code.</p> <p>This page will cover most of the transformations you'll need to know.</p> <p>Note</p> <p>After reading this page, you should be able to read YS code and also be able write working YS code fairly easily. To write really good, idiomatic YS code, you should also be well versed in all the various YAML forms, and when to best use them. Like anything, practice makes perfect!</p>"},{"location":"doc/4clojure/#foreword","title":"Foreword","text":"<p>YS is a language made from a combination of YAML and Clojure, and its design tries to combine the best of both worlds. This might seem like a bad idea at first, but it actually works out surprisingly well.</p> <p>YS interpreter (compiler and runtime) is:</p> <ul> <li>Written in Clojure</li> <li>Compiles to Clojure code</li> <li>Evaluates with a Clojure runtime</li> </ul> <p>But the primary YS audience is not Clojure programmers! While YS is a complete programming language, and can be used for any task in general, it will likely be most useful for people who need more from their YAML. All YAML config files are valid YS code and YS code is always 100% valid YAML.</p> <p>This document is not an attempt to convert Clojure programmers to YS. It is simply meant to help people learn YS faster if they already know Clojure.</p>"},{"location":"doc/4clojure/#syntax-intro","title":"Syntax Intro","text":"<p>Clojure is a Lisp. Lisp code is comprised of list forms, value forms, comments and whitespace. Clojure has a somewhat richer syntax than your typical Lisp, adding brackets and braces for some forms and reader macros for others. Still, structurally there is very little to learn.</p> <p>YAML code is a data language that unlike JSON or EDN offers quite a few syntactic constructs like comments, anchors, aliases, tags, block (indented) and flow (bracketed) collections styles and 5 different scalar quoting styles: plain (unquoted), single quoted, double quoted, literal and folded.</p> <p>YS makes use of all of these constructs to make a clean looking programming language that simultaneously works as a data language.</p> <p>The main takeaway here is that YS offers a lot more flexibility in ways to write code than Clojure (Lisp) does.</p> <p>Note</p> <p>Whether \"more\" ways is better or worse is entirely up to you. It's just important to point out from the start that YS has this flexibility and you should expect to see it in the code.</p>"},{"location":"doc/binary/","title":"Compiling YS to Binary","text":"<p>You can compile any YS program that has a <code>main</code> function to a machine native binary executable.</p> <p>This is done using the <code>ys --compile --binary</code> command.</p> <p>For example, if you have a file named <code>hello.ys</code> with the following content:</p> <pre><code>!YS-v0\n\ndefn main(name='world'):\n  say: 'Hello, $name!'\n</code></pre> <p>You can run:</p> <pre><code>$ time ys --compile --binary hello.ys\n* Compiling YS 'hello.ys' to 'hello' executable\n* Setting up build env in '/tmp/tmp.W0u4SGljdY'\n* This may take a few minutes...\n[1/8] Initializing              (3.1s @ 0.24GB)\n[2/8] Performing analysis               (12.2s @ 0.64GB)\n[3/8] Building universe         (1.8s @ 0.45GB)\n[4/8] Parsing methods           (1.6s @ 0.46GB)\n[5/8] Inlining methods          (1.4s @ 0.63GB)\n[6/8] Compiling methods         (17.7s @ 0.43GB)\n[7/8] Laying out methods                (1.0s @ 0.49GB)\n[8/8] Creating image            (1.7s @ 0.54GB)\n* Compiled YS 'hello.ys' to 'hello' executable\n\nreal    0m48.929s\nuser    6m44.965s\nsys     0m5.095s\n$ ls -lh hello\n-rwxr-xr-x 1 me me 13M Sep 10 15:04 hello*\n</code></pre> <p>Note that the compilation takes some time and the resulting binary is quite large.</p> <p>Let's try it out:</p> <pre><code>$ time ./hello\nHello, world!\n\nreal    0m0.014s\nuser    0m0.002s\nsys     0m0.013s\n$ time ./hello Bob\nHello, Bob!\n\nreal    0m0.014s\nuser    0m0.005s\nsys     0m0.010s\n</code></pre> <p>Let's compare the 14ms runtime to using the <code>ys</code> interpreter with <code>-e</code>:</p> <pre><code>$ time ys -e 'defn main(name=\"world\"): say(\"Hello, $name!\")'\nHello, world!\n\nreal    0m0.034s\nuser    0m0.019s\nsys     0m0.017s\n</code></pre> <p>The binary is about 2.5 times faster than the interpreter in this case.</p> <p>Note that we can even compile the one-liner if we want to:</p> <pre><code>$ ys --compile --binary -e 'defn main(name=\"world\"): say(\"Hello, $name!\")'\n... time passes ...\n* Compiled YS '-e' to './NO-NAME' executable\n</code></pre> <p>Since there is no input file, the binary is named <code>NO-NAME</code>.</p> <p>Optionally, you can use the <code>--output=&lt;file-name&gt;</code> to specify the output file name.</p> <p>The options listed above have short names as well:</p> <pre><code>$ ys -cbo say-hi hello.ys\n* Compiling YS 'hello.ys' to 'say-hi' executable\n...\n</code></pre>"},{"location":"doc/bindings/","title":"YS Binding Libraries","text":"<p>Your existing YAML files are perfectly valid YS files! Using a YS binding library (aka module or package) these files can be loaded into native objects just like a YAML loader would do.</p> <p>Without a <code>!YS-v0</code> tag at the top they will load the same as normal. With that tag, they can be made to take advantage of any of the vast YS functional capabilities.</p> <p>YS intends to provide a YS capable YAML loader library (module/package) for every programming language that uses YAML. These libraries are meant to be full replacements for the existing YAML loaders in that language.</p> <p>Note</p> <p>YS loaders only return data values that adhere to the JSON data model. While that model is a subset of what can be represented in YAML 1.2, it is what most users of YAML expect. In other words, YS is targeted at YAML's most popular use cases.</p>"},{"location":"doc/bindings/#advantages-of-using-ys","title":"Advantages of using YS","text":"<p>YS YAML loaders have major advantages over the existing YAML loaders:</p> <ul> <li>Same API and capabilities regardless of the programming language.</li> <li>New features and bux fixes released to all languages at the same time.</li> <li>Highly configurable. Limit YAML and YS capabilities to your exact needs.</li> <li>Created by a YAML Specification\u00a0 creator &amp; maintainer.</li> </ul>"},{"location":"doc/bindings/#currently-available-libraries","title":"Currently Available Libraries","text":"<p>Currently there are working libraries for:</p> <ul> <li>Clojure\u00a0 </li> <li>Crystal\u00a0 </li> <li>Go\u00a0 </li> <li>Java\u00a0 </li> <li>Julia\u00a0 </li> <li>NodeJS\u00a0 </li> <li>Perl\u00a0 </li> <li>Python\u00a0 </li> <li>Raku\u00a0 </li> <li>Ruby\u00a0 </li> <li>Rust\u00a0 </li> </ul> <p>Install these libraries like you would any other library for your language. You must also install the matching version of the <code>libyamlscript.so</code> shared library. See Installing YS for more info.</p> <p>You can use these libraries like any other YAML loader. Here's an example usage in Python:</p> <p>File <code>program.py</code>:</p> <pre><code>from yamlscript import YAMLScript\nys = YAMLScript()\ninput = open('file.ys').read()\ndata = ys.load(input)\nprint(data)\n</code></pre> <p>File <code>file.ys</code>:</p> <pre><code>!YS-v0:\n\n::  # Set values to use in data\n  name =: \"World\"\n  other =: load(\"other.yaml\")\n\nfoo:: -[(6 * 7), inc(41), 43.--, (3 .. 9):sum]\nbar:: other.stuff:shuffle.take(3)\nbaz:: \"Hello, $name!\"\n</code></pre> <p>File <code>other.yaml</code>:</p> <pre><code>stuff:\n- ark\n- banana\n- cat\n- doll\n- electron\n- flan\n- golf ball\n</code></pre> <p>Run:</p> <pre><code>$ python prog.py\n{'foo': [42, 42, 42, 42], 'bar': ['cat', 'flan', 'doll'], 'baz': 'Hello, World!'}\n</code></pre>"},{"location":"doc/chain/","title":"YS Dot Chaining","text":"<p>One of the most powerful features of YS is the ability to chain function calls together. Functions are chained together using the <code>.</code> operator.</p> <p>Here are some examples:</p> <pre><code>x.5                 # -&gt; (nth x 5)\nx.abc               # -&gt; (get+ x 'abc)\nx.foo()             # -&gt; (foo x)\nx.foo(abc 123)      # -&gt; (foo x abc 123)\nx.foo(abc _ 123)    # -&gt; (foo abc x 123)\nx.foo(abc 123 _)    # -&gt; (foo abc 123 x)\nx.foo(_ _ _)        # -&gt; (foo x x x)\nx.?                 # -&gt; (truey? x)\nx.!                 # -&gt; (falsey? x)\nx.++                # -&gt; (inc x)\nx.--                # -&gt; (dec x)\nx.#                 # -&gt; (count x)\nx.#?                # -&gt; (not (empty? x))\nx.#!                # -&gt; (empty? x)\nx.#++               # -&gt; (inc (count x))\nx.#--               # -&gt; (dec (count x))\nx.@                 # -&gt; (deref x)\nx.&gt;                 # -&gt; (DBG x)\nx.abc.5.foo(22).#++ # -&gt; (inc (count (foo (nth (get+ x 'abc) 5) 22)))\nx.&gt;.abc.&gt;.foo()     # -&gt; (foo (DBG (get+ (DBG x) 'abc)))\n</code></pre> <p>The <code>get+</code> looks up a key in a map (like the <code>get</code> function in Clojure) but given <code>x.y</code> looks for the string key <code>\"y\"</code> or the keyword <code>:y</code> or the symbol <code>'y</code> in the map <code>x</code>.</p> <p>Instead of needing to write <code>(:k y)</code> or <code>(get x \"y\")</code> or <code>(get x 'y)</code> depending on the type of the key, you can just write <code>x.y</code>.</p> <p>When <code>.</code> is used to call a function, the value of the LHS is passed as the first argument to the function on the RHS. When this is not the desired behavior, you can use <code>_</code> to indicate the position that the value should be passed as.</p> <p>Some core functions like <code>take</code> and <code>drop</code> (when called used the <code>.</code> operator) will automatically put the collection argument as the second argument.</p>"},{"location":"doc/cheat/","title":"YS Cheat Sheet","text":""},{"location":"doc/cheat/#ys-fundamentals","title":"YS Fundamentals","text":"<ul> <li>Valid YS code is always valid YAML</li> <li>YS has 3 modes: code, data, and bare</li> <li>Code mode data is treated as code (can toggle to data mode)</li> <li>Data mode data is treated as data (can toggle to code mode)</li> <li>Bare mode data is treated as data (cannot toggle; always normal YAML)</li> <li>YS files must start with a YS (YAMLScript) tag:</li> <li><code>!YS-v0</code> - Start in code mode</li> <li><code>!YS-v0:</code> - Start in data mode</li> <li>No tag - Start in bare mode (plain YAML; no code evaluation)</li> <li>Initial tagged pair of <code>!YS v0:</code> is an alternative; starts in bare mode</li> <li>YS code mode always uses these YAML forms:</li> <li>Block mappings (normal indented mappings; <code>:</code> separated pairs)</li> <li>Plain scalars (no quotes)</li> <li>Quoted scalars (single or double or literal (<code>|</code>))</li> <li>Theses YAML forms are NOT allowed in code mode:</li> <li>Flow mappings and sequences (<code>{}</code> and <code>[]</code>)</li> <li>Block sequences (lines starting with <code>-</code>)</li> <li>Folded scalars (<code>&gt;</code>)</li> <li>All YAML forms are allowed in data mode</li> <li><code>!</code> tag toggles between code and data mode</li> <li><code>a:: b</code> is sugar for <code>a: ! b</code> in mapping pairs</li> <li>Use <code>=&gt;: x</code> to write <code>x</code> as a mapping pair in code mode</li> </ul> <p>The following examples are in code mode unless otherwise noted.</p>"},{"location":"doc/cheat/#assignment","title":"Assignment","text":"<p>The space before the <code>=</code> is required.</p> <pre><code>hello =: 'Oh hello'\na b c =: -[1 2 3]  # Destructuring assignment\n</code></pre>"},{"location":"doc/cheat/#ys-expression-escapes","title":"YS expression escapes","text":"<p>YS expressions need to be written as valid YAML scalars. When an expression starts with YAML syntax characters like <code>{</code>, <code>[</code>, <code>*</code>, <code>#</code> then its not a valid YAML scalar. Also expressions that have stuff after a quoted string (<code>''</code> <code>\"\"</code>) are not valid YAML.</p> <p>You can turn text into a valid YAML plain scalar by prefixing it with a dash (<code>-</code>) or a plus (<code>+</code>). The dash or plus is removed when YS reads the scalar.</p> <p>Note: the dash cannot have whitespace after it, but the plus can.</p> <pre><code>-[1 2 3]: .map(inc)  # =&gt; [2 3 4]\n=&gt;: +\n  'foo' + 'bar'      # =&gt; 'foobar'\n</code></pre>"},{"location":"doc/cheat/#printing-text","title":"Printing text","text":"<pre><code>say: 'hello'        # String\nsay: hello          # Variable\nsay: \"$hello!!!\"    # Interpolated string\nsay: |              # Multiline interpolated string\n  Hello, $name!\n  How are you?\nprint: 'I have no newline'\nwarn: 'Prints to stderr (with trailing newline)'\n</code></pre>"},{"location":"doc/cheat/#define-a-function","title":"Define a function","text":"<p>YS functions, like Clojure functions, require a specific argument arity, and can be defined to be multi-arity.</p> <pre><code>defn greet(name):\n  say: \"Hello, $name!\"\n\ndefn greet(name='world'):  # Default argument\n\ndefn foo(bar *baz): # Variable number of arguments\n\ndefn foo(*):        # Any number of arguments\n\ndefn foo(_ x _):    # Ignored arguments\n\ndefn foo:           # Multi-arity function\n  (): 0\n  (x): x\n  (x y): x + y\n</code></pre>"},{"location":"doc/cheat/#call-a-function","title":"Call a function","text":"<pre><code>greet()             # Scalar call variations\ngreet('Bob')\n(greet 'Bob')\n-'Bob'.greet()\n\ngreet:              # Map pair call variations\ngreet: 'Bob'\ngreet 'Bob':\n</code></pre>"},{"location":"doc/cheat/#chain-calls","title":"Chain calls","text":"<pre><code>say: read('/usr/share/dict/words')\n     .lines():shuffle.take(3).join(' | ')\n# =&gt; specialty | mutation's | Kisangani\n</code></pre> <p>Note</p> <p><code>.lines():shuffle</code> is short for <code>.lines().shuffle()</code>. It must be be attached to something on the left.</p>"},{"location":"doc/cheat/#special-chain-operators","title":"Special chain operators","text":"<ul> <li><code>.@</code> - Short for <code>.deref()</code></li> <li><code>.$</code> - Short for <code>.last()</code></li> <li><code>.#</code> - Short for <code>.count()</code></li> <li><code>.?</code> - Short for <code>.truey?()</code></li> <li><code>.!</code> - Short for <code>.falsey?()</code></li> <li><code>.??</code> - Short for <code>.boolean()</code></li> <li><code>.!!</code> - Short for <code>.not()</code></li> <li><code>.++</code> - Short for <code>.inc()</code></li> <li><code>.--</code> - Short for <code>.dec()</code></li> <li><code>.&gt;&gt;&gt;</code> - Short for <code>.DBG()</code></li> </ul>"},{"location":"doc/cheat/#looping","title":"Looping","text":"<p>List comprehensions are done with the <code>for</code>, <code>each</code>, <code>map</code> <pre><code>each i (1 .. 3):\n  say: i\n</code></pre></p> <pre><code>map inc: (1 .. 3)\n</code></pre> <pre><code>reduce (fn [acc num] acc + num) 0: (1 .. 3)\n</code></pre> <pre><code>reduce _ 0 (1 2 3):\n  fn(acc num): acc + num\n</code></pre> <p>The <code>_</code> is a placeholder for the defined function argument. Use <code>_</code> when the function argument is too long to write in place.</p>"},{"location":"doc/cheat/#conditional-ifelse","title":"Conditional (if/else)","text":"<pre><code>if a &gt; 10:\n  say: 'BIG'\n  say: 'small'\n</code></pre> <p>The <code>if</code> construct must have a 'then' and an 'else' clause. Use the `</p>"},{"location":"doc/cheat/#conditional-cond","title":"Conditional (cond)","text":"<pre><code>cond:\n  a &lt; 5: 'S'\n  a &lt; 10: 'M'\n  a &lt; 15: 'L'\n  =&gt;: 'XL'\n</code></pre>"},{"location":"doc/cheat/#interpolation","title":"Interpolation","text":"<pre><code>say: |\n  Dear $name,\n\n  I have 3 words for you: $(words().take(3 ).join(', ')).\n\n  Yours truly, $get(ENV 'USER')\n</code></pre>"},{"location":"doc/cheat/#global-variables","title":"Global variables","text":"<pre><code>- _                 # Previous document value\n- +++               # Runtime state mapping\n- ARGV              # Command line arguments\n- ARGS              # Command line arguments parsed\n- CWD               # Current working directory\n- DIR               # Parent directory path of the current script\n- ENV               # Environment variables mapping\n- FILE              # File path of the current script\n- INC               # File loading include path\n- RUN               # Runtime information mapping\n- VERSION           # YS version\n</code></pre>"},{"location":"doc/cli/","title":"Cli","text":"<p>one</p> <p><pre><code>foo: bar\n</code></pre> two</p>"},{"location":"doc/clj-to-ys/","title":"From Clojure to YS","text":"<p>YS (YAMLScript) works by translating code written in YS to Clojure code, which is then evaluated.</p> <p>A good way to learn YS is to convert existing Clojure programs to YS.</p> <p>This tutorial will guide you through the process of converting various Clojure programs to idiomatic YS a step at a time.</p> <p>For each Clojure program, we will:</p> <ul> <li>Start with a working Clojure program</li> <li>Refactor some parts of the program to YS</li> <li>Repeat until YS is idiomatic</li> <li>Have working YS code every step of the way</li> </ul> <p>If you don't know Clojure, that's okay. We're starting simple and you can learn 2 languages for the price of one.</p> <p>Let's get started!</p>"},{"location":"doc/clj-to-ys/#hello-world","title":"Hello World","text":"<p>Since we are obligated as programmers to start with a \"Hello, World!\" program, let's look at the simplest hello-world in Clojure:</p> <pre><code>(println \"Hello, World!\")\n</code></pre> <p>It turns out the this program is already valid YS!</p> <pre><code>$ ys -e '(println \"Hello, World!\")'\nHello, World!\n</code></pre> <p>Let's save it to a file called <code>program.ys</code> and run it.</p> <pre><code>(println \"Hello, World!\")\n</code></pre> <pre><code>$ ys program.ys\n$\n</code></pre> <p>Dang. Nothing happened.</p> <p>Let's compile it to Clojure to see what's going on.</p> <pre><code>$ ys -c program.ys\n\"(println \\\"Hello, World!\\\")\"\n</code></pre> <p>Ah! It compiled to a string, because we forgot to add <code>!YS-v0</code> to the top of the file. All YAML files are valid YS files. They won't evaluate any code unless you explicitly tell them to.</p> <pre><code>!YS-v0\n(println \"Hello, World!\")\n</code></pre> <pre><code>$ ys program.ys\nHello, World!\n</code></pre> <p>There we go!</p> <p>Let's make it idiomatic now.</p> <pre><code>!YS-v0\nsay: 'Hello, World!'\n</code></pre> <p>Look mom, no parentheses!</p> <p>We turned the YAML scalar into a single pair mapping, and we changed the double-quoted string to a single-quoted string.</p> <p>Single-quoted strings are preferred in YS unless you need interpolation or special escaped characters.</p> <p>We also changed the <code>println</code> function to the <code>say</code> function, because who has time to type <code>println</code> when you just want to <code>say</code> something?!?!</p> <p>Let's compile it back to Clojure to be honest with ourselves.</p> <pre><code>$ ys -c program.ys\n(say \"Hello, World!\")\n</code></pre> <p>We got our Clojure parentheses and double-quoted string back. Clojure doesn't use single quotes for strings.</p> <p>We still have <code>say</code> instead of <code>println</code>, but that's okay because <code>ys -c</code> compiles to Clojure code intended to be run by a YS runtime, and <code>say</code> is part of the YS standard library.</p>"},{"location":"doc/clj-to-ys/#hello-20","title":"Hello 2.0","text":"<p>Let's make our little program a little more interesting.</p> <pre><code>(defn hello\n  ([name] (println (str \"Hello, \" name \"!\")))\n  ([] (hello \"World\")))\n(hello)\n(hello \"YS\")\n</code></pre> <p>We've defined a function <code>hello</code> that takes an optional <code>name</code> argument. If <code>name</code> is not provided, it defaults to <code>\"World\"</code>.</p> <p>Let's convert this to YS, but change as little as possible.</p> <pre><code>!YS-v0\n=&gt;: !clj |\n  (defn hello\n    ([name] (println (str \"Hello, \" name \"!\")))\n    ([] (hello \"World\")))\n  (hello)\n  (hello \"YS\")\n</code></pre> <p>Hmm. We added 2 lines to the top and then indented the Clojure code. Does that work?</p> <pre><code>$ ys program.ys\nHello, World!\nHello, YS!\n</code></pre> <p>Apparently it does!</p> <p>We already know about the first line. The <code>=&gt;</code> is a special key in YS, when you need to write a YAML key/value pair, but you only have a value. The compiler simply removes the <code>=&gt;</code> and uses the value as the expression.</p> <p>What did here is keep the entire Clojure code string intact using a YAML literal scalar (think heredocs) and then use the <code>!clj</code> tag to tell the YS compiler to treat the string as Clojure code.</p> <p>The <code>!clj</code> tag is a way to write Clojure things that YS does not yet support. But it can also be a good first step to converting Clojure code to YS.</p> <p>Let's keep going by leaving the function defn alone but playing with the function calls.</p> <pre><code>!YS-v0\n=&gt;: !clj |\n  (defn hello\n    ([name] (println (str \"Hello, \" name \"!\")))\n    ([] (hello \"World\")))\nhello:\nhello: 'YS'\n</code></pre> <p>We made the 2 calls to <code>hello</code> into YAML mapping pairs. The first one has no value, and that's valid in YS when a function has no arguments.</p> <p>Now let's convert the function defn to YS.</p> <pre><code>!YS-v0\ndefn hello:\n (name): (println (str \"Hello, \" name \"!\"))\n (): (hello \"World\")\nhello:\nhello: 'YS'\n</code></pre> <p>That's how you write a multi-arity function in YS. It's advanced stuff and you already learned it during hello-world! Take a moment! You deserve it!</p> <pre><code>!YS-v0\ndefn hello(name='world'):\n  (println (str \"Hello, \" name \"!\"))\nhello:\nhello: 'YS'\n</code></pre> <p>Hey! What happened to our multi-arity accomplishment? We don't need it here in YS, because YS has support for default function arguments.</p> <p>Let's finish up with a little interpolation.</p> <pre><code>!YS-v0\ndefn hello(name='world'):\n  say: \"Hello, $name!\"\nhello:\nhello: 'YS'\n</code></pre> <p>That's some idiomatic YS if I've ever seen it!</p>"},{"location":"doc/clj-to-ys/#fizzbuzz","title":"FizzBuzz","text":"<p>Let's continue our journey of refactoring cliche coding conundrums with the classic FizzBuzz\u00a0 .</p> <p>Here's a working Clojure implementation I found at Rosetta Code\u00a0 .</p> <pre><code>(defn fizzbuzz [start finish]\n  (map (fn [n]\n         (cond\n           (zero? (mod n 15)) \"FizzBuzz\"\n           (zero? (mod n 3)) \"Fizz\"\n           (zero? (mod n 5)) \"Buzz\"\n           :else n))\n    (range start finish)))\n\n(doseq [x (fizzbuzz 1 101)]\n  (println x))\n</code></pre> <p>We'll skip the <code>!clj</code> step this time and start by making this a top level YAML mapping.</p> <pre><code>!YS-v0\n\ndefn fizzbuzz(start finish):\n  (map (fn [n]\n         (cond\n           (zero? (mod n 15)) \"FizzBuzz\"\n           (zero? (mod n 3)) \"Fizz\"\n           (zero? (mod n 5)) \"Buzz\"\n           :else n))\n    (range start finish))\n\ndoseq [x (fizzbuzz 1 101)]:\n  (println x)\n</code></pre> <p>It works! Trust me! Don't do that! Run it yourself! But it works! Trust me!</p> <p>All we did was turn the top level expressions into YAML mapping pairs, by removing the outer parentheses and adding a colon in the middle.</p> <p>We also changed the defn args to use parens instead of square brackets.</p> <p>Let's make more expressions into pairs now.</p> <pre><code>!YS-v0\n\ndefn fizzbuzz(start finish):\n  map:\n    fn(n):\n      cond:\n        (zero? (mod n 15)): \"FizzBuzz\"\n        (zero? (mod n 3)): \"Fizz\"\n        (zero? (mod n 5)): \"Buzz\"\n        else: n\n    range: start finish\n\ndoseq [x (fizzbuzz 1 101)]:\n  println: x\n</code></pre> <p>We also changed <code>:else</code> to <code>else</code> because YS likes it that way.</p> <p>Does it work? You betcha! Are we done? Heck no!</p> <pre><code>!YS-v0\n\ndefn fizzbuzz(start finish):\n  map _ (start .. finish):\n    fn(n):\n      cond:\n        (zero? (mod n 15)): 'FizzBuzz'\n        (zero? (mod n 3)): 'Fizz'\n        (zero? (mod n 5)): 'Buzz'\n        else: n\n\ndoseq [x (fizzbuzz 1 100)]:\n  println: x\n</code></pre> <p>Ok, hmm. We moved the range up to the top of the map call but put a <code>_</code> right before it. And it's not a range call anymore, it's some operator expression.</p> <p><code>..</code> is the <code>rng</code> operator in YS and the end is inclusive so we didn't need to say 101 when we meant 100.</p> <p>The <code>_</code> is a placeholder for the pair value to go. In Clojure, many functions take a function as the first argument. If we need to actually define a big function there it would be nicer if we could do it last. In these cases <code>_</code> is our friend.</p> <p>Double quotes to single. What's next?</p> <pre><code>!YS-v0\n\ndefn fizzbuzz(start finish):\n  map _ (start .. finish):\n    fn(n):\n      cond:\n        (mod n 15).!: 'FizzBuzz'\n        (mod n 3).!:  'Fizz'\n        (mod n 5).!:  'Buzz'\n        else:         n\n\ndoseq x (fizzbuzz 1 100):\n  say: x\n</code></pre> <p>We replaced the <code>zero?</code> calls with a <code>.!</code> (short for <code>.falsey?()</code>) call. We also removed the square brackets from the <code>doseq</code> call because YS is cool like that.</p> <p>Getting better...</p> <p>In YS, if you define a function called <code>main</code> it will be called automatically when the program is run.</p> <p>Let's try that.</p> <pre><code>!YS-v0\n\ndefn main(start=1 finish=100):\n  each x (start .. finish):\n    say:\n      fizzbuzz: x\n\ndefn- fizzbuzz(n):\n  cond:\n    (mod n 15).!: 'FizzBuzz'\n    (mod n 3).!:  'Fizz'\n    (mod n 5).!:  'Buzz'\n    else:         n\n</code></pre> <p>We moved the heavy lifting code into a private function called <code>fizzbuzz</code> and simply call it from the <code>main</code> function for every number in our range.</p> <p>We also made it so we can pass in the start and finish values as arguments:</p> <pre><code>$ ys program.ys 35 42\nBuzz\nFizz\n37\n38\nFizz\nBuzz\n41\nFizz\n</code></pre> <p>Pretty sweet!</p> <p>Let's tidy up this code a bit more, and come down from our fizzy buzz.</p> <pre><code>!YS-v0\n\ndefn main(start=1 finish=100):\n  each x (start .. finish): x.fizzbuzz().say()\n\ndefn- fizzbuzz(n):\n  cond:\n    (n % 15).!: 'FizzBuzz'\n    (n % 3).!:  'Fizz'\n    (n % 5).!:  'Buzz'\n    else:       n\n</code></pre> <p>We made the body of <code>main</code> into a single pair by chaining the <code>x</code>, <code>fizzbuzz()</code>, and <code>say()</code> together. I wouldn't say this is idiomatic YS, it's a little less readable imho, but sometimes we got to show off a little.</p> <p>This is probably how I'd write that part:</p> <pre><code>  each x (start .. finish):\n    say: fizzbuzz(x)\n</code></pre> <p>See how <code>fizzbuzz</code> comes before the paren, not inside it? We call that a YeS expression and it's definitely idiomatic!</p> <p>Finally we replaced the <code>mod</code> calls with the <code>%</code> operator. To be fair, <code>%</code> is the <code>rem</code> operator and <code>%%</code> is the <code>mod</code> operator in but with positive numbers they do the same thing.</p> <p>I'm fizzed out! Let's move on!</p>"},{"location":"doc/clj-to-ys/#to-be-continued","title":"To Be Continued...","text":"<p>We'll continue this journey soon. I promise.</p> <p>I have lots more Idiomatic YS to show you.</p> <p>Stay tuned!</p>"},{"location":"doc/clojure/","title":"Clojure Basics","text":"<p>YS as a technology has many goals. YS as a programming language is essentially a different syntax for Clojure. However, YS is certainly not an attempt to replace Clojure.</p> <p>In theory YS could have been written in any language. But in reality, Clojure was the best choice for many reasons including:</p> <ol> <li>Clojure is a Lisp and Lisps are \"code as data\". Since YS is YAML and YAML is    data, Clojure is a natural fit.</li> <li>GraalVM's native-image compiler and Clojure's SCI runtime make it possible to    to use YS without Java or the JVM.</li> <li>Clojure's core libraries are extensive, robust and well-documented.</li> </ol> <p>Since YS code always translates to Clojure code, it's important to have a good understanding of Clojure to write good YS code.</p> <p>Again, Clojure is a Lisp dialect. Lisps work entirely with parenthesized expressions containing a function followed by its arguments (S-Expressions).</p> <p>For example:</p> <pre><code>(+ 1 2 3)  ; `+` is a function that adds its arguments\n(str \"Hello \" name \"!\")  ; `str` is a function that concatenates its arguments\n(println (str \"The answer is \" (+ 2 3 7) \"!\"))  ; Multiple nested expressions\n</code></pre> <p>The basic clojure syntactic forms are:</p> <ul> <li>Lists - <code>(a b c)</code></li> <li>Vectors - <code>[a b c]</code></li> <li>Maps - <code>{a b, c d}</code></li> <li>Symbols - <code>a</code>, <code>b</code>, <code>c</code></li> <li>Quoted forms - <code>'(...)</code>, <code>'[...]</code>, <code>'{...}</code>, <code>'abc</code></li> <li>Strings - <code>\"abc\"</code></li> <li>Numbers - <code>123</code>, <code>3.14</code></li> <li>Characters - <code>\\a</code>, <code>\\b</code>, <code>\\c</code></li> <li>Keywords - <code>:a</code>, <code>:b</code>, <code>:c</code></li> <li>Anonymous functions - <code>#(+ %1 %2)</code></li> <li>Sets - <code>#{a b c}</code></li> <li>Regex - <code>#\"abc\"</code></li> <li>Comments - <code>;</code> to end of line</li> <li>Commented out forms - <code>#_(+ a b c)</code></li> </ul> <p>See Introduction to Clojure\u00a0  for more about Clojure.</p>"},{"location":"doc/control/","title":"Control Flow","text":"<p>YS (iow Clojure) is a functional programming language. That means that everything is a function. Running a program is just a calling a function that calls other functions.</p> <p>Even though YS tries hard to look like an imperative language, you must keep in mind that it's functional and get familiar with how the flow works.</p> <p>This document will cover:</p> <ul> <li>Starting a program</li> <li>Variable scope</li> <li>Grouping expressions</li> <li>Looping functions and recursion</li> <li>Conditional expressions</li> </ul> <p>Note</p> <p>Some of the things that are called \"functions\" in in this document are actually \"macros\" or \"special forms\" in Clojure. The distinction is not particularly important here, but worth mentioning.</p>"},{"location":"doc/control/#starting-a-program","title":"Starting a Program","text":"<p>A YS file generally is just a bunch of <code>defn</code> calls to define functions.</p> <p>Sometimes there will be assignment expressions at the top level. Top level variables are global and can be used anywhere in the program. They belong to the file's namespace which is <code>main</code> by default.</p> <p>If a program defines a function called <code>main</code>, it will be called when the program is run. Any command line arguments will be passed to the <code>main</code> function after being cast to numbers if they look like numbers.</p> <p><code>program.ys</code>:</p> <pre><code>!YS-v0\n\ndefn main(word='Hello!' times=3):\n  each i (1 .. times):\n    say: \"$i) $word\"\n</code></pre> <pre><code>$ ys program.ys\n1) Hello!\n2) Hello!\n3) Hello!\n</code></pre> <pre><code>$ ys program.ys YS 2\n1) YS\n2) YS\n</code></pre> <p>If a program does not define a <code>main</code> function, then nothing will happen unless you've defined a top level function call yourself. YS files that are meant to be used as libraries will not have a <code>main</code> function or a top level function call.</p>"},{"location":"doc/control/#variable-scope","title":"Variable Scope","text":"<p>One cool thing about YS (and Clojure) is that you can use any word as a variable name. Even things like <code>if</code> and <code>for</code> which are reserved words in many languages.</p> <p>For example you might do this:</p> <pre><code>defn foo(list):\n  count =: count(list)\n  if count &gt; 0:\n    say: 'The list is not empty'\n  else:\n    say: 'The list is empty'\n</code></pre> <p>Once we bind <code>count</code> to the result of the <code>count</code> function, we can't use the <code>count</code> function again in that scope. Often this is just fine. And it feels nice that you don't have to think up a synonym or alternative mangling for <code>count</code>.</p>"},{"location":"doc/control/#grouping-expressions","title":"Grouping Expressions","text":"<p>Some expression contexts allow multiple expressions to be grouped together and some only allow a single expression.</p> <p>You can group multiple expressions together with a <code>do</code> function call when you need to to do multiple things in a context that only allows a single expression.</p> <pre><code>if a &gt; b:\n  do:\n    say: 'a is greater than b'\n    say: 'a must be HUGE!'\n  say: 'Nothing to see here'\n</code></pre> <p>Note</p> <p>The <code>if</code> function actually supports the better named <code>then</code> and <code>else</code> words for grouping, but <code>do</code> can also be used.</p>"},{"location":"doc/control/#looping-functions-and-recursion","title":"Looping Functions and Recursion","text":"<p>YS has a few looping functions: <code>loop</code>, <code>reduce</code>, <code>for</code> and <code>each</code>.</p> <p>These will be documented in more detail in the future, but for now you can see the Clojure documentation for them:</p> <ul> <li>loop\u00a0 </li> <li>reduce\u00a0 </li> <li>for\u00a0 </li> <li><code>each</code> is a YS function that calls to a <code>for</code> expression inside a   <code>doall</code> expression.   This allows you to print things in the loop body.   In every other way it's the same as <code>for</code>.</li> </ul>"},{"location":"doc/control/#conditional-expressions","title":"Conditional Expressions","text":"<p>YS has a few common conditional expressions: <code>if</code>, <code>when</code>, <code>cond</code> and <code>case</code>.</p>"},{"location":"doc/control/#the-if-function","title":"The <code>if</code> Function","text":"<p>In YS, an <code>if</code> expression is a function that takes 3 arguments: a condition, a then expression and an else expression.</p> <pre><code>if a: b c  # If a is true, return b, else return c\n</code></pre> <p>The <code>b</code> and <code>c</code> expressions can also be mapping pairs:</p> <pre><code>if a:\n  say: 'yes'\n  say: 'no'\n</code></pre> <p>Sometimes you want to do more than one thing in the then or else expression:</p> <pre><code>if a:\n  then:\n    say: 'yes'\n    say: 'yes'\n  else:\n    say: 'no'\n    say: 'no'\n</code></pre> <p>If you use <code>then</code> you must also use <code>else</code>, but <code>else</code> can be used without a <code>then</code>:</p> <pre><code>if a:\n  say: 'yes'\n  else:\n    say: 'no'\n    say: 'no'\n</code></pre> <p>Since <code>if</code> is a function, it has a return value.</p> <pre><code>say:\n  if a: -'yes' 'no'\n</code></pre> <p>Any variable assigned in the <code>then</code> or <code>else</code> expression will only apply to that expression and not to the surrounding scope.</p> <pre><code>x =: 1\nif a &gt; b:\n  x =: 2\n  x =: 3\n=&gt;: x    # =&gt; 1\n</code></pre> <p>What you want to do here is capture the result of the <code>if</code> expression:</p> <pre><code>x =:\n  if a &gt; b:\n    then: 2\n    else: 3\n=&gt;: x    # =&gt; 2 or 3\n</code></pre> <p>Note that <code>say</code> returns <code>nil</code>, so all the <code>if</code> expressions above would also return <code>nil</code>.</p>"},{"location":"doc/control/#the-when-function","title":"The <code>when</code> Function","text":"<p>YS also has a <code>when</code> function that is like <code>if</code> but without an else expression.</p> <pre><code>when a:\n  say: 'yes'\n</code></pre> <p>The <code>if</code> function should only be used wen you have a then and an else expression. Otherwise, use <code>when</code>.</p> <p>One thing about <code>when</code> is that its body can have multiple expressions.</p> <pre><code>when a:\n  say: 'yes'\n  say: 'yes'\n</code></pre>"},{"location":"doc/control/#the-cond-function","title":"The <code>cond</code> Function","text":"<p>The <code>cond</code> function is like a series of <code>if</code> expressions but with multiple conditions.</p> <pre><code>size =:\n  cond:\n    a &lt; 20:  'small'\n    a &lt; 50:  'medium'\n    a &lt; 100: 'large'\n    else:    'huge'\n</code></pre>"},{"location":"doc/control/#the-case-function","title":"The <code>case</code> Function","text":"<p>The <code>case</code> function is like a <code>cond</code> but with a single expression to compare against.</p> <pre><code>count =:\n  case a:\n    1: 'one'\n    2: 'two'\n    3: 'three'\n    else: 'many'\n</code></pre>"},{"location":"doc/core/","title":"Clojure Core Essentials","text":"<p>YS has a very large set of useful functions that it inherits from Clojure's <code>clojure.core</code> library\u00a0 .</p> <p>These functions are the bread and butter building blocks of YS programming.</p> <p>The functions are very well organized in the Clojure Docs Quick Reference\u00a0  and you can get to the documentation for each function from there.</p> <p>This document is a condensed quick reference of the functions that are most commonly used in YS programming.</p> <p>YS also has the <code>ys::std</code> standard library that provides additional functions.</p> <p>The YS standard library replaces some Clojure functions with a version more suited to YS. In those cases, the original Clojure function is still available in the <code>ys::clj</code> namespace.</p>"},{"location":"doc/core/#number","title":"Number","text":""},{"location":"doc/core/#arithmetic","title":"Arithmetic","text":"<p>Clojure Core:</p> <ul> <li>+\u00a0 , -\u00a0 , *\u00a0 , /\u00a0 , inc\u00a0 , dec\u00a0 , max\u00a0 , min\u00a0 , rand\u00a0 , rand-int\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>%</code>, <code>%%</code> infix operators</li> <li><code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code> named math functions</li> <li><code>sum</code>, <code>sqr</code>, <code>cube</code>, <code>sqrt</code>, <code>pow</code>, <code>abs</code></li> <li><code>add+</code>, <code>sub+</code>, <code>mul+</code>, <code>div+</code> polymorphic functions</li> </ul> <p>See Also:</p> <ul> <li><code>clojure.math</code>    functions callable as <code>math/&lt;func-name&gt;</code> in YS.</li> </ul>"},{"location":"doc/core/#comparison","title":"Comparison","text":"<p>Clojure Core:</p> <ul> <li>&lt;\u00a0 , &gt;\u00a0 , &lt;=\u00a0 , &gt;=\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>==</code>, <code>!=</code> infix operators</li> <li><code>eq</code>, <code>ne</code>, <code>lt</code>, <code>gt</code>, <code>le</code>, <code>ge</code> named comparison functions</li> </ul>"},{"location":"doc/core/#cast","title":"Cast","text":"<p>Clojure Core:</p> <ul> <li>byte\u00a0 , short\u00a0 , int\u00a0 , long\u00a0 , float\u00a0 , double\u00a0 , num\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>to-num</code>, <code>to-int</code>, <code>to-float</code> - polymorphic cast functions</li> </ul>"},{"location":"doc/core/#test","title":"Test","text":"<p>Clojure Core:</p> <ul> <li>zero?\u00a0 , pos?\u00a0 , neg?\u00a0 , even?\u00a0 , odd?\u00a0 , number?\u00a0 </li> </ul>"},{"location":"doc/core/#boolean","title":"Boolean","text":"<p>Clojure Core:</p> <ul> <li>nil?\u00a0 , true?\u00a0 , false?\u00a0 , boolean\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>truey?</code>, <code>falsey?</code>, <code>to-bool</code>, <code>to-booly</code></li> </ul>"},{"location":"doc/core/#string","title":"String","text":"<p>Clojure Core:</p> <ul> <li>str\u00a0 , pr-str\u00a0 , prn-str\u00a0 , with-out-str\u00a0 , count\u00a0 , subs\u00a0 , format\u00a0 , string?\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>words</code>, <code>split</code>, <code>join</code>, <code>lines</code>, <code>text</code>, <code>replace</code>, <code>replace1</code></li> <li><code>chomp</code>, <code>trim</code>, <code>triml</code>, <code>trimr</code>, <code>lc</code>, <code>uc</code>, <code>uc1</code>, <code>index</code>, <code>pretty</code></li> </ul> <p>See Also:</p> <ul> <li><code>clojure.string</code>    functions callable as <code>str/&lt;func-name&gt;</code> in YS.</li> </ul>"},{"location":"doc/core/#regular-expression","title":"Regular Expression","text":"<p>Clojure Core:</p> <ul> <li>re-pattern\u00a0 , re-matches\u00a0 , re-find\u00a0 , re-seq\u00a0 , re-groups\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>=~</code>, <code>!~</code> infix operators</li> <li><code>/.../</code> regex literals</li> <li><code>qr</code></li> </ul>"},{"location":"doc/core/#flow-control","title":"Flow Control","text":""},{"location":"doc/core/#boolean_1","title":"Boolean","text":"<p>Clojure Core:</p> <ul> <li>not\u00a0 , and\u00a0 , or\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>||</code>, <code>&amp;&amp;</code>, <code>|||</code>, <code>&amp;&amp;&amp;</code> infix operators</li> <li><code>or?</code>, <code>and?</code> booly named functions</li> </ul>"},{"location":"doc/core/#normal","title":"Normal","text":"<p>Clojure Core:</p> <ul> <li>if\u00a0 , when\u00a0 , if-not\u00a0 , when-not\u00a0 , if-let\u00a0 , when-let\u00a0 , if-some\u00a0 , when-some\u00a0 , cond\u00a0 , condp\u00a0 , case\u00a0 , do\u00a0 , eval\u00a0 , loop\u00a0 , recur\u00a0 , while\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>if-lets</code>, <code>when-lets</code>, <code>call</code>, <code>each</code>, <code>exit</code>, <code>sleep</code></li> </ul>"},{"location":"doc/core/#exception","title":"Exception","text":"<p>Clojure Core:</p> <ul> <li>try\u00a0 , catch\u00a0 , finally\u00a0 , throw\u00a0 , assert\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>die</code>, <code>warn</code>, <code>exit</code>, <code>err</code></li> </ul>"},{"location":"doc/core/#function","title":"Function","text":"<p>Clojure Core:</p> <ul> <li>fn\u00a0 , defn\u00a0 , defn-\u00a0 , identity\u00a0 , comp\u00a0 , partial\u00a0 , complement\u00a0 , constantly\u00a0 , -&gt;\u00a0 , -&gt;&gt;\u00a0 , apply\u00a0 , fn?\u00a0 , ifn?\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>\\(...)</code> anonymous function syntax</li> <li><code>.</code> dot chaining infix operator</li> <li><code>value</code>, <code>call</code></li> </ul>"},{"location":"doc/core/#collection","title":"Collection","text":""},{"location":"doc/core/#general","title":"General","text":"<p>Clojure Core:</p> <ul> <li>count\u00a0 , empty\u00a0 , not-empty\u00a0 , into\u00a0 , conj\u00a0 , contains?\u00a0 , distinct?\u00a0 , empty?\u00a0 , every?\u00a0 , some\u00a0 , not-every?\u00a0 , not-any?\u00a0 , coll?\u00a0 , seq?\u00a0 , vector?\u00a0 , list?\u00a0 , map?\u00a0 , set?\u00a0 , sorted?\u00a0 , sequential?\u00a0 , associative?\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>grep</code>, <code>has?</code>, <code>in?</code></li> </ul>"},{"location":"doc/core/#vector","title":"Vector","text":"<p>Clojure Core:</p> <ul> <li>vec\u00a0 , vector\u00a0 , vec-of\u00a0 , conj\u00a0 , peek\u00a0 , pop\u00a0 , get\u00a0 </li> </ul>"},{"location":"doc/core/#list","title":"List","text":"<p>Clojure Core:</p> <ul> <li>list\u00a0 , cons\u00a0 , conj\u00a0 , peek\u00a0 , pop\u00a0 , first\u00a0 , rest\u00a0 </li> </ul>"},{"location":"doc/core/#map","title":"Map","text":"<p>Clojure Core:</p> <ul> <li>hash-map\u00a0 , array-map\u00a0 , sorted-map\u00a0 , zipmap\u00a0 , frequencies\u00a0 , assoc\u00a0 , assoc-in\u00a0 , dissoc\u00a0 , find\u00a0 , get-in\u00a0 , update-in\u00a0 , key\u00a0 , val\u00a0 , keys\u00a0 , vals\u00a0 , merge\u00a0 , reduce-kv\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>omap</code>, <code>get+</code></li> </ul>"},{"location":"doc/core/#sequence","title":"Sequence","text":"<p>Clojure Core:</p> <ul> <li>seq\u00a0 , repeat\u00a0 , range\u00a0 , iterate\u00a0 , cycle\u00a0 , interleave\u00a0 , interpose\u00a0 , first\u00a0 , second\u00a0 , last\u00a0 , rest\u00a0 , next\u00a0 , butlast\u00a0 , nth\u00a0 , take\u00a0 , drop\u00a0 , take-while\u00a0 , drop-while\u00a0 , conj\u00a0 , concat\u00a0 , map\u00a0 , filter\u00a0 , remove\u00a0 , sort\u00a0 , shuffle\u00a0 , flatten\u00a0 , for\u00a0 , doseq\u00a0 , dorun\u00a0 , doall\u00a0 , mapcat\u00a0 , reduce\u00a0 , keep\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>..</code> infix rng operator</li> <li><code>rng</code>, <code>reverse</code></li> </ul>"},{"location":"doc/core/#variable","title":"Variable","text":"<p>Clojure Core:</p> <ul> <li>def\u00a0 , intern\u00a0 , declare\u00a0 , binding\u00a0 , gensym\u00a0 , var\u00a0 , var-get\u00a0 , resolve\u00a0 , find-var\u00a0 , alter-var-root\u00a0 , var?\u00a0 , bound?\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>=:</code>, <code>.=:</code>, <code>+=:</code>, <code>-=:</code>, <code>*=:</code>, <code>/=:</code> def/let syntax</li> <li><code>value</code></li> </ul>"},{"location":"doc/core/#io","title":"I/O","text":"<p>Clojure Core:</p> <ul> <li>print\u00a0 , printf\u00a0 , println\u00a0 , pr\u00a0 , prn\u00a0 , print-str\u00a0 , println-str\u00a0 , pr-str\u00a0 , prn-str\u00a0 , newline\u00a0 , flush\u00a0 , read\u00a0 , write\u00a0 , with-out-str\u00a0 , with-open\u00a0 , with-in-str\u00a0 </li> </ul> <p>YS Std:</p> <ul> <li><code>say</code>, <code>out</code>, <code>warn</code>, <code>pp</code></li> </ul>"},{"location":"doc/define/","title":"Defining Variables and Functions","text":"<p>Two of the most common things you'll want to do in YS code is to define variables and functions.</p> <p>It's very simple. Here's an example:</p> <pre><code>!YS-v0\n\nname =: 'world'\n\ndefn main():\n  greeting =: 'Hello'\n  say: \"$greeting, $name!\"\n</code></pre> <p>To define a variable with a value we specify a symbol name, followed by one or more spaces, followed by <code>=:</code> for the YS key (the LHS). The variable will be set to the result of the evaluation of the mapping pair's value (the RHS).</p> <p>To define a function we use <code>defn</code>, followed by the function name followed by the parenthesized arguments for the LHS. The RHS is the function body.</p> <p>Let's see how this compiles to Clojure internally using <code>ys -c file.ys</code>:</p> <pre><code>(def name \"world\")\n(defn main [] (let [greeting \"Hello\"] (say (str greeting \", \" name \"!\"))))\n(apply main ARGS)\n</code></pre> <p>In our YS code we defined 2 variables: <code>name</code> and <code>greeting</code>. But in the Clojure code one became a <code>def</code> expression and the other used <code>let</code>. Using <code>=:</code> outside a function uses <code>def</code> and it's a file scope variable. Using <code>=:</code> inside a function uses <code>let</code> and the scope is the remainder of the function.</p> <p>This is idiomatic Clojure.</p>"},{"location":"doc/env-vars/","title":"YS Environment Vars","text":"<p>YS has a number of environment variables that can be set to control its behavior. These variables each begin with <code>YS_</code> and are all uppercase with underscores separating words.</p> <ul> <li> <p><code>YSPATH</code> - A colon-separated list of directories to search for YS library   files loaded with the <code>use</code> function.   This is the only YS environment variable that doesn't start with <code>YS_</code>, but   there is an equivalent <code>YS_PATH</code> that can be used instead.</p> </li> <li> <p><code>YS_PATH</code> - An alternative to <code>YSPATH</code> that is used if <code>YSPATH</code> is not set.</p> </li> <li> <p><code>YS_PRINT=1</code> - Same as <code>-p</code> (<code>--print</code>) command line option.</p> </li> <li> <p><code>YS_STREAM=1</code> - Same as <code>-s</code> (<code>--stream</code>) command line option.</p> </li> <li> <p><code>YS_OUTPUT=&lt;file-name&gt;</code> - Same as <code>-o</code> (<code>--output=&lt;file-name&gt;</code>) command line   option.</p> </li> <li> <p><code>YS_FORMAT=&lt;yaml|json|edn|csv|tsv&gt;</code> - Same as <code>-t</code> ()</p> </li> <li> <p><code>YS_UNORDERED=1</code> - Same as <code>-u</code> (<code>--unordered</code>) command line option.</p> </li> <li> <p><code>YS_XTRACE=1</code> - Same as <code>-x</code> (<code>--xtrace</code>) command line option.</p> </li> <li> <p><code>YS_STACK_TRACE=1</code> - Same as <code>-S</code> (<code>--stack-trace</code>) command line option.</p> </li> <li> <p><code>YS_SHOW_OPTS=1</code> - Print all the option values.</p> </li> <li> <p><code>YS_SHOW_LEX=1</code> - Print the lexed tokens of each YS expression.</p> </li> <li> <p><code>YS_SHOW_INPUT=1</code> - Print the input YS expressions.</p> </li> </ul>"},{"location":"doc/examples/","title":"YS by Example","text":"<p>One of the best ways to learn a new programming language is to see examples of real code written in that language. This page contains a links to programs written in YS.</p> <p>Note</p> <p>The YS documentation is a work in progress. Looking at real life examples is a solid way to get started. If you feel the urge to contribute to the documentation, please do so. It would be greatly appreciated!</p>"},{"location":"doc/examples/#ys-examples-of-refactoring-large-yaml-files","title":"YS Examples of Refactoring Large YAML Files","text":"<ul> <li>Calva's CircleCI Config\u00a0 </li> <li>HelmYS Helm Templating\u00a0 </li> </ul>"},{"location":"doc/examples/#ys-examples-of-programs-utilities-and-automation","title":"YS Examples of Programs, Utilities and Automation","text":"<ul> <li>Rosetta Code\u00a0    YS (YAMLScript) solutions to Rosetta Code tasks.</li> <li>yamllm\u00a0    A command line multi LLM (Anthropic, OpenAI, Gemma) query tool.</li> <li>sbs\u00a0    Creates markdown gists to compare pairs of files \"side by side\".   Used to show differences between YS and Go templates in Helm.</li> <li>Example gist comparing Helm templates in YS and Go\u00a0 </li> <li>ys-vs-rc\u00a0    Compares YS and Rosetta Code solutions to the same problem in many languages.</li> <li>Example gist comparing FizzBuzz in YS vs many other languages\u00a0 </li> <li>YS Repository Utilities</li> <li>util/release-yamlscript\u00a0      The utility that orchestrates the release of YS, including 12 binary builds     and <code>libyamlscript.so</code> bindings for 11 programming languages.</li> <li>util/brew-update\u00a0      The utility that updates the Homebrew formula for YS.</li> <li>util/mdys\u00a0      Renders Markdown with embedded YS code blocks.     Used for the YS documentation.</li> <li>util/version-bump\u00a0      Bumps the version of dozens of YS files in the repository at     release time.</li> </ul> <p>More examples will be added here as they become known.</p> <p>If you have YS example code you'd like to share, please submit a PR to the YS Repo\u00a0 .</p>"},{"location":"doc/exercism/","title":"Learn YS at Exercism","text":"<p>Exercism\u00a0  is a platform that offers code practice and mentorship for everyone. It is a great way to improve your coding skills and learn new programming languages.</p> <p>Exercism provides a series of exercises in over 70 programming languages\u00a0  including YS / YAMLScript\u00a0  , and you can get feedback from mentors on your solutions.</p> <p>It is a fun and interactive way to learn to code, and it is completely free to use. If you are looking to improve your coding skills or learn a new language, Exercism is a good place to start.</p>"},{"location":"doc/gotchas/","title":"Common YAML / YS Gotchas","text":"<p>All YS files are required to be valid YAML. YS uses most of YAML's capabilities and flexibilities to create a clean programming language (one that doesn't look like just a bunch of data).</p> <p>Unfortunately, this means that you can run into some situations where your YS code looks perfectly fine but is actually invalid YAML.</p> <p>Here's a common gotcha. YS can repeat a string with this syntax: <code>'foo' * 3</code> yields <code>'foofoofoo'</code>.</p> <p>However, the following is not valid and would cause a YAML parsing error:</p> <pre><code>say: 'foo' * 3\n</code></pre> <p>This is because YAML sees a single quoted scalar and text content is not allowed to follow the closing quote.</p> <p>YS provides the <code>+</code> escaping character to fix this:</p> <pre><code>say: +'foo' * 3\n# (these also work in this case):\nsay: ('foo' * 3)\nsay: 3 * 'foo'\n</code></pre> <p>Now the right-hand side is a plain scalar wThis is because YAML sees a single quoted scalar and text content is not allowed to follow the closing quote.hose value is <code>+'foo' * 3</code>. YS will ignore the leading <code>+</code> and evaluate the expression as expected.</p> <p>This <code>+</code> escaping character can be used anywhere that you need to use a plain scalar to write a YS expression but the leading character would otherwise be interpreted as YAML syntax.</p> <p>Another example:</p> <pre><code># Here [3 4 5] is a YS vector, not a YAML sequence.\n# Again we make the entire RHS a plain scalar by starting with a `+`.\nsay: +[3 4 5].reverse()\n</code></pre> <p>It is super common to use <code>[]</code> vectors and <code>{}</code> mappings in Clojure code expressions and thus in YS code expressions. In YAML, the same syntax is used for flow sequence and mapping nodes. This can cause confusion.</p> <p>We \"fix\" this, again, by using the <code>+</code> escaping character. Also, we simply disallow (in code mode) YAML flow sequences and flow mappings. Using the <code>+</code> to get the scalar expression version of the same thing works fine (and as a bonus, there is no need for the commas and colons).</p> <p>For example: <pre><code>!YS-v0\n\n# This is an error (using a flow sequence in code mode):\nsay: [1, 2, 3]\n# This is a scalar that re-parses as a vector:\nsay: +[1, 2, 3]\n# And thus does not need the commas (commas are whitespace in previous line):\nsay: +[1 2 3]\n# We can use the YAML flow collection syntax if we switch to data mode:\nsay:: [1, 2, 3]\n# Same switching as above, but with `!` instead of `::`:\nsay: ! [1, 2, 3]\n# The commas are require in YAML flow collection syntax.\n</code></pre></p> <p>YAML block sequences (lines starting with <code>-</code>) are also disallowed in code mode.</p> <p>The rationale here is that if you ever see <code>{</code>, <code>[</code>, <code>-</code> or <code>&gt;</code> (folded scalar) you can assume that you are in data mode and not code mode.</p> <p>Example errors:</p> <pre><code>$ ys -e 'say: [1, 2, 3]'\nError: Sequences (block and flow) not allowed in code mode\n\n$ ys -e '\nsay:\n- 1\n- 2\n- 3'\nError: Sequences (block and flow) not allowed in code mode\n</code></pre> <p>There are various ways to do it correctly:</p> <pre><code>$ ys -e 'say:: [1, 2, 3]'\n[1 2 3]\n\n$ ys -e '\nsay::\n- 1\n- 2\n- 3'\n[1 2 3]\n\n$ ys -e 'say: +[1, 2, 3]'\n[1 2 3]\n</code></pre> <p>Don't worry, you'll get the hang of it quickly!</p>"},{"location":"doc/install/","title":"Installing YS","text":"<p>YS has 3 main things you might want to install:</p> <ol> <li>The <code>ys</code> compiler, loader and runner command.</li> <li>The <code>libyamlscript.so</code> shared library needed by a YS loader library for your    particular programming language.</li> <li>A YS loader library for your    particular programming language, like Python, Rust, NodeJS, etc.</li> </ol>"},{"location":"doc/install/#install-ys-with-homebrew","title":"Install <code>ys</code> with Homebrew","text":"<p>You can install <code>ys</code> on macOS or Linux with Homebrew.</p> <p>Just run these commands:</p> <pre><code>brew tap yaml/yamlscript\nbrew install ys\n</code></pre> <p>Homebrew support for installing <code>libyamlscript</code> is coming soon.</p>"},{"location":"doc/install/#quick-install-script-for-ys-and-libyamlscript","title":"Quick Install Script for <code>ys</code> and <code>libyamlscript</code>","text":"<p>You can install both <code>ys</code> and <code>libyamlscript</code> with a single CLI command, where:</p> <ul> <li><code>VERSION</code> defaults to the latest YS version.</li> <li><code>PREFIX</code> defaults to <code>$HOME/.local</code>.</li> <li><code>LIB=1</code> means only install the shared library.</li> <li><code>BIN=1</code> means only install the <code>ys</code> binary.</li> </ul> <p>Examples: <pre><code>$ curl https://yamlscript.org/install | bash\n$ curl https://yamlscript.org/install | VERSION=0.1.96 bash\n$ curl https://yamlscript.org/install | VERSION=0.1.96 BIN=1 bash  # ys\n$ curl https://yamlscript.org/install | VERSION=0.1.96 LIB=1 bash  # libyamlscript\n$ curl https://yamlscript.org/install | PREFIX=/tmp/yamlscript bash\n</code></pre></p> <p>For the <code>ys</code> command you'll need to have <code>PREFIX/bin</code> in your <code>PATH</code>, but the install script will tell you that.</p> <p>For <code>libyamlscript</code>, unless you use the default <code>PREFIX</code> you'll need to add <code>PREFIX/lib</code> to your <code>LD_LIBRARY_PATH</code>.</p> <p>An even shorter command to install <code>ys</code></p> <pre><code>$ curl -s https://getys.org/ys | bash\n</code></pre> <p>You can use all the same options as above (before <code>bash</code>).</p>"},{"location":"doc/install/#download-and-install","title":"Download and Install","text":"<p>All the binary pre-built release files are here\u00a0 .</p> <ul> <li>Download the appropriate release file.</li> <li>Expand the file with <code>$ tar xf &lt;release-file&gt;</code>.</li> <li>Use <code>cd</code> to enter the release directory.</li> <li>Run <code>make install</code> or <code>make install PREFIX=...</code>.</li> <li>Or just copy the binary file to the place where you want it.</li> </ul>"},{"location":"doc/install/#build-a-release-from-source","title":"Build a Release from Source","text":"<p>You can also easily build and install <code>ys</code> and <code>libyamlscript</code> from source:</p> <ul> <li>Download the \"Source code\" release file.</li> <li>Expand the file with <code>$ tar xf &lt;release-file&gt;</code>.</li> <li>Use <code>cd</code> to enter the release directory.</li> <li>Run <code>make install</code> or <code>make install PREFIX=...</code>.</li> </ul> <p>This will take a few minutes but it requires no dependencies besides <code>bash</code>, <code>make</code> and <code>curl</code>.</p> <p>Note</p> <p>On Linux it also requires the <code>libz-dev</code> package.</p>"},{"location":"doc/install/#install-a-ys-loader-library","title":"Install a YS Loader Library","text":"<p>YS loader libraries are intended to be a  drop in replacement for your current YAML loader.</p> <p>YS loader libraries are currently available for these programming languages:</p> <ul> <li>Clojure\u00a0 </li> <li>Crystal\u00a0 </li> <li>Go\u00a0 </li> <li>Java\u00a0 </li> <li>Julia\u00a0 </li> <li>NodeJS\u00a0 </li> <li>Perl\u00a0 </li> <li>Python\u00a0 </li> <li>Raku\u00a0 </li> <li>Ruby\u00a0 </li> <li>Rust\u00a0 </li> </ul> <p>Install the library you want using the normal library installer for your language. Then install the matching version of the <code>libyamlscript</code> shared library as described above.</p> <p>Note</p> <p>Currently when you install a YS loader library for your particular programming language you must also install the <code>libyamlscript</code> shared library of the exact same version. Fortunately this is simple.</p>"},{"location":"doc/intro/","title":"Introducing YS","text":"<p>YS is a new approach to providing the extra capabilities that YAML users have been asking for (or adding themselves) for years. YS embeds cleanly into existing YAML files and adds new capabilities such as:</p> <ul> <li>Getting data from other YAML files</li> <li>Assigning variables</li> <li>Referencing other parts of YAML (without anchorsi/aliases)</li> <li>Interpolating variables and function calls into strings</li> <li>Transforming data structures</li> <li>Defining and calling functions</li> <li>Using external libraries</li> <li>Running shell commands</li> <li>And much more...</li> </ul> <p>All of YS is (and must be) valid YAML syntax, even though it might seem surprising from time to time. Also all YAML config files are valid YS files and YS will treat them as such (no code execution), unless you explicitly tell it to do more (by adding a <code>!YS-v0</code> tag to the start).</p> <pre><code>!YS-v0\nsay: \"Welcome to YS!\"\n</code></pre> <p>YS is also a complete, mature, functional, performant programming language. That's because under the hood, YS code is compiled to Clojure\u00a0  code and evaluated by a Clojure runtime. For most day to day YS use, you won't need to know anything about Clojure, but when you need to do something more advanced, all of Clojure\u00a0  is available for you to use.</p> <p>Even though Clojure is a Lisp, YS code looks a lot more like Python, Ruby, Perl or JavaScript. And even though Clojure is a JVM (Java) language, YS doesn't use the JVM at all. YS is a fast standalone native binary, as is the <code>libyamlscript</code> shared library that it is used by all YS loader libraries.</p>"},{"location":"doc/loaders/","title":"YS Loader Libraries","text":"<p>YS is focused on providing a loader library for every programming language where YAML is used. Ideally it should be a drop-in replacement for the existing YAML loader library you are using.</p> <p>All existing YAML config files are already valid YS files and using the YS loader to load them should work without any changes. The advantage of using the YS loader is that they all work the same way and provide the same capabilities, regardless of the underlying programming language.</p> <p>The following loader libraries are currently available:</p> <ul> <li>Clojure\u00a0 </li> <li>Crystal\u00a0 </li> <li>Go\u00a0 </li> <li>Java\u00a0 </li> <li>Julia\u00a0 </li> <li>NodeJS\u00a0 </li> <li>Perl\u00a0 </li> <li>Python\u00a0 </li> <li>Raku\u00a0 </li> <li>Ruby\u00a0 </li> <li>Rust\u00a0 </li> </ul>"},{"location":"doc/mode-tags/","title":"YS Mode Tags","text":"<p>YS has 3 modes that every node in a YAML document can be in: data, code, and bare.</p> <p>By default YS sees YAML files as being in bare mode, and loads them according to basic YAML rules.</p> <p>You need to use a special tag for YS to be able to use logic in a YAML file.</p> <p>These tags are applied to each document (top level node) in a YAML file. Since most YAML files only have one document, you can think of these tags as being declared at the top of the files and being applied to the whole file.</p>"},{"location":"doc/mode-tags/#v0-ys-mode-tags","title":"v0 YS Mode Tags","text":"<ul> <li><code>!YS-v0</code> - Start in code mode.</li> <li><code>!YS-v0:</code> - Start in data mode.</li> <li><code>!code</code> - Start in code mode. Must come after a <code>!YS-v0</code> tag.</li> <li><code>!data</code> - Start in data mode. Must come after a <code>!YS-v0</code> tag.</li> <li><code>!bare</code> - Start in bare mode. Must come after a <code>!YS-v0</code> tag.</li> </ul> <p>The <code>!code</code>, <code>!data</code>, and <code>!bare</code> tags are used for clarity but can only be used on a document that follows a document with a <code>!YS-v0</code> tag.</p> <p>One way to use <code>!data</code> without have a previous document is:</p> <pre><code>!YS-v0\n--- !data\nnum:: 6 * 7  # 42\n</code></pre> <p>In reality this YAML has two documents, but since the first one has no content it is ignored by the YS compiler. Even though it is ignored, it serves to add the <code>!YS-v0</code> tag to the file, so that you can now use <code>!data</code> or <code>!code</code> or <code>!bare</code> tags in the rest of the file.</p> <p>Note</p> <p>Every document in a YAML file is considered \"bare\" unless it has a mode tag at the top of that document.</p>"},{"location":"doc/mode-tags/#alternate-v0-ys-mode-tags","title":"Alternate v0 YS Mode Tags","text":"<p>Originally, these mode tags were supported for YS v0:</p> <ul> <li><code>!yamlscript/v0</code> - Start in code mode.</li> <li><code>!yamlscript/v0:</code> - Start in data mode.</li> <li><code>!yamlscript/v0/code</code> - Start in code mode.</li> <li><code>!yamlscript/v0/data</code> - Start in data mode.</li> <li><code>!yamlscript/v0/bare</code> - Start in bare mode.</li> </ul> <p>These tags are still supported for backwards compatibility, but the <code>!YS-v0</code> tags are preferred. They may be removed in a future version of YS.</p>"},{"location":"doc/modes/","title":"YS Syntax Modes","text":"<p>One of the most important things to understand when learning YS is the concept of \"modes\".</p> <p>It basically comes down to whether an unquoted scalar like <code>count</code> should be considered as a data string or a code symbol (variable, function name etc). Since the main focus of YS is about embedding code into YAML data files, it's very important to know what mode you are in at any given point.</p> <p>YS has 3 modes:</p> <ul> <li>Bare mode</li> </ul> <p>Exactly the same as YAML 1.2 (Core Schema).   YS can load most existing files without executing any code.</p> <ul> <li>Data mode</li> </ul> <p>Very similar to bare mode, but allows you to switch to code mode.   All YAML syntax forms are allowed here.</p> <ul> <li>Code mode</li> </ul> <p>Plain (unquoted) scalars are treated as code expressions.   YAML's flow mappings (<code>{}</code>), flow sequences (<code>[]</code>) and block sequences (<code>-</code>)   are not allowed in code mode.   YS \"code\" is  written using block mappings (<code>k: v</code>), plain scalars,   quoted scalars (single and double) and literal (<code>|</code>) scalars.   Folded scalars (<code>&gt;</code>) are also disallowed in code mode.</p> <p>The most important ones to learn about are data and code modes. To use YS effectively you'll need to be comfortable with switching back and forth between the two.</p> <p>Bare mode is the default when you haven't added a <code>!YS-v0</code> tag to the start of a YS document. It means that everything in the file is data; code can never be used. This is how we can make sure that existing YAML files are valid YS.</p> <p>To enable a YAML file to use YS code, you need to add one of these tags to the top:</p> <ul> <li><code>!YS-v0</code> - Start in code mode.</li> <li><code>!YS-v0:</code> - Start in data mode.</li> <li><code>!YS v0:</code> - Tagged key/val pair that starts in bare mode.</li> </ul> <p>Consider the following examples.</p> <p>Bare mode:</p> <pre><code>$ ys --load &lt;(echo '\nfoo:\n  count: [red, green, blue]')\n{\"foo\":{\"count\":[\"red\",\"green\",\"blue\"]}}\n</code></pre> <p>Data mode:</p> <pre><code>$ ys --load &lt;(echo '\n!YS-v0:\nfoo:\n  count: [red, green, blue]')\n{\"foo\":{\"count\":[\"red\",\"green\",\"blue\"]}}\n</code></pre> <p>Code mode:</p> <pre><code>$ ys --load &lt;(echo '\n!YS-v0\nfoo:\n  count: [red, green, blue]')\nError: Sequences (block and flow) not allowed in code mode\n</code></pre> <p>Oops. Looks like we need to switch to data mode in there.</p>"},{"location":"doc/modes/#switching-modes","title":"Switching Modes","text":"<p>If we want to add a function to a data file we should start in data mode. Then we should switch to code mode for things that are code.</p> <p>Here we want to call the <code>count</code> function with a sequence and get back 3, the number of elements in the sequence.</p> <p>The special tag <code>!</code> can be used to switch from data to code and vice versa.</p> <pre><code>$ ys --load &lt;(echo '\n!YS-v0:\nfoo: !\n  count: [red, green, blue]')\nError: Sequences (block and flow) not allowed in code mode\n</code></pre> <p>Here we started in data mode but then switched the mode to code with <code>!</code>. We got the same error. YS only allows block mappings for code. We need to put <code>[red, green, blue]</code> into data mode:</p> <pre><code>$ ys --load &lt;(echo '\n!YS-v0:\nfoo: !\n  count: ! [red, green, blue]')\n{\"foo\":3}\n</code></pre> <p>It worked!</p> <p>Using <code>!</code> is so common that YS has a cleaner way to do it when used on a mapping pair value. If you use <code>::</code> instead of <code>:</code> it does the same thing.</p> <p>Let's try it out:</p> <pre><code>$ ys --load &lt;(echo '\n!YS-v0:\nfoo::\n  count:: [red, green, blue]')\n{\"foo\":3}\n</code></pre> <p>Sweet!</p> <p>However, when switching in a sequence you'll need to use <code>!</code>:</p> <pre><code>$ ys --load &lt;(echo '\n!YS-v0:\n- !\n  count:: [red, green, blue]')\n[3]\n</code></pre> <p>NOTE: <code>::</code> isn't special YAML syntax. YS cannot change YAML 1.2 syntax in any way. In the examples above <code>count:</code> is simply a plain scalar ending with <code>:</code>.</p> <p>We can see that in bare mode:</p> <pre><code>$ ys --load &lt;(echo '\ncount:: [red, green, blue]')\n{\"count:\":[\"red\",\"green\",\"blue\"]}\n</code></pre>"},{"location":"doc/operators/","title":"YS Operators","text":"<p>YS has a number of operators that you can use in your code.</p> <p>Review YeS Expressions to see how YS supports infix operator expressions, whereas Clojure requires the operator to precede the operands.</p> <p>When YS operators are used with infix notation, they often become polymorphic and do things according to the types of the operands.</p> <pre><code>!YS-v0\ns =: ('foo' + 'bar')  # =&gt; 'foobar'\ns =: (+ 'foo' 'bar')  # ERROR - Clojure + only works on numbers\n</code></pre> <p>You can see why by looking at the <code>ys -c</code> output:</p> <pre><code>$ ys -c -e \"s =: ('foo' + 'bar')\" -e \"s =: (+ 'foo' 'bar')\"\n(def s (add+ \"foo\" \"bar\"))\n(def s (+ \"foo\" \"bar\"))\n</code></pre> <p>See how the infix <code>+</code> operator compiles to the <code>add+</code> function? The <code>add+</code> function works on numbers, strings, characters, sequences, mappings, sets and functions!</p> <p>Note</p> <p>If you absolutely need the Clojure <code>+</code> function for performance reasons, you can simply use the prefix form: <code>(+ a b)</code>.</p>"},{"location":"doc/operators/#arithmetic-operators","title":"Arithmetic Operators","text":"<ul> <li><code>+</code> - Addition - Infix works on strings, sequences, and mappings or else casts   arguments to numbers.</li> <li><code>-</code> - Subtraction - Works on numbers.</li> <li><code>*</code> - Multiplication - Infix works on numbers or <code>str * num</code>, <code>num * str</code>,   <code>seq * num</code>, <code>num * seq</code>.</li> <li><code>/</code> - Division - Works on numbers. Infix returns a double in the cases where   Clojure would return a ratio.</li> <li><code>%</code> - Remainder - Works on numbers. Compiles to <code>rem</code> in Clojure.</li> <li><code>%%</code> - Modulus - Works on numbers. Compiles to <code>mod</code> in Clojure.</li> <li><code>**</code> - Exponentiation - Works on numbers and has right associativity.</li> </ul>"},{"location":"doc/operators/#comparison-operators","title":"Comparison Operators","text":"<ul> <li><code>==</code> - Equal To - Works on any comparable values.</li> <li><code>!=</code> - Not Equal To - Works on any comparable values.</li> <li><code>&gt;</code> - Greater Than - Works on numbers. Supports <code>a &gt; b &gt; c</code>.</li> <li><code>&gt;=</code> - Greater Than or Equal To - Works on numbers.</li> <li><code>&lt;</code> - Less Than - Works on numbers.</li> <li><code>&lt;=</code> - Less Than or Equal To - Works on numbers.</li> </ul> <p>These operators have the respective named functions: <code>eq</code>, <code>ne</code>, <code>gt</code>, <code>ge</code>, <code>lt</code>, <code>le</code> for use in places where a function makes more sense than an operator.</p>"},{"location":"doc/operators/#conditional-operators","title":"Conditional Operators","text":"<p>In Clojure <code>false</code> and <code>nil</code> are treated as \"false\" and everything else is treated as \"true\".</p> <p>YS adds the concept of \"truey\" and \"falsey\" values. Empty strings, empty collections, <code>0</code>, <code>false</code>, and <code>nil</code> are \"falsey\" and everything else is \"truey\".</p> <p>This concept applies to some operators.</p> <ul> <li><code>&amp;&amp;</code> - Logical And</li> <li><code>||</code> - Logical Or</li> <li><code>&amp;&amp;&amp;</code> - Truey And</li> <li><code>|||</code> - Truey Or</li> </ul>"},{"location":"doc/operators/#regular-expression-operators","title":"Regular Expression Operators","text":"<ul> <li><code>=~</code> - <code>a =~ b</code> calls <code>re-find(b a)</code>. Coerces <code>a</code> to a string.</li> <li><code>!~</code> - <code>not(a =~ b)</code></li> <li><code>=~~</code> - <code>a =~ b</code> calls <code>re-matches(b a)</code>. Coerces <code>a</code> to a string.</li> <li><code>!~~</code> - <code>not(a =~~ b)</code></li> </ul>"},{"location":"doc/operators/#other-operators","title":"Other Operators","text":"<ul> <li> <p><code>.</code> - Function Chaining Operator</p> <p><code>a.b.3.c(d).e(f)</code> compiles to: <code>(e (c (nth (get+ a 'b) 3) d) f)</code>.</p> </li> <li> <p><code>..</code> - Range Operator</p> <p><code>1 .. 3</code> -&gt; <code>(1 2 3)</code>, <code>3 .. 1</code> -&gt; <code>(3 2 1)</code>.</p> <p>Differs from Clojure's <code>range</code>  function.</p> </li> </ul>"},{"location":"doc/query/","title":"Convert/Query/Transform","text":"<p>You can use the <code>ys</code> command line tool to convert, query and transform YAML (or JSON since JSON is YAML) files much like you would with <code>jq</code>  or <code>yq</code> .</p> Install <code>ys</code> Now! <pre><code>curl -s https://getys.org/ys | bash\n</code></pre> <p>YS is an excellent tool for these types of CLI 1-liner tasks, because it:</p> <ul> <li>Is a full programming language with 100s of builtin functions</li> <li>Has a great compact \"dot notation\" syntax</li> <li>Has many options for output formats and other niceties</li> </ul> <p>For example, to get the first 5 keys of a subsection of a YAML file that start with a vowel and print the result as YAML to stdout:</p> <pre><code>$ ys '.some.0.part:keys.filter(/^[aeiou]/).take(5)' file.yaml\n- id\n- enabled\n- owner\n- interval\n- environment\n</code></pre> Should I use <code>yq</code> or <code>ys</code>? <p>Both!</p> <p>While <code>yq</code> currently has features that <code>ys</code> does not (like updating files in place and preserving comments), <code>ys</code> has a much larger set of functions (it's an entire programming language) to make use of.</p> <p>Both are fantastic tools and can be used together for great good!</p>"},{"location":"doc/query/#ys-conversion-examples","title":"YS Conversion Examples","text":"<p>Click on the examples below to see more details.</p> <ul> <li> <p>Convert YAML/JSON to other formats</p> <code>ys -J file.yaml\u00a0\u00a0\u00a0# Convert to JSON</code> <p>Use one of these Load options:</p> <ul> <li><code>-l</code>/<code>--load</code> Load input and print as compact JSON</li> <li><code>-J</code>/<code>--json</code> Print as formatted JSON</li> <li><code>-Y</code>/<code>--yaml</code> Print as YAML</li> <li><code>--csv</code> Print as CSV</li> <li><code>--tsv</code> Print as TSV</li> <li><code>--edn</code> Print as EDN</li> </ul> <p>Prints the data in the specified format to stdout.</p> <p>Examples: <pre><code>ys -l file.yaml  # --load for compact JSON output\n</code></pre> <pre><code>ys -J file.yaml  # Pretty JSON output\n</code></pre> <pre><code>ys -l file.yaml | jq .   # Pipe to jq for even prettier JSON output\n</code></pre> <pre><code>&lt; file.yaml ys -l -  # Read from stdin (use - for file name)\n</code></pre> <pre><code>&lt; file.yaml ys -l    # -l with no file argument reads from stdin\n</code></pre></p> </li> <li> <p>Show code evaluation in a format</p> <code>ys -Ye ENV\u00a0\u00a0\u00a0# Environment as YAML</code> <p><pre><code>ys -Ye ENV  # Environment as YAML\n</code></pre> <pre><code>ys -Ye 'ENV:sort:flat:O'  # Sorted\n</code></pre></p> </li> </ul>"},{"location":"doc/query/#many-more-examples-soon","title":"Many more examples soon...","text":""},{"location":"doc/referencing/","title":"Referencing YAML Nodes","text":"<p>One thing that's important when adding code to YAML is having ways for the code to reference other data.</p>"},{"location":"doc/run-ys/","title":"Self Installation Scripts","text":"<p>Note</p> <p>If you just ran a program with <code>bash</code> that printed a URL to this page, click the arrow below for more information on \"What just happened?\" below.</p> What just happened? <p>If you are reading this you probably just ran a YS program with <code>bash</code>. The first time you do that, the program installed the <code>ys</code> interpreter under the <code>/tmp/</code> directory for you and then ran the program with it. Subsequent runs of the program will use that installed <code>ys</code> interpreter.</p> <p>You may continue to run the program this way, but there will be a slight delay at the start each time while the <code>run-ys</code> auto-installer script is downloaded.</p> <p>It is very easy to install the <code>ys</code> interpreter permanently on your system so that you can run the program with <code>ys</code> instead of <code>bash</code>.</p> <pre><code>$ curl -s https://yamlscript.org/install-ys | bash\n</code></pre> <p>See the YS Installation page for more information.</p> <p>YS has a way to publish programs that people can run immediately without having installed the <code>ys</code> interpreter first.</p> <p>Warning</p> <p>See the Security Considerations below before using this technique.</p> <p>Just begin your YS program with these lines:</p> <pre><code>#!/usr/bin/env ys-0\nsource &lt;(curl '-s' 'https://yamlscript.org/run-ys') \"$@\" :\n</code></pre> <p>Then anyone can run your program using Bash with a command like this: <code>bash script.ys arg1 arg2 ...</code>.</p> <p>The first time they do so, the <code>ys</code> interpreter will be downloaded and installed under the <code>/tmp/</code> directory.</p> <p>The <code>ys</code> interpreter will be downloaded only once, and it will be used for all subsequent runs of the script.</p> <p>Note</p> <p>The <code>curl</code> command will still download and evaluate the <code>run-ys</code> Bash script on subsequent runs so the user will need to have internet access.</p> <p>The program can also be run with the <code>ys</code> interpreter if the user installs it. In that case the Bash installer line will be ignored.</p> <p>Since the program has a shebang line, it can also be run as a <code>PATH</code> command if the file is marked as executable.</p>"},{"location":"doc/run-ys/#example","title":"Example","text":"<p>Here's a small YS program that program that prints the ROT13 encoding of its arguments:</p> <pre><code>#!/usr/bin/env ys-0\n\nsource &lt;(curl '-s' 'https://yamlscript.org/run-ys') \"$@\" :\n\nalphabet =: set((\\\\A .. \\\\Z) + (\\\\a .. \\\\z))\nrot13 =: cycle(alphabet).drop(13 * 2).zipmap(alphabet)\n\ndefn main(*input):\n  say: str/escape(input.join(' ') rot13)\n</code></pre> <p>If we run it with <code>ys</code>:</p> <pre><code>$ ys rot13.ys I Love YS\nV Ybir LF\n</code></pre> <p>If we run it with <code>bash</code>:</p> <pre><code>$ bash rot13.ys I Love YS\nInstalling the YS CLI '/tmp/yamlscript-run-ys/bin/ys-0.1.96' now...\nCtl-C to abort\nSee https://yamlscript.org/doc/run-ys for more information.\n\nInstalled /tmp/yamlscript-run-ys/bin/ys - version 0.1.96\n--------------------------------------------------------------------------------\nV Ybir LF\n</code></pre> <p>and again:</p> <pre><code>$ bash rot13.ys I Love YS\nV Ybir LF\n</code></pre>"},{"location":"doc/run-ys/#how-it-works","title":"How It Works","text":"<p>The program is both valid YS and valid Bash.</p> <p>YS programs are required to start with a YAML tag like this:</p> <pre><code>!YS-v0\n</code></pre> <p>But if they start with a shebang line like this:</p> <pre><code>#!/usr/bin/env ys-0\n</code></pre> <p>then the <code>!YS-v0</code> tag is optional.</p> <p>When you run the program with <code>bash</code>, the shebang line is merely a comment and ignored by Bash.</p> <p>The <code>source</code> line is a Bash command that reads and evaluates the contents of the <code>&lt;(...)</code> process substitution file. The <code>curl</code> command inside downloads the <code>run-ys</code> script and installs the <code>ys</code> interpreter under the <code>/tmp/</code> directory if it is not already installed.</p> <p>It then <code>exec</code>s the installed <code>ys</code> interpreter with your original program and any arguments you provided.</p> <p>The <code>source</code> line is also a valid YS command. It calls the YS <code>source</code> macro which ignores all of its arguments (much like the <code>comment</code> macro does).</p>"},{"location":"doc/run-ys/#use-cases-and-security-considerations","title":"Use Cases and Security Considerations","text":"<p>This technique is may be useful in situations where you want to share a YS program with people who are not yet familiar with YS.</p> <p>Since the program is run with Bash which gets more Bash code from the internet, it is subject to the many security risks of running arbitrary code from the internet.</p> <p>Caveat yamlscriptor!</p> <pre><code>A more secure way to distribute a YS program is to\n[compile it to a binary executable](binary.md) and distribute the binary\ninstead.\n</code></pre> <p>There is at least one use case where this Bash technique is safe and useful:</p> <p>You can easily run a YS program that you are developing with a particular version of the <code>ys</code> interpreter without having to install it first. Just use the <code>YS_VERSION</code> environment variable to specify the version you want:</p> <pre><code>$ YS_VERSION=0.1.96 bash my-program.ys arg1 arg2 ...\n</code></pre> <p>This might be useful for testing a reported bug with an older version of the interpreter, for example.</p> <p>There may be other development and testing use cases for this technique as well. If you find one, please let us know!</p>"},{"location":"doc/syntax/","title":"YS Syntax","text":"<p>The <code>ys</code> YS interpreter command runs YS programs by compiling them to Clojure code and evaluating that Clojure code.</p> <p>To fully understand YS you need to know:</p> <ul> <li>How YAML works</li> <li>How Clojure works</li> </ul> <p>This document will show you the basics of YS syntax and how they translate to Clojure code.</p> <p>Note</p> <p>You can play with all the concepts here by putting example code into a file like <code>example.ys</code> and running <code>ys -c example.ys</code> which will print the Clojure code that the YS code compiles to.</p>"},{"location":"doc/syntax/#first-steps","title":"First Steps","text":"<pre><code>!YS-v0\n(say \"Hello, world!\")\n</code></pre> <p>This is a simple YS program that prints \"Hello, world!\".</p> <p>An interesting point about YS is that is always valid YAML, and the YS compiler (<code>ys -c</code>) is really just a fancy YAML loader. Almost all YAML files are valid YS and the compiler turns them into the expected data structure.</p> <p>This is where the <code>!YS-v0</code> tag comes in. It tells the YS compiler to \"load\" the YAML into a YS AST which prints naturally to Clojure code.</p> <p>The point is that every YS program needs to start with the <code>!YS-v0</code> tag, or else it just compiles to a regular data structure.</p> <p>The second line is a YS function call that happens to be a Clojure function call.</p> <p>Let's play around with that function call syntax a bit.</p> <pre><code>!YS-v0\nsay(\"Hello, world!\")\n</code></pre> <p>This compiles to the same Clojure code as the first example. We moved the <code>say</code> function name outside the parentheses. In YS this is called a YeS Expression.</p> <p>Note that from a YAML perspective, the entire YAML document is a single scalar value.</p> <p>YS code uses YAML scalars and YAML block mappings for code. Generally a mix of the two where the top (file level) structure is a nested mapping and the leaf values are scalar expressions.</p> <p>Let's change our code to use a mapping instead:</p> <pre><code>!YS-v0\nsay: \"Hello, world!\"\n</code></pre> <p>Again, this compiles to the same Clojure code as the first two examples.</p> <pre><code>!YS-v0\nsay: 'Hello, world!'\n</code></pre> <p>This is the same as the previous example, but the string is single-quoted. Single quotes aren't used for strings in Clojure, but they are in YAML.</p> <p>In YS, like Perl and Ruby, double quoted strings support variable interpolation and character escaping while single quoted strings do not.</p> <p>Let's get a bit fancier with our string:</p> <pre><code>!YS-v0\nname =: 'world'\nsay: \"Hello, $name!\"\n</code></pre> <p>That's a variable assignment and a string interpolation.</p> <pre><code>!YS-v0\nname =: 'world'\nsay: str('Hello, ', name, '!')\n</code></pre> <p>Clojure as a <code>str</code> function that concatenates strings together.</p> <p>See the commas between the <code>str</code> call arguments? In Clojure, commas are whitespace and are completely ignored. This is also true in YS!</p> <p>In general Clojure and YS only use commas in places where the code is hard to follow without them.</p> <pre><code>!YS-v0\nname =: 'world'\nsay: -'Hello, ' + name + '!'\n</code></pre> <p>Here we are doing something that you don't see in Clojure. We're using <code>+</code> to concatenate strings.</p> <p>When YS operators are infix they compile to polymorphic functions that work on types of data other than numbers.</p> <p>But what about the <code>-</code> in front of the string?</p> <p>Without the <code>-</code> this would be invalid YAML because YAML does not allow text on the same line after a quoted string.</p> <p>The <code>-</code> causes YAML to see everything after it as the scalar value: <code>-'Hello, ' + name + '!'</code>. This is like an escape character for situations where you want to write an expression but the first character is a syntax character in YAML. The <code>-</code> is removed and the rest of the scalar is compiled as an expression.</p>"},{"location":"doc/syntax/#basic-function-definition","title":"Basic Function Definition","text":"<pre><code>defn greet(name):\n  say: \"Hello, $name!\"\n\ngreet: 'Bob'\n</code></pre> <p>In Clojure we'd write this as:</p> <pre><code>(defn greet [name]\n  (say \"Hello, \" name \"!\"))\n\n(greet \"Bob\")\n</code></pre> <p>It's pretty easy to see what's going on here.</p> <p>Note how we use indentation nesting where Clojure uses parentheses. That's just the natural way to do things in YAML. Most of the YS syntax design is about making code look natural in YAML. It works out surprisingly well!</p>"},{"location":"doc/syntax/#variable-assignment-def-and-let","title":"Variable Assignment (def and let)","text":"<p>In the remaining examples we'll assume the <code>!YS-v0</code> tag is present.</p> <p>Note</p> <p>What we are calling variable assignment is known as symbol binding in Clojure. Clojure differentiates between symbols and variables but the distinction is not so important for YS.</p> <p>Assignments are done by using <code>name =: expression</code>.</p> <pre><code>foo =: bar() + 17\n</code></pre> <p>It looks like <code>=:</code> is some syntax added to YAML, but it's actually just a plain scalar value that ends with a space and an equals sign!</p> <p>These would work just as well:</p> <pre><code>foo   =   :\n  bar()\n  + 17\n\n? foo\n  =\n: bar()\n  + 17\n</code></pre> <p>Note</p> <p>The second form above uses YAML's rarely seen explicit key syntax. It can be useful sometimes in YS when you need spread the key portion of a key/value mapping pair over multiple lines. Without it mapping keys are required by YAML to be a single line. The 'value' side can always be multiline and can start on the next line too. This is a very common pattern in YS to make code more readable.</p> <p>Assignment statements written at the file level compile to <code>def</code> forms in Clojure, while those written inside a function compile to <code>let</code> forms.</p> <pre><code>defn f1():\n  a =: this()\n  b =: that()\n  =&gt;: a + b\n</code></pre> <p>This compiles to:</p> <pre><code>(defn f1 []\n  (let [a (this)\n        b (that)]\n    (+ a b)))\n</code></pre> <p>Notice how multiple consecutive assignments are compiled to a single <code>let</code> form. This is the preferred Clojure style and YS tries to compile to idiomatic Clojure code whenever possible.</p> <p>What's with the <code>=&gt;</code>? The special token <code>=&gt;</code> can be used as a placeholder key for when you want to use a single expression but being inside a mapping requires you use a key/value pair. The <code>=&gt;</code> is removed during compilation and the expression is left as the value.</p>"},{"location":"doc/syntax/#destructuring-assignment","title":"Destructuring Assignment","text":"<p>Many modern languages have destructuring assignment, where the LHS of an assignment looks like a data structure instead of a single variable. This quasi-data-structure is a collection of variables that are assigned values from the RHS of the assignment.</p> <p>Clojure and YS have destructuring assignment support for both sequences and mappings.</p> <pre><code>-[a b c] =: foo()\n-{d :d e :e} =: bar()\n</code></pre> <p>This would assign the first three values of the sequence returned by <code>foo</code> to <code>a</code>, <code>b</code>, and <code>c</code>, and the values of the <code>:d</code> and <code>:e</code> keys of the mapping to <code>d</code> and <code>e</code>.</p> <p>This can also be done in function arguments:</p> <pre><code>defn f(a [b c] d):\n  =&gt;: (a + (b * c)) / d\nf: 2 [3 4] 7  # =&gt; 2\n</code></pre> <p>Here you would call <code>f</code> with a single sequence argument and the first three values of that sequence would be assigned to <code>a</code>, <code>b</code>, and <code>c</code> respectively.</p> <p>For some reason Clojure does not support destructuring assignment in <code>def</code> forms but YS makes it work just fine.</p>"},{"location":"doc/syntax/#function-arguments","title":"Function Arguments","text":"<p>Like Clojure, all YS functions must be defined with the number of arguments they take. This is know as the function's arity. Functions can be written to take different specific numbers of arguments, where each arity has its own definition body. Functions can also be written to take a variable number of arguments.</p> <p>Multi-arity functions are called with the same name but the number of arguments used determines which body is evaluated.</p> <p>Note that unlike some other languages with multi-arity functions, the type of the arguments is not used to determine which body to evaluate.</p> <p>For example to define a function that takes two or more arguments:</p> <pre><code>defn foo(a b *more): ...\n</code></pre> <p>To define a function that can take 0, 1 or 3+ arguments:</p> <pre><code>defn foo:\n  (): ...\n  (a): ...\n  (a b c *more): ...\n</code></pre> <p>It would be an error to call the above function with 2 arguments.</p>"},{"location":"doc/syntax/#default-values","title":"Default Values","text":"<p>Clojure does not support default values for function arguments but YS does.</p> <pre><code>defn foo(a b=10 c='horse'): ...\n</code></pre>"},{"location":"doc/syntax/#work-in-progress","title":"Work in Progress","text":"<p>This document is a work in progress. More content will be added soon.</p>"},{"location":"doc/syntax/#see-also","title":"See Also","text":"<ul> <li>YS Modes - Understanding code mode vs data mode</li> <li>YeS Expressions</li> </ul>"},{"location":"doc/tutorial/","title":"YS Syntax Basics","text":"<p>Let's start learning about YS syntax by looking at a simple YS program.</p> <p>Here's a program to print some numbers (10 of them by default) from the fibonacci sequence:</p> <pre><code>!YS-v0\n\ndefn main(n=10):\n  loop a 0, b 1, i 1:\n    say: a\n    when i &lt; n:\n      recur: b, (a + b), i.++\n</code></pre> <p>When you run a YS program using the <code>ys</code> interpreter command it:</p> <ul> <li>Compiles the YS code to Clojure code</li> <li>Evaluates the Clojure code</li> </ul> <p>Let's try it (requesting 8 numbers from the fibonacci sequence):</p> <pre><code>$ ys fib.ys 8\n0\n1\n1\n2\n3\n5\n8\n13\n</code></pre> <p>Great, but to understand it better let's look at the Clojure code that it compiled to:</p> <pre><code>$ ys -c fib.ys\n(defn main\n ([n]\n  (loop [a 0 b 1 i 1]\n   (say a)\n   (when (&lt; i n) (recur b (add+ a b) (inc i)))))\n ([] (main 10)))\n(apply main ARGS)\n</code></pre> <p>note:</p> <pre><code>When learning or debugging YS programs, it's often very helpful to look at\nthe generated Clojure code using `ys -c`.\n</code></pre> <p>We can see 2 top-level forms in the generated Clojure code. The first is the <code>main</code> function definition, and the second is the call to the <code>main</code> function with the command-line arguments. That's interesting, we didn't actually call <code>main</code> in our ys program.</p> <p>The YS compiler automatically adds a call to <code>main</code> if it detects the <code>main</code> was defined but not called in the program.</p> <p>The Clojure <code>main</code> function has 2 bodies, one with an argument <code>n</code> and the other without any arguments. In the YS program there is only one function body, but not that the <code>n</code> argument has a default value of <code>10</code>. Clojure doesn't support default arguments, but the YS compiler can generate a second body that takes no arguments and calls the first body with the default.</p>"},{"location":"doc/v0/","title":"Understanding \"v0\"","text":"<p>The domain of YAML in the world of programming is vast and varied.</p> <p>YS intends to continually grow to meet YAML's needs as new use cases arise.</p> <p>By now you should be aware of the \"v0\" syntax that is required in various places in YS.</p> <p>The \"v0\" is meant to declare the YS API version being used. At some point soon, v0 will be declared stable and a new version of the language will begin development. At that point, no breaking changes will be made to the v0 syntax, thus all v0 YS / YAML files will continue to work indefinitely.</p> <p>Any new version of YS is free to break compatibility with the previous versions, while still allowing previous versions of libraries and files to be used.</p>"},{"location":"doc/v0/#the-v0v1-story","title":"The v0/v1 Story","text":"<p>You might expect that the next new version after v0 would be v1, but YS v0 is robust enough to be named v1 and also declared stable at the same time. This eliminates the notion that a stable v0 isn't production ready.</p> <p>The truth is that v0 is already a very capable language and very few things should change before v0/v1 is declared stable.</p>"},{"location":"doc/v0/#roadmap-to-v1-stable","title":"Roadmap to v1 Stable","text":"<p>Here's a list of the things that we want to add or change before the v1 release:</p> <ul> <li>Change the loader bindings (Python, Rust, etc) <code>load()</code> function to not allow   code evaluation by default.</li> </ul> <p>We want full capabilities configuration support, but this is the minimum   required to be able to declare v0/v1 stable.</p> <ul> <li>A basic configuration system for YS files.</li> </ul> <p>This will allow for the configuration of the YS loader and other things.</p> <ul> <li>Use of external dependencies in YS files.</li> </ul> <p>We want v0 to be able to declare its dependency libraries from GitHub, Maven,   local files and other sources.</p> <ul> <li>Internal restructuring of the built-in libraries.</li> </ul> <p>We want to review the internal library names and function names and signatures   to make sure they are consistent and easy to use.   A few functions might be renamed, changed or removed.</p> <ul> <li>Add support for <code>v1</code> to be interpreted as <code>v0</code> in all cases.</li> </ul> <p>This is rather minor, but obviously needs to happen before v1 is declared a   stable equivalent to v0.</p> <p>We'll add to this list as necesary blockers are identified.</p> <p>Overall v0 is quite stable and we want to make the v0/v1 stable release as soon as possible.</p>"},{"location":"doc/v0/#places-where-v0-is-required","title":"Places where \"v0\" is required","text":"<ul> <li>YS mode tags \u2014 <code>!YS-v0</code>, <code>!yamlscript/v0</code>, etc.</li> <li>The <code>#!/usr/bin/env ys-0</code> shebang line. Here we use <code>ys-0</code> rather than <code>ys-v0</code>   because <code>ys-0</code> is the actual name of binary found in <code>PATH</code>.</li> </ul>"},{"location":"doc/vocab/","title":"YS Vocabulary","text":"<p>YAML and YS have specific names for the various parts of the language. It is important to understand these terms to be able to better understand the documentation and how the language works.</p>"},{"location":"doc/vocab/#yaml-vocabulary","title":"YAML Vocabulary","text":"<ul> <li> <p>file</p> <p>A YAML file is a text file that contains a YAML stream. The file name often has a <code>.yaml</code>, <code>.yml</code>, or <code>.ys</code> extension, but this is not required.</p> </li> <li> <p>stream</p> <p>A YAML stream is a sequence of zero or more documents. Each document is a complete YAML text. The documents are separated by <code>---</code> or <code>...</code> lines. The stream is the top-level structure of a YAML file.</p> </li> <li> <p>document</p> <p>A YAML document is a single YAML text. A document represents a single node; either a mapping, sequence or scalar.</p> </li> <li> <p>node</p> <p>A YAML node is a single piece of data. A node can be a mapping, sequence, or scalar.</p> </li> <li> <p>kind</p> <p>A generic word for mapping, sequence or scalar. You would say \"there are 3 kinds of nodes\", not \"there are 3 types of nodes\".</p> </li> <li> <p>mapping</p> <p>A YAML mapping is a collection of key/value pairs. The key and the value can be any node.</p> </li> <li> <p>sequence</p> <p>A YAML sequence is a sequential list of nodes. The nodes are ordered and can be any node.</p> </li> <li> <p>collection</p> <p>A YAML collection is either a mapping or a sequence.</p> </li> <li> <p>scalar</p> <p>A YAML scalar is a single piece of data. A scalar typically represents a string, number, boolean, or null, but it can be any object that can be represented in YAML serialized to a string form.</p> </li> <li> <p>pair</p> <p>A YAML pair is two consecutive nodes in a mapping. The first node is the key and the second node is the value.</p> </li> <li> <p>key</p> <p>The first node of a mapping pair.</p> </li> <li> <p>explicit key</p> <p>In a block mapping pair, a key can use a leading <code>?</code> as an explicit key indicator. This is useful if you need a scalar key to be multi-line:</p> <p><pre><code>? a long\n  key string\n: value\n</code></pre> same as:</p> <pre><code>a long key string: value\n</code></pre> <p>Note how the <code>:</code> is placed at the start of the line before the value. This is necessary when using the explicit key syntax.</p> </li> <li> <p>value</p> <p>The second node of a mapping pair.</p> </li> <li> <p>tag</p> <p>A YAML tag is an short string annotation attached to a =node that specifies how that node should be processed. Tags start with <code>!</code> followed by 0-n characters (excluding whitespace and certain syntax characters).</p> <p>Explicit tags are not often used in practice, but internally a YAML loader implicitly assigns a tag to every node that doesn't have an explicit tag.</p> </li> <li> <p>anchor</p> <p>A YAML anchor is a short string annotation attached to a =node that can be used to reference (=alias) that node elsewhere in the =document. Anchors start with <code>&amp;</code> followed by 1-n characters (excluding whitespace and certain syntax characters).</p> </li> <li> <p>property</p> <p>A term used to mean either the tag or the anchor of a node.</p> </li> <li> <p>alias</p> <p>A YAML alias is a short string annotation attached to a =node that references another =node with the same anchor.</p> </li> <li> <p>block style</p> <p>YAML collections can be written in either block style or flow style. Block style uses indentation to indicate structure. This is the most common style used in YAML files. Any sub-node of a block collection can use either block or flow style.</p> </li> <li> <p>flow style</p> <p>YAML collections can be written in either block style or flow style. Flow style uses curly braces, square brackets, colons and commas to indicate structure. Flow style is very much like JSON and is actually a superset of JSON. Sub-nodes of a flow collection must also use flow style.</p> </li> <li> <p>plain style scalar</p> <p>A YAML scalar can be written in any or 5 styles within a block collection: plain, single-quoted, double-quoted, literal, or folded. In a flow collection, only the plain, single-quoted, and double-quoted styles are allowed.</p> <p>A plain style scalar is one without any quoting. It can span multiple lines. It can't:</p> <ul> <li>Start or end with whitespace</li> <li>Start a YAML syntax character: <code>[]{},\"'&amp;*#?!|&gt;-%@</code></li> <li>Contain the <code>:</code> or <code>#</code> character sequences</li> <li>Make use of YAML escape sequences</li> </ul> </li> <li> <p>single-quoted style scalar</p> <p>A single-quoted style scalar is one enclosed in single quotes. It can span multiple lines. It uses the <code>''</code> sequence to represent a single quote within the scalar.</p> </li> <li> <p>double-quoted style scalar</p> <p>A double-quoted style scalar is one enclosed in double quotes. It can span multiple lines. It can make use of <code>\\</code> escape sequences to represent special characters.</p> </li> <li> <p>literal style scalar</p> <p>A literal style scalar is one that uses the <code>|</code> character to indicate that the scalar spans multiple lines. The scalar is written on the next line and all subsequent lines that are indented more than the first line are part of the scalar.</p> <p>Literal scalars are very much like here-documents seen in Perl and shell languages. You can use them to represent almost any text, including code files and other YAML files, simply by indenting them correctly.</p> <p>Even Makefiles, which have lines that start with tabs (which are forbidden in YAML indentation), can be represented in YAML literal scalars without changing the content.</p> </li> <li> <p>folded style scalar</p> <p>A folded style scalar is one that uses the <code>&gt;</code> character to indicate that the scalar spans multiple lines. Folded scalars follow certain rules that \"fold\" newlines and whitespace into single spaces. The rules are complicated. You can often get the desired results by just using plain style scalars instead.</p> </li> <li> <p>loader</p> <p>A YAML loader is a program that reads a YAML stream and converts it into a native data structure that can be used by the program. A loader is a stack of stages (aka transforms) that each convert their input from one state to another. The names of the transforms are: parser, composer, resolver and constructor.</p> </li> <li> <p>parser</p> <p>People often user the term \"parser\" to refer to the entire loader, but the parser is actually just one of the transforms in the loader. In most implmentations, the parser and the lexer are combined into a single transform that turns the input stream of characters into a stream of events.</p> <p>It is by far the most complex transform in the loader, and is defined by 211 productions in the YAML 1.2 specification.</p> </li> <li> <p>event</p> <p>An event is a data structure that represents a scalar value, an alias reference, or the start or end of a stream, document, mapping, or sequence. There are 10 types of events typically generated by the parser: STREAM-START, STREAM-END, DOCUMENT-START, DOCUMENT-END, MAPPING-START, MAPPING-END, SEQUENCE-START, SEQUENCE-END, SCALAR, and ALIAS.</p> <p>The event structures contain certain attributes of the input that are needed for further processing. For instance START-* and SCALAR events contain the style, tag, and anchor properties, and SCALAR events also contain the value. All events contain the start and end positions of the input that they represent.</p> </li> <li> <p>composer</p> <p>The loader stage that transforms the stream of events into a tree of nodes.</p> </li> <li> <p>resolver</p> <p>The loader stage that assigns tags to the nodes that didn't have an explicit one. Possibly normalizes the nodes in some way.</p> </li> <li> <p>constructor</p> <p>The loader stage that converts the nodes into a native data structure that can be used by the program.</p> </li> <li> <p>dumper</p> <p>A YAML dumper is a program that takes a native data structure and converts it into a YAML stream. A dumper is a stack of stages (aka transforms) that each convert their input from one state to another, in reverse order of the loader.</p> </li> </ul>"},{"location":"doc/vocab/#ys-vocabulary","title":"YS Vocabulary","text":"<ul> <li> <p>mode</p> <p>A YS mode is a set of rules that determine the semantics of a given YAML node by YS. Every YAML node in a stream has one of 3 modes:</p> <ul> <li>bare - Node follows the semantics of a normal YAML loader.   Sub-nodes will always be of bare mode as well.   That is, no code evaluation can ever take place.</li> <li>code - Node is meant to be compiled as code to be evaluated.   The <code>say: 'Hello'</code> mapping pair will print \"Hello\", because the unquoted key   <code>say</code> is a symbol bound to the <code>ys::std/say</code> function.   Any sub-node can be changed to data mode (or bare mode).</li> <li>data - Node is meant to be compiled as having data semantics.   This is similar to bare mode, except any sub-node can change modes to code   mode (or bare mode).</li> </ul> </li> <li> <p>mode tag</p> <p>Unless a YAML/YS document starts with a mode tag, then it is assigned to bare mode and treated as normal YAML. These tags are used to indicate the mode of a node:</p> <ul> <li><code>!YS-v0</code> - Start a document in code mode</li> <li><code>!YS-v0:</code> - Start a document in data mode</li> <li><code>!bare</code> - Make a node have bare mode semantics</li> <li><code>!code</code> - Make a node have code mode semantics</li> <li><code>!data</code> - Make a node have data mode semantics</li> <li><code>!</code> - Toggle between code and data modes (or vice versa)</li> </ul> <p>A <code>!YS-v0</code> or <code>!YS-v0:</code> mode tags must appear before any other mode tag is used in a stream. Each document in a stream must have mode tag or else it is considered bare mode.</p> </li> <li> <p>expression</p> <p>An evaluatable piece of YS code.</p> </li> <li> <p>S-expression</p> <p>Lisp term for a parenthesized list of 1 or more forms where the first form is a function and the rest of the forms are arguments. Any of the forms may themselves be s-expressions.</p> <pre><code>(println (* 6 7))  # =&gt; 42\n</code></pre> <p>YS supports s-expressions, YeS-expressions, pair-expressions and dot-chain expressions.</p> </li> <li> <p>YeS-expression</p> <p>A YS syntax where the function name comes before the opening parentheses and infix operator expressions are allowed:</p> <pre><code>println(6 * 7)\n</code></pre> </li> <li> <p>Pair expression</p> <p>A YS expression as a mapping pair where the function comes first on the LHS. The argument forms can be on either side of the <code>:</code>.</p> <pre><code>println: 6 * 7\n</code></pre> </li> <li> <p>Dot-chain expressions</p> <p>Functions can be applied to values <code>.fn-name()</code>: These are the same:   <pre><code>fn2(fn1(val1 val2))\nval1.fn1(val2).fn2()\nval1.fn1(val2):fn2\n</code></pre></p> <p>The LHS of a dot function call generally becomes the first argument. If there is only one argument then: <code>arg:fn1</code> is short for <code>arg.fn1()</code>.</p> </li> </ul>"},{"location":"doc/yaml/","title":"YAML Basics","text":"<p>YAML was created to make data documents simple (most of the time). It was also created to give people a lot of control over how they write their data.</p> <p>Modern programmers generally have a decent understanding of YAML basics as it ends up in many places in the tech world. That said, there are many lesser well-known YAML concepts and features and YS makes use of most of them.</p> <p>Remember, all valid YS is required to be valid YAML syntax. To write YS well, you'll need to have a solid understanding of YAML concepts and also Clojure concepts.</p> <p>This document will cover all the YAML syntax, concepts and vocabulary that you need to know to write YS effectively.</p> <p>Note</p> <p>When a word or phrase is presented in double quotes here, it is intended to be a YAML vocabulary term that you should commit to memory. These terms are used consistently throughout the YS documentation (and also the YAML specification and other YAML-related writings).</p>"},{"location":"doc/yaml/#yaml-data-model","title":"YAML Data Model","text":"<p>YAML represents the same kinds of data as JSON: \"mappings\", \"sequences\" and \"scalars\".</p> <ul> <li>A \"mapping\" is an unordered collection of key-value pairs where each key is   unique.   Mappings are also known as 'hashes', 'dictionaries', 'objects' or 'associative   arrays' in other languages, but in YAML they are always called mappings.</li> <li>A \"sequence\" is an ordered collection of values.   Sequences are also known as 'arrays', 'lists' or 'vectors' elsewhere.</li> <li>A \"scalar\" is a single value, like a number, string, keyword, boolean or even   a null value.   Scalars are also known as 'atoms' or 'primitives' elsewhere.</li> </ul> <p>YAML adds just a few things to this basic data model:</p> <ul> <li>YAML \"streams\" can consist of one YAML \"document\" (the normal case), multiple   documents separated by <code>---</code> / <code>...</code>, or no documents at all.</li> <li>A YAML \"stream\" is all of the YAML text in a single YAML file or YAML string     passed to a YAML \"loader\" or generated by a YAML \"dumper\".</li> <li>A YAML \"document\" is a single YAML data \"node\".</li> <li>A \"node\" is a single value in the YAML data model: a mapping, sequence or     scalar.</li> <li>Any YAML node in a document can be given a name (called an \"anchor\") and   referred to by that name elsewhere in the document using an \"alias\".</li> <li>An anchor looks like <code>&amp;foo</code> and an alias looks like <code>*foo</code>.</li> <li>Example:     <pre><code>first: &amp;anchor\n  a: mapping\nsecond: *anchor  # Both values are the same mapping: {\"a\": \"mapping\"}.\n</code></pre></li> <li>A mapping key can be any \"kind\" of YAML node, (not just a scalar node like in   JSON).</li> <li>This is not commonly used either in YAML or YS, but it is completely valid.</li> <li>The term \"kind\" is used to refer to those three different YAML node shapes:     \"mapping\", \"sequence\" or \"scalar\".</li> <li>Any YAML node can have a \"explicit tag\".</li> <li>A tag looks like <code>!foo-bar</code> and is used to associate a word or string with     a that YAML node.</li> <li>Tags typically instruct a YAML loader how to interpret the node.</li> <li>Even though it is rare to see tags in YAML, part of the loading process is     to assign a tag to every node that lacks an explicit one.     This process is known as \"implicit tagging\" or \"tag resolution\".</li> <li>In YS, the tags <code>!YS-v0</code> and just <code>!</code> are quite common.     They control the YS \"mode\" of a particular node.</li> </ul>"},{"location":"doc/yaml/#basic-yaml-syntax","title":"Basic YAML Syntax","text":"<p>YAML supports a comment syntax. Comments start with a <code>#</code> and continue to the end of the line. Blank lines are also considered comments. The <code>#</code> must be at the start of the line or preceded by whitespace.</p> <p>We'll show you some YAML examples to illustrate the basic syntax and use YAML comments to explain the concepts as much as possible.</p> <p>Example 1: A YAML stream with several syntax elements:</p> <pre><code># A line starting with `---` is used to begin a new document.\n# It is not required for the first document in a stream.\n# It is common to put any tag or anchor for the top level node on the same\n# line as the `---`.\n\n---\n\n# Let's start with the common mapping and sequence nodes.\n# Mappings are a group of \"pairs\", each consisting of a \"key\" and a \"value\"\n# separated by a colon.\n# Sequences are a group of nodes where each one is prefixed by a dash.\n# Both the colon and the dash must be followed by a whitespace to be valid.\n\n# The top level node of this document is a mapping.\n\n# For the first pair we have a scalar key and a scalar value.\n# Notice how the key is single-quoted and the value is double-quoted.\n\n'first-key': \"first-value\"\n\n# The second pair has another scalar key and scalar value.\n\nsecond-key: second value\n\n# Notice that both of them are unquoted.\n# Scalars of can be expressed with or without quotes.\n# This is very common in YAML and very important in YS.\n\n# The kind of quoting (or lack thereof) is called the scalar's \"style\" in YAML.\n# The different quoting styles have different encoding rules and different\n# semantics.\n# There are actually 5 distinct scalar styles in YAML: plain, single quoted,\n# double quoted, literal and folded.\n# We'll cover these styles in more detail in a second.\n\n# Mapping pair values can be any kind of YAML node.\n# Mappings and sequences can also be used as values and nested to an arbitrary\n# depth.\n# This is accomplished by indenting the nested node using one or more spaces.\n\nthird-key:\n  a: sub-mapping\n  second:\n  - a sequence\n  - of values\n  - a scalar\n  - - sub-sequence\n    - items\n  - another: sub-mapping\n\n  # The sequence value under the key `second` here doesn't seem to be indented\n  # but the leading dash acts as indentation.\n  # This is the preferred style for indenting sequence values of mapping pairs\n  # in YAML, but you can also indent them more if you prefer.\n\n  another sequence:\n  - one\n  - two\n\nHere's what the 5 scalar styles look like:\n\nplain:\n- I'm unquoted and plain\n- I can also span multiple lines\n  where whitespace beteween lines\n  folds to a single space\nsingle quoted:\n- 'I''m single quoted'\n- 'I have one thing that is escapable,\n  the single quote itself '' which\n  is escaped by doubling it'\n- 'Multiline single quoted scalars\n  fold the same way as plain'\ndouble quoted:\n- \"I'm double quoted\"\n- \"I'm the only style capable of encoding\n  any possible string value\"\n- \"I have lots of escapes like \\n and \\t\n  and also \\\" and \\\\\"\n- \"Multiline double quoted scalars\n  fold the same way as plain\"\nliteral: |\n  I'm like a heredoc in Shell or Perl.\n\n  But my scope is determined by indentation.\n  Newlines are preserved as you would expect\n  from a heredoc.\nfolded: &gt;\n  Folded scalars pretty much fold like\n  the others, but you can use them without\n  worry of ` #` or `: ` being special.\n\n  They are the most rarely used scalar style.\n\nIn YS code mode:\n- plain: Used for code expressions\n- single quoted: Used for character strings\n- double quoted: Used for strings with interpolation support\n- literal: Used for template strings including interpolation\n- folded: Not allowed in code mode\n\n# A line with `...` is used to end a document.\n# It's optional, since `---` does the same thing, but you might want to use it\n# for clarity.\n\n...\n\n\n# Here we start a second document in the stream.\n# This one is a top level sequence and it has an anchor and a tag:\n# The `---` indicator is required and you can also use the line to specify the\n# anchor and tag for the top level node.\n\n--- &amp;my-seq-1 !a-tag\n\n# The first sequence item is a scalar string with content of \"first item\".\n- first item\n\n# The second item is another sequence:\n-\n  - one\n  - two\n\n# It is possible, typical and preferred to collapse this like so:\n- - one\n  - two\n\n# The third item is a mapping:\n-\n  foo: bar\n  baz: 42\n\n# This may also be collapsed (and is also preferred) like so:\n\n- foo: bar\n  baz: 42\n\n# This sequence collapsing can be many levels deep:\n\n- - - - foo: bar\n\n# But don't try collapsing multiple mappings.\n# The next line would be an error:\n\n# - foo: bar: baz   # ERROR ': ' not allowed in plain scalars\n\n# A third document in the stream. Note that no `...` was used to end the\n# previous document.\n\n---\n\n# Mappings and sequences can be expressed using a different syntax that looks\n# like JSON.\n# YAML uses curly braces for mappings and square brackets for sequences.\n# These are called \"flow style\" for \"collections\".\n# The normal indented style we've been using is called \"block style\" by\n# comparison.\n# Note: A YAML \"collection\" is the generic term for a node that is either a\n# mapping or a sequence.\n\nkey 1: {x: red,\n        y: blue, z: green}\nkey 2: [red, blue,\n        green]\n\n# If you ever need an empty mapping or sequence, you need to use the following:\n\nempty mapping: {}\nempty sequence: []\n\n# There is actually no way to write empty collections in block style.\n</code></pre>"},{"location":"doc/yaml/#less-common-yaml-syntax","title":"Less Common YAML Syntax","text":"<p>Here's a few YAML syntax variants that you won't see very often. Some of these are used in YS, so it's good to know about them.</p> <pre><code># YAML has a top level \"directive\" syntax.\n# There are only 2 directives defined by the YAML 1.2 specification:\n# This is the first one, the \"YAML directive\".\n# It simply specifies the version of the YAML specification in play.\n\n%YAML 1.2\n\n# The second directive is the \"TAG directive\".\n# It allows you to specify a shorthand for a tag URI.\n\n%TAG !ys! tag:yamlscript.org,2022:\n\n# To date, directives are not used in YS.\n\n# The `---` indicator is required to start a new document if you have used any\n# directives (even on the first document).\n\n---\n\n# YAML allows a mapping key to be any node, not just a scalar.\n# In other words it allows collections or even aliases to be used as keys.\n\n- &amp;map1\n  a: value\n# Here it is obvious that the key is a mapping.\n- *map1 : 42\n# Here we are using YAML's \"explicit key\" syntax (`?`) to specify the key.\n- ? [a, flow, sequence]\n  : 42\n# We can use `?` with block collections too.\n- ? a: block\n    mapping: key\n  : 43\n# We can even use it for literals scalar keys.\n- ? |-\n    a literal\n    scalar key\n  : 44\n\n---\n\n# The collection key does have a good use case in YS.\n# Consider this `for` loop:\n\nfor a foo(), b bar(), c [1 2 3]:\n  say: a + b + c\n\n# YS requires that the `for [\u2026]` key be a plain scalar, and YAML\n# requires that plain scalar keys need to be a single line.\n# This could lead to unreadable code if we our \"for binding\" is complex.\n\n# Bute can also do it like this:\n\nfor:\n  ? a: foo()\n    b: bar()\n    c: [1 2 3]\n  : say: a + b\n\n# Which you might find to be clearer.\n</code></pre>"},{"location":"doc/yaml/#see-also","title":"See Also","text":"<ul> <li>The yaml.info Site\u00a0 </li> <li>Common YAML / YS Gotchas</li> </ul>"},{"location":"doc/yes/","title":"YeS Expressions","text":"<p>Lisp has the concept of S-Expressions\u00a0  (aka <code>sexpr</code>s), nested parenthesized expressions where the parentheses contain a function (usually a symbol bound to a function) followed by its arguments.</p> <p>YS has a concept called \"YeS Expressions\" (aka <code>ysexpr</code>s) which offer alternate ways to write sexprs in a style that feels more familiar to non-Lisp language expressions.</p> <p>Note</p> <p>In general, YS supports writing code as sexprs, ysexprs or as block mapping pairs. Nested expressions can combine any of those forms. It's up to the programmer to decide which works best for them in any given context.</p> <pre><code>(def var1 (sqrt (+ (* 3 4) 5)))\n</code></pre> <p>The equivalent code in Python would be:</p> <pre><code>var1 = sqrt(3 * 4 + 5)\n</code></pre> <p>In YS, we could write:</p> <pre><code>var1 =: sqrt((3 * 4) + 5)\n</code></pre> <p>There are 3 notable transformations happening here:</p> <ul> <li>Functions named by a word can be placed before the opening paren instead of   inside it.   e.g. <code>a(b c)</code> translates to <code>(a b c)</code>.   Note that no whitespace can come between the <code>a</code> and the <code>(</code>.</li> <li>Prefix operations can be written infix.   e.g. <code>(a + b)</code> translates to <code>(+ a b)</code>.   Triplets with an operator (punctuation) symbol in the middle get this   treatment.</li> <li>Variable assignment (aka symbol binding) can be written using <code>=:</code> YAML   mapping pairs.   e.g. <code>a =: b + c</code> translates to <code>(def a (+ b c))</code>.   Note that whitespace is required on both sides of the <code>=:</code>.</li> </ul> <p>We'll discuss the a few more details of each of these YeS expression transforms below.</p> <p>Note</p> <p>YS has many other transformations that strive to make YS code clean and easy to read and understand. YeS expression transformations are among the most commonly used.</p>"},{"location":"doc/yes/#prefix-call-notation","title":"Prefix Call Notation","text":"<p>The most common way to call a function in non-Lisp programming languages is <code>a()</code>, <code>a(b)</code>, <code>a(b c)</code> etc where <code>a</code> is the name of a function and <code>b</code> and <code>c</code> are arguments that the function is called with. Lisp languages use the same format but put the <code>a</code> inside the parens.</p> <p>YS lets you do either. Again the <code>a</code> must be next to the <code>(</code>. IOW, <code>a (b c)</code> is not the same as <code>a(b c)</code>!</p> <p>Another way to write the function call <code>(a b c)</code> in YS is to use it in a mapping pair context:</p> <pre><code>a: b c\n# Or sometimes:\na b: c\n</code></pre>"},{"location":"doc/yes/#infix-operator-notation","title":"Infix Operator Notation","text":"<p>Lisps write binary operator expressions like:</p> <pre><code>(+ a 5)  ;; a + 5\n(&gt; a 5)  ;; a &gt; 5\n</code></pre> <p>That makes sense because <code>+</code> and <code>&gt;</code> are just ordinary Lisp symbols bound to addition and greater-than functions.</p> <p>One advantage of this prefix notation is that this operations can take more than 2 arguments:</p> <pre><code>(+ a b c d)  ;; a + b + c + d\n(&gt; a b c d)  ;; a &gt; b &gt; c &gt; d  or  (a &gt; b) &amp;&amp; (b &gt; c) &amp;&amp; (c &gt; d)\n</code></pre> <p>YeS expressions allow you to do these things:</p> <pre><code>=&gt;: a + b        # (+ a b)\n=&gt;: a + b + c    # (+ a b c)\n=&gt;: a + b &gt; c    # ERROR - no operator mixing; no implicit precedence in YS\n=&gt;: (a + c) &gt; c  # (&gt; (+ a b) c) - Fine with parens\n</code></pre> <p>Note that we didn't need any parentheses around <code>a + b</code>. When a YAML plain scalar with an operator triplet (or multiple forms separated by the same operator) the parentheses are implied and thus optional. The parentheses are implied in a few other contexts as well like:</p> <pre><code>if a &gt; b: c d\n# Equivalent to:\nif (a &gt; b): c d\n</code></pre>"},{"location":"doc/yes/#when-operators-are-arguments","title":"When Operators are Arguments","text":"<p>Every once in a while you might want to pass an operator as an argument to a function call triplet like <code>(apply + numbers)</code> and YS would wrongly translate that to <code>(+ apply numbers)</code>.</p> <p>This is easily avoided by using the prefix call notation described above: <code>apply(+ numbers)</code>. It is also avoided when using the block mapping pair form:</p> <pre><code>apply +: numbers\n</code></pre> <p>Also note that the operator switching only applies to triplet forms, so expressions like <code>(a +)</code> and <code>(a + b c)</code> are never affected.</p>"},{"location":"doc/yes/#assignment-symbol-binding-expressions","title":"Assignment (Symbol Binding) Expressions","text":"<p>In many programming languages, like Python for instance, it's common to see things like:</p> <pre><code>a = b(c)\n</code></pre> <p>where the evaluation result of the function <code>b(c)</code> is assigned (aka bound) to the variable (or symbol) <code>a</code>.</p> <p>In Clojure you would use a <code>def</code> form:</p> <pre><code>(def a (b c))\n</code></pre> <p>Unless it was inside a function scope, in which case you would use a <code>let</code> form:</p> <pre><code>(defn f [b c]\n  (let [a (b c)]\n    (d a)))\n</code></pre> <p>In YS you can write them both the same way:</p> <pre><code>a =: b(c)\n# and\ndefn f(b c):\n  a =: b(c)\n  d: a\n</code></pre> <p>In Clojure you can define multiple <code>let</code> bindings in a single <code>let</code> form.</p> <pre><code>(defn f [a]\n  (let [b (inc a)\n        c (dec a)]\n    (d b c)))\n</code></pre> <p>In YS you can do the same thing:</p> <pre><code>defn f(a):\n  b =: inc(a)\n  c =: dec(a)\n  d: b c\n</code></pre> <p>The YS compiler joins consecutive <code>=:</code> pairs into a single <code>let</code> form, resulting in the same Clojure code as the example above.</p> <p>In Clojure you can bind multiple symbols at once using destructuring:</p> <pre><code>(defn f []\n  (let [[a b] (c)]\n    (g a b)))\n</code></pre> <p>This binds <code>a</code> and <code>b</code> to the first two elements of the sequence returned by calling <code>c</code>.</p> <p>Note that this works for a <code>let</code> expression but not for a <code>def</code> expression:</p> <pre><code>(def [a b] (c))  ;; Syntax error\n</code></pre> <p>In YS it works fine:</p> <pre><code>-[a b] =: c()\n</code></pre>"},{"location":"doc/yes/#conclusion","title":"Conclusion","text":"<p>YeS Expressions are a key way to help you write YS code that looks more like the code you're used to writing in non-Lisp languages, while still retaining the full power of Lisp (Clojure). It's your choice how you want your code to look, and YS gives you many options for that.</p> <p>No matter what your valid YS code looks like, it always compiles to valid Lisp, which makes it extremely reliable to reason about.</p> <p>The power of Lisp is that its input expressions almost completely match the internal evaluation forms that it compiles to. It's very obvious what's going on under the hood, because it's the same as what you see on the outside. This is called homoiconicity\u00a0 .</p> <p>In dynamic languages like JavaScript, Python, Ruby or Perl you don't really get to see what your code turns into before it is evaluated.</p> <p>YS tries to offer a very flexible set of coding styles that always compile to Lisp's extremely robust evaluation form.</p>"},{"location":"doc/ys-clj/","title":"Replaced Clojure Functions","text":"<p>A number of standard functions from Clojure's standard library <code>clojure::core</code> have been replaced by functions in the <code>ys::std</code> library. In general the replacements have the same intent as the original functions, but from a YS perspective.</p> <p>When you absolutely need the original Clojure functions, they are available in this <code>ys::clj</code> library. These functions are automatically available in YAMLSCript by using the <code>clj/</code> prefix.</p>"},{"location":"doc/ys-clj/#functions","title":"Functions","text":"<p>The documentation for these functions is available in the Clojure documentation web site, so we include a link to there in each definition.</p> <ul> <li> <p><code>clj/compile</code> \u2014 In Clojure\u00a0  the   <code>compile</code> function compiles a namespace into a set of class files.   In YS it converts a YS source code string into a   Clojure source code string.</p> </li> <li> <p><code>clj/load</code> \u2014 In Clojure\u00a0  the   <code>load</code> function loads a file from the classpath.   In YS it's an alias for <code>load-file</code>(below).</p> </li> <li> <p><code>clj/load-file</code> \u2014 In Clojure\u00a0    the <code>load-file</code> function loads a Clojure file from a given file path.   In YS it loads a YS file from a given file path.</p> </li> <li> <p><code>clj/num</code> \u2014 In Clojure\u00a0  the <code>num</code>   function converts a Java number to a Clojure number.   In YS it converts a numeric string to a number.</p> </li> <li> <p><code>clj/use</code> \u2014 In Clojure\u00a0  the <code>use</code>   function is used to refer a namespace into the current namespace.   In YS it loads a YS or Clojure library from <code>YSPATH</code>.</p> </li> </ul>"},{"location":"doc/ys-csv/","title":"CSV and TSV","text":"<p>This library provides functions for reading and writing the CSV\u00a0  and TSV\u00a0  formats.</p> <ul> <li><code>read(S)</code> \u2014 Short name for <code>csv/read-csv(S)</code></li> <li><code>read-csv(s)</code> \u2014 Convert a CSV string to a list of lists</li> <li><code>read-tsv(s)</code> \u2014 Convert a TSV string to a list of lists</li> <li><code>write(S)</code> \u2014 Short name for <code>csv/write-csv(S)</code></li> <li> <p><code>write-csv(LoL)</code> \u2014 Convert a list of lists to a CSV string |</p> </li> <li> <p><code>write-tsv(LoL)</code> \u2014 Convert a list of lists to a TSV string</p> </li> </ul>"},{"location":"doc/ys-json/","title":"JSON Library","text":"<ul> <li><code>load(S)</code> \u2014 Load a JSON string to a native data structure.</li> <li><code>dump(X)</code> \u2014 Dump a native data structure to a JSON string.</li> <li><code>pretty(X)</code> \u2014 Dump a native data structure to a pretty JSON string.</li> </ul>"},{"location":"doc/ys-libs/","title":"YS Builtin Libraries","text":"<ul> <li><code>ys::clj</code> \u2014 Original Clojure functions replaced by <code>ys::std</code></li> <li><code>ys::json</code> \u2014 JSON load and dump functions</li> <li><code>ys::std</code> \u2014 YS standard library</li> <li><code>ys::taptest</code> \u2014 TAP Test library</li> <li><code>ys::yaml</code> \u2014 YAML load and dump functions</li> <li><code>ys::ys</code> \u2014 Using YS in YS</li> </ul>"},{"location":"doc/ys-std/","title":"Standard Library","text":"<p>YS has over 1000 functions that are always available to your YS programs without needing to explicitly import (<code>use</code>) any libraries. Over 800 of these can be used without a namespace prefix like <code>str/</code> or <code>math/</code>.</p> <p>Most of these functions are from the Clojure standard library\u00a0 , but YS also has the <code>ys::std</code> standard library that provides additional functions.</p> <p>This document describes the <code>ys::std</code> functions and how to use them. It also links to related functions in the Clojure core library.</p> <p>Note</p> <p>In a few cases, the YS standard library replaces some Clojure functions with a version more suited to YS. In those cases, the original Clojure function is still available in the <code>ys::clj</code> namespace.</p>"},{"location":"doc/ys-std/#string-functions","title":"String functions","text":"<ul> <li><code>base64-decode(Str) \u2192 Str</code> \u2014 Decode a base64 string</li> <li><code>base64-encode(Str) \u2192 Str</code> \u2014 Encode a string to base64</li> <li><code>base64-points(Str) \u2192 [Int]</code> \u2014 Decode a base64 string to code points</li> <li><code>base64(Str) \u2192 Str</code> \u2014 Alias of base64-encode</li> <li> <p><code>blank?(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/blank?</code> </p> <p>True if string is nil, empty or only whitespace</p> </li> <li> <p><code>chomp(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/trim-newline</code> </p> <p>Remove trailing newlines</p> </li> <li> <p><code>chop(Str) \u2192 Str</code> \u2014 Remove last character</p> </li> <li> <p><code>ends?(Str) \u2192 B</code> \u2014 Alias of <code>clojure.string/ends-with?</code> </p> <p>True if string ends with suffix</p> </li> <li> <p><code>escape(Str {Chr:Str}) \u2192 Str</code> \u2014 Alias of <code>clojure.string/escape</code> </p> <p>Escape special characters in a string</p> </li> <li> <p><code>index(Str Str) \u2192 Int</code> \u2014 Alias of <code>clojure.string/index-of</code> </p> <p>Find index of substring</p> </li> <li> <p><code>join([Str]) \u2192 Str</code> \u2014 Join strings or seqs with <code>\"\"</code></p> </li> <li><code>join(sep [Str]) \u2192 Str</code> \u2014 Join strings or seqs with a separator</li> <li><code>joins([Str]) \u2192 Str</code> \u2014 Join strings with <code>\" \"</code></li> <li> <p><code>lc(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/lower-case</code> </p> <p>Lowercase a string</p> </li> <li> <p><code>lines(Str) \u2192 [Str]</code> \u2014 Split a string into lines</p> </li> <li><code>pretty(Str) \u2192 Str</code> \u2014 Pretty print a value</li> <li><code>replace(X) \u2192 X</code> \u2014 Alias of <code>clojure.core/replace</code> </li> <li> <p><code>replace(Str Rgx Str?) \u2192 Str</code> \u2014 Alias of <code>clojure.string/replace</code> </p> <p>Replace all occurrences of regex with new string (default \"\")</p> </li> <li> <p><code>replace1(Str Rgx Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/replace-first</code> </p> <p>Replace first occurrence of regex with new string</p> </li> <li> <p><code>rindex(Str Str) \u2192 Int</code> \u2014 Alias of <code>clojure.string/last-index-of</code> </p> <p>Find last index of substring</p> </li> <li> <p><code>split(Str) \u2192 [Str]</code> \u2014 Like <code>clojure.string/split</code> </p> <p>Split on <code>\"\"</code></p> </li> <li> <p><code>split(Str rgx) \u2192 [Str]</code> \u2014 Alias of <code>clojure.string/split</code> </p> <p>Split a string by a regex</p> </li> <li> <p><code>starts?(Str Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/starts-with?</code> </p> <p>True if string starts with prefix</p> </li> <li> <p><code>substr(Str Int Int?) \u2192 Str</code> \u2014 Substring function with Perl semantics </p> <p>Offset is 0-based, negative offset counts from end; Optional length is from offset and defaults to end of string; Negative length counts from end of string</p> </li> <li> <p><code>text([Str]) \u2192 Str</code> \u2014 Join list of strings with newlines, adding a newline at the end</p> </li> <li> <p><code>trim(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/trim</code> </p> <p>Trim whitespace from both ends</p> </li> <li> <p><code>triml(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/triml</code> </p> <p>Trim whitespace from left end</p> </li> <li> <p><code>trimr(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/trimr</code> </p> <p>Trim whitespace from right end</p> </li> <li> <p><code>uc(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/upper-case</code> </p> <p>Uppercase a string</p> </li> <li> <p><code>uc1(Str) \u2192 Str</code> \u2014 Alias of <code>clojure.string/capitalize</code> </p> <p>Uppercase the first character</p> </li> <li> <p><code>words(Str) \u2192 [Str]</code> \u2014 Split a string into words (split on whitespace)</p> </li> </ul> <p>See also: https://clojuredocs.org/quickref#strings-characters\u00a0 </p>"},{"location":"doc/ys-std/#collection-functions","title":"Collection functions","text":"<ul> <li> <p><code>diff(Col Col) \u2192 [Str Str Str]</code> \u2014 Alias of <code>clojure.data/diff</code> </p> <p>Return the difference of two collections</p> </li> <li> <p><code>flat(Vec) \u2192 Vec</code> \u2014 Like <code>clojure.core/flatten</code> </p> <p>Only flattens one level</p> </li> <li> <p><code>get+(Col Key) \u2192 X</code> \u2014 Get a string, keyword or symbol from a map or sequence</p> </li> <li><code>grep(Fn Col) \u2192 Col</code> \u2014 Filter a collection by a predicate function</li> <li><code>has?(Col) \u2192 Fn</code> \u2014 Returns a partial function closed over Col</li> <li> <p><code>has?(Col X) \u2192 B</code> \u2014 True if collection has X </p> <p>Works with strings, maps and sequences</p> </li> <li> <p><code>in?(Col) \u2192 Fn</code> \u2014 Returns a partial function closed over Col</p> </li> <li> <p><code>in?(X Col) \u2192 B</code> \u2014 True if X is in collection </p> <p>Works with strings, maps and sequences</p> </li> <li> <p><code>omap([X]) \u2192 Omap</code> \u2014 Create an ordered map</p> </li> <li><code>reverse(Col) \u2192 Col</code> \u2014 Reverse a string, vector or sequence</li> <li> <p><code>rng(Int Int) \u2192 [Int]</code> \u2014 Create a range of numbers or characters, Y is inclusive</p> <p>If X is greater than Y, the range is descending</p> </li> <li> <p><code>slice(Col [Key]) \u2192 [X]</code> \u2014 Get a sequence of values from the keys</p> </li> </ul> <p>See also: https://clojuredocs.org/quickref#collections\u00a0 </p>"},{"location":"doc/ys-std/#math-functions","title":"Math functions","text":"<ul> <li><code>add(Num*) \u2192 Num</code> \u2014 Alias of <code>clojure.core/+</code> </li> <li><code>sub(Num+) \u2192 Num</code> \u2014 Alias of <code>clojure.core/-</code> </li> <li><code>mul(Num*) \u2192 Num</code> \u2014 Alias of <code>clojure.core/*</code> </li> <li><code>div(Num+) \u2192 Num</code> \u2014 Division function that returns a float if needed</li> <li> <p><code>add+(X+) \u2192 X</code> \u2014 Polymorphic addition function</p> <p>Adds numbers, strings, chars, sequences, maps, sets and functions</p> </li> <li> <p><code>sub+(X+) \u2192 X</code> \u2014 Polymorphic subtraction function</p> <p>Subtracts numbers, strings, chars, sequences, maps and sets</p> </li> <li> <p><code>mul+(X+) \u2192 X</code> \u2014 Polymorphic multiplication function</p> <p>Multiplies numbers, strings and sequences</p> </li> <li> <p><code>digits(Str) \u2192 [Int]</code> \u2014 Convert a string of digits to a sequence of numbers</p> </li> <li> <p><code>floor(Num) \u2192 Num</code> \u2014 Alias of CM/floor </p> <p>Round down to the nearest integer</p> </li> <li> <p><code>pow(Num Num+) \u2192 Num</code> \u2014 Raise a number to a power</p> </li> <li><code>sqr(Num) \u2192 Num</code> \u2014 Square a number</li> <li><code>cube(Num) \u2192 Num</code> \u2014 Cube a number</li> <li><code>sqrt(Num) \u2192 Num</code> \u2014 Square root of a number</li> <li><code>sum([Num]) \u2192 Num</code> \u2014 Sum a sequence of numbers</li> </ul> <p>See also: https://clojure.github.io/clojure/clojure.math-api.html\u00a0 </p>"},{"location":"doc/ys-std/#infix-operators","title":"Infix operators","text":"<ul> <li><code>.</code> \u2014 For chaining functions (<code>foo.bar.baz()</code>)</li> <li><code>:</code> \u2014 This <code>foo:bar</code> is same as <code>foo.bar()</code></li> <li><code>+</code> \u2014 For <code>add+</code></li> <li><code>-</code> \u2014 For <code>sub+</code></li> <li><code>*</code> \u2014 For <code>mul+</code></li> <li><code>/</code> \u2014 For <code>div</code></li> <li><code>**</code> \u2014 For <code>pow</code></li> <li><code>..</code> \u2014 For <code>rng</code></li> <li><code>=~</code> \u2014 For <code>re-find</code></li> <li><code>!~</code> \u2014 For <code>re-find + not</code></li> <li><code>==</code> \u2014 For <code>eq</code></li> <li><code>!=</code> \u2014 For <code>ne</code></li> <li><code>&gt;</code> \u2014 For <code>gt</code></li> <li><code>&gt;=</code> \u2014 For <code>ge</code></li> <li><code>&lt;</code> \u2014 For <code>lt</code></li> <li><code>&lt;=</code> \u2014 For <code>le</code></li> <li><code>&amp;&amp;</code> \u2014 For <code>and</code></li> <li><code>||</code> \u2014 For <code>or</code></li> <li><code>&amp;&amp;&amp;</code> \u2014 For <code>and?</code></li> <li><code>|||</code> \u2014 For <code>or?</code></li> </ul>"},{"location":"doc/ys-std/#chaining-short-forms","title":"Chaining short forms","text":"<ul> <li><code>value.#</code> \u2014 Short for <code>value.count()</code></li> <li><code>value.$</code> \u2014 Short for <code>value.last()</code></li> <li><code>value.++</code> \u2014 Short for <code>value.inc()</code></li> <li><code>value.--</code> \u2014 Short for <code>value.dec()</code></li> <li><code>value.?</code> \u2014 Short for <code>value.truey?()</code></li> <li><code>value.!</code> \u2014 Short for <code>value.falsey?()</code></li> <li><code>value.??</code> \u2014 Short for <code>value.boolean()</code></li> <li><code>value.!!</code> \u2014 Short for <code>value.not()</code></li> <li><code>value.@</code> \u2014 Short for `value.deref()</li> <li> <p><code>value.&gt;&gt;&gt;</code> \u2014 Short for <code>value.DBG()</code></p> <p>Print value/data to stderr and return the value unchanged</p> </li> </ul>"},{"location":"doc/ys-std/#control-functions","title":"Control functions","text":"<ul> <li> <p><code>call(Fn X*) \u2192 X</code> \u2014 Call a function or value</p> <p>Function can be a string, symbol or function</p> </li> <li> <p><code>die(Msg)</code> \u2014 Idiomatic error function</p> </li> <li><code>each(Bindings Body) \u2192 X</code> \u2014 Non-lazy <code>clojure.core/for</code> </li> <li><code>eval(Str) \u2192 X</code> \u2014 Evaluate a string as YS code</li> <li><code>exit(RC=0)</code> \u2014 Exit the program</li> <li><code>if(Cond Then Else) \u2192 X</code> \u2014 Functional if used in dot chaining</li> <li><code>sleep(Secs) \u2192 X</code> \u2014 Sleep for a number of seconds</li> <li> <p><code>value(X) \u2192 X</code> \u2014 Get var value from var, symbol or string</p> <p>Often used to convert a string to a function.</p> </li> <li> <p><code>when+(Cond Body) \u2192 X</code> \u2014 Like <code>clojure.core/when</code> </p> <p>Binds the result of the condition to the <code>_</code> symbol</p> </li> </ul> <p>See also: https://clojuredocs.org/quickref#flow-control\u00a0 </p>"},{"location":"doc/ys-std/#function-functions","title":"Function functions","text":"<ul> <li><code>defn flip(Fn) \u2192 X</code> \u2014 Flip the arguments of a function</li> </ul>"},{"location":"doc/ys-std/#regex-functions","title":"Regex functions","text":"<ul> <li><code>=~ X</code> \u2014 Infix re-find operator</li> <li><code>!~ X</code> \u2014 Infix re-find complement operator</li> </ul> <p>See also: https://clojuredocs.org/quickref#regular-expressions\u00a0 </p>"},{"location":"doc/ys-std/#io-functions","title":"I/O functions","text":"<ul> <li><code>err(Str*) \u2192 nil</code> \u2014 Print to stderr</li> <li> <p><code>out(Str*) \u2192 nil</code> \u2014 Print to stdout</p> <p>Flushes stdout after printing</p> </li> <li> <p><code>pp(X) \u2192 nil</code> \u2014 Pretty print a value</p> </li> <li> <p><code>print(Str*) \u2192 nil</code> \u2014 Print to stdout without newline</p> <p>Flushes stdout after printing</p> </li> <li> <p><code>read(path) \u2192 Str</code> \u2014 Alias of <code>clojure.core/slurp</code> </p> <p>Read a file into a string</p> </li> <li> <p><code>say(Str*) \u2192 nil</code> \u2014 Print to stdout with newline</p> </li> <li> <p><code>warn(Str*) \u2192 nil</code> \u2014 Print to stderr with newline</p> <p>Flushes stderr after printing</p> </li> <li> <p><code>write(path Str) \u2192 nil</code> \u2014 Alias of <code>clojure.core/spit</code> </p> <p>Write a string to a file</p> </li> </ul>"},{"location":"doc/ys-std/#shorter-named-alias-functions","title":"Shorter named alias functions","text":"<ul> <li><code>a(X) \u2192 X</code> \u2014 Alias of <code>clojure.core/identity</code> </li> <li><code>len(X) \u2192 Int</code> \u2014 Alias of <code>clojure.core/count</code> </li> </ul>"},{"location":"doc/ys-std/#quoting-functions","title":"Quoting functions","text":"<ul> <li><code>q(form) \u2192 X</code> \u2014 Alias of <code>clojure.core/quote</code> </li> <li><code>qr(str) \u2192 Rgx</code> \u2014 Alias of <code>clojure.core/re-pattern</code> </li> <li><code>qw(symbols) \u2192 [Str]</code> \u2014 Turn symbols into a vector of strings</li> </ul>"},{"location":"doc/ys-std/#named-function-for-infix-operators","title":"Named function for infix operators","text":"<ul> <li><code>eq</code> \u2014 Alias of <code>clojure.core/=</code> </li> <li><code>ne</code> \u2014 Alias of <code>clojure.core/not=</code> </li> <li><code>gt</code> \u2014 Alias of <code>clojure.core/&gt;</code> </li> <li><code>ge</code> \u2014 Alias of <code>clojure.core/&gt;=</code> </li> <li><code>lt</code> \u2014 Alias of <code>clojure.core/&lt;</code> </li> <li><code>le</code> \u2014 Alias of <code>clojure.core/&lt;=</code> </li> </ul>"},{"location":"doc/ys-std/#common-type-conversion-functions","title":"Common type conversion functions","text":"<ul> <li><code>to-bool(X) \u2192 B</code> \u2014 Convert X to a boolean</li> <li><code>to-char(X) \u2192 Chr</code> \u2014 Convert X to a character</li> <li><code>to-float(X) \u2192 Flt</code> \u2014 Convert X to a float</li> <li><code>to-int(X) \u2192 Int</code> \u2014 Convert X to an integer</li> <li><code>to-keyw(X) \u2192 Kwd</code> \u2014 Convert X to a keyword</li> <li><code>to-list(X) \u2192 List</code> \u2014 Convert X to a list</li> <li><code>to-map(X) \u2192 Map</code> \u2014 Convert X to a map</li> <li><code>to-num(X) \u2192 Num</code> \u2014 Convert X to a number</li> <li><code>to-omap(X) \u2192 Omap</code> \u2014 Convert X to an ordered map</li> <li><code>to-set(X) \u2192 Set</code> \u2014 Convert X to a set</li> <li><code>to-str(X) \u2192 Str</code> \u2014 Convert X to a string</li> <li> <p><code>to-type(X) \u2192 Str</code> \u2014 Convert X to a string name of its type:</p> <p><code>\"atom\"</code>, <code>\"bool\"</code>, <code>\"char\"</code>, <code>\"class\"</code>, <code>\"float\"</code>, <code>\"fun\"</code>, <code>\"int\"</code>, <code>\"keyw\"</code>, <code>\"list\"</code>, <code>\"map\"</code>, <code>\"nil\"</code>, <code>\"num\"</code>, <code>\"rgx\"</code>, <code>\"seq\"</code>, <code>\"set\"</code>, <code>\"str\"</code>, <code>\"sym\"</code>, <code>\"var\"</code>, <code>\"vec\"</code></p> </li> <li> <p><code>to-vec(X) \u2192 Vec</code> \u2014 Convert X to a vector</p> </li> </ul>"},{"location":"doc/ys-std/#single-character-casting-functions","title":"Single character casting functions","text":"<ul> <li><code>B(X)</code> \u2014 Convert to a boolean</li> <li><code>C(X)</code> \u2014 Convert to a character</li> <li><code>D(X)</code> \u2014 Deref an atom</li> <li><code>F(X)</code> \u2014 Convert to a float</li> <li><code>I(X)</code> \u2014 Convert to an integer</li> <li><code>K(X)</code> \u2014 Convert to a keyword</li> <li><code>L(X)</code> \u2014 Convert to a list</li> <li><code>M(X)</code> \u2014 Convert to a map</li> <li><code>N(X)</code> \u2014 Convert to a number</li> <li><code>O(X)</code> \u2014 Convert to an ordered map</li> <li><code>S(X)</code> \u2014 Convert to a set</li> <li><code>T(X)</code> \u2014 Convert to a type name string</li> <li><code>V(X)</code> \u2014 Convert to a vector</li> <li><code>L+(X*) \u2192 List</code> \u2014 Convert to a list</li> <li><code>M+(X*) \u2192 Map</code> \u2014 Convert to a map</li> <li><code>O+(X*) \u2192 Omap</code> \u2014 Convert to an ordered map</li> <li><code>V+(X*) \u2192 Vec</code> \u2014 Convert to a vector</li> </ul>"},{"location":"doc/ys-std/#alternate-truth-functions","title":"Alternate truth functions","text":"<ul> <li><code>falsey?(X) \u2192 X</code> \u2014 True if X is falsey - 0, nil, false, empty</li> <li><code>F?(X)</code> \u2014 Short for <code>falsey?</code></li> <li><code>truey?(X) \u2192 X</code> \u2014 True if X is not falsey</li> <li><code>T?(X)</code> \u2014 Short for <code>truey?</code></li> <li><code>or?(X X+) \u2192 X</code> \u2014 Return first truey value or nil</li> <li><code>and?(X X+) \u2192 X</code> \u2014 Return last truey value or nil</li> </ul>"},{"location":"doc/ys-std/#file-system-functions","title":"File system functions","text":"<ul> <li><code>fs-d(Path) \u2192 B</code> \u2014 True if path is a directory</li> <li><code>fs-e(Path) \u2192 B</code> \u2014 True if path exists</li> <li><code>fs-f(Path) \u2192 B</code> \u2014 True if path is a regular file</li> <li><code>fs-l(Path) \u2192 B</code> \u2014 True if path is a symbolic link</li> <li><code>fs-r(Path) \u2192 B</code> \u2014 True if path is readable</li> <li><code>fs-s(Path) \u2192 B</code> \u2014 True if path is not empty</li> <li><code>fs-w(Path) \u2192 B</code> \u2014 True if path is writable</li> <li><code>fs-x(Path) \u2192 B</code> \u2014 True if path is executable</li> <li><code>fs-z(Path) \u2192 B</code> \u2014 True if path is empty</li> <li><code>fs-abs(Path) \u2192 Path</code> \u2014 Get the absolute path</li> <li><code>fs-abs?(Path) \u2192 B</code> \u2014 True if path is absolute</li> <li><code>fs-basename(Path Ext?) \u2192 B</code> \u2014 Get the file name of a path, without extension</li> <li><code>fs-dirname(Path) \u2192 Dir</code> \u2014 Get the directory name of a path</li> <li><code>fs-filename(Path) \u2192 File</code> \u2014 Get the file name of a path</li> <li><code>fs-glob(Path) \u2192 [Path]</code> \u2014 Glob a path</li> <li><code>fs-ls(dir) \u2192 [File]</code> \u2014 List a directory</li> <li><code>fs-mtime(file) \u2192 Int</code> \u2014 Get the modification time of a file</li> <li><code>fs-rel(Path) \u2192 Path</code> \u2014 Get the relative path</li> <li><code>fs-rel?(Path) \u2192 B</code> \u2014 True if path is relative</li> <li><code>fs-which(name) \u2192 B</code> \u2014 Find the path of an executable</li> </ul> <p>See also: https://github.com/babashka/fs/blob/master/API.md\u00a0 </p>"},{"location":"doc/ys-std/#datetime-functions","title":"Date/Time functions","text":"<ul> <li><code>now() \u2192 Instant</code> \u2014 Returns <code>java.time.Instant</code> object</li> </ul>"},{"location":"doc/ys-std/#security-functions","title":"Security functions","text":"<ul> <li><code>md5(S) \u2192 X</code> \u2014 Calculate the MD5 hash of a string</li> <li><code>sha1(S) \u2192 X</code> \u2014 Calculate the SHA-1 hash of a string</li> <li><code>sha256(S) \u2192 X</code> \u2014 Calculate the SHA-256 hash of a string</li> </ul>"},{"location":"doc/ys-std/#ipc-functions","title":"IPC functions","text":"<ul> <li><code>exec(Cmd Str*) \u2192 Result</code> \u2014 Execute a command</li> <li><code>process(Cmd Str*) \u2192 Result</code> \u2014 Execute a command</li> <li><code>sh(Cmd Str*) \u2192 Result</code> \u2014 Execute a command</li> <li><code>shell(Cmd Str*) \u2192 Result</code> \u2014 Execute a command</li> <li><code>shout(Cmd Str*) \u2192 Result</code> \u2014 Execute a command and return the output</li> </ul> <p>See also: https://github.com/babashka/process#readme\u00a0 </p>"},{"location":"doc/ys-std/#external-library-functions","title":"External library functions","text":"<ul> <li><code>use-pod(pod-name version) \u2192 nil</code> \u2014 Load an external library pod</li> </ul>"},{"location":"doc/ys-std/#http-functions","title":"HTTP functions","text":"<ul> <li><code>curl(URL) \u2192 Str</code> \u2014 Get a URL and return the body</li> </ul>"},{"location":"doc/ys-std/#yaml-document-result-stashing-functions","title":"YAML document result stashing functions","text":"<ul> <li> <p><code>stream() \u2192 X</code> \u2014 Mapping of document results</p> <p>The symbol <code>_</code> at the top level compiles to <code>(stream)</code></p> </li> </ul>"},{"location":"doc/ys-std/#atom-functions","title":"Atom functions","text":"<ul> <li><code>atom() \u2192 Atom</code> \u2014 Create an atom with a nil value</li> <li><code>atom(X) \u2192 Atom</code> \u2014 Create an atom with a value X</li> <li> <p><code>reset(Atom X) \u2192 X</code> \u2014 Alias of <code>clojure.core/reset!</code> </p> <p>Set the value of an atom</p> </li> <li> <p><code>swap(Atom Fn Arg*) \u2192 X</code> \u2014 Alias of <code>clojure.core/swap!</code> </p> <p>Update the value of an atom</p> </li> </ul>"},{"location":"doc/ys-std/#special-functions","title":"Special functions","text":"<ul> <li> <p><code>source(X*) \u2192 nil</code> \u2014 Run a YS file as a Bash script</p> <p>Acts like <code>clojure.core/comment.</code>  Does nothing in YS. Intended for Bash.</p> </li> </ul>"},{"location":"doc/ys-std/#see-also","title":"See Also","text":"<ul> <li>The <code>ys::std</code> source code\u00a0 </li> <li>The <code>clojure::core</code> source code\u00a0 </li> </ul>"},{"location":"doc/ys-taptest/","title":"YS TAP Testing Library","text":"<p>This library provides an implementation of the Test Anything Protocol (TAP)\u00a0  for YS.</p> <p>It's a really clean way to write unit tests for your YS code.</p> <p>Here's an example of a simple test file (test-1.t):</p> <pre><code>#!/usr/bin/env ys-0\n\nrequire ys::taptest: test done\n\nhash1 =::\n  foo: one\n  bar: two\n\nhash2 =::\n  bar: three\n\ntest::\n- name: Test merge\n  code: hash1.merge(hash2)\n  want:\n    foo: one\n    bar: three\n\n- name: Count keys\n  code: hash1.keys().count()\n  want: 2\n\ndone: 2     # Make sure we ran 2 tests\n</code></pre> <p>We can run this test file with the common <code>prove</code> command:</p> <pre><code>$ prove -v test-1.t\ntest-1.t ..\nok 1 - Test merge\nok 2 - Count keys\n1..2\nok\nAll tests successful.\nFiles=1, Tests=2,  0 wallclock secs ( 0.01 usr  0.00 sys +  0.01 cusr  0.00 csys =  0.02 CPU)\nResult: PASS\n</code></pre> <p>Tests are defined as a simple YAML sequence of mappings, one for each test. The <code>test</code> functions takes this sequence and runs each test in order.</p> <p>TAP needs to know that all the tests you intended to run were run. You can do this by calling the <code>plan</code> function beforehand with the number of tests you intend to run, or by calling the <code>done</code> afterwards with the number of tests you intended to run. You can also call <code>done</code> with no arguments (<code>done:</code>) to indicate that all tests were run.</p>"},{"location":"doc/ys-taptest/#test-mappings","title":"Test Mappings","text":"<p>Each test mapping has certain keys that determine how the test is run.</p> <p>You must specify <code>code</code> or <code>cmnd</code> for each test. This indicates either the YS code to run or the CLI command to run.</p> <p>You must specify one of <code>want</code>, <code>like</code> or <code>have</code> for each test. This indicates how the result should be tested.</p> <p>Here are the test mapping keys you can use in a test:</p> <ul> <li> <p><code>name</code> \u2014 The name/description of the test. This is optional.</p> </li> <li> <p><code>code</code> \u2014 The YS code to run for the test.</p> </li> <li> <p><code>cmnd</code> \u2014 The CLI command to run for the test.</p> </li> <li> <p><code>want</code> \u2014 The exact expected result of the test.</p> </li> <li> <p><code>like</code> \u2014 A regex pattern that the result should match.</p> </li> <li> <p><code>have</code> \u2014 A substring that the result should contain.</p> </li> <li> <p><code>what</code> \u2014 What part of the result to test.   Can be set to <code>value</code>, <code>error</code> or <code>out</code> for <code>code</code> tests and defaults to   <code>value</code>.   Can be set to <code>out</code>, <code>err</code>, <code>exit</code> or <code>all</code> for <code>cmnd</code> tests and defaults to   <code>out</code>.   See below for more information on these <code>what</code> values.</p> </li> <li> <p><code>form</code> \u2014 A function to format the result for testing.   The function will be called with the full result data and the current test   object.</p> </li> <li> <p><code>SKIP</code> \u2014 If set to <code>true</code>, this test will be skipped.   Can be used on multiple tests.</p> </li> <li> <p><code>ONLY</code> \u2014 If set to <code>true</code> only this test will be run.   Can be used on multiple tests.</p> </li> </ul>"},{"location":"doc/ys-taptest/#the-what-values","title":"The <code>what</code> Values","text":"<ul> <li> <p><code>value</code> \u2014 Test the return value of the code.   This is the default for <code>code</code> tests.</p> </li> <li> <p><code>error</code> \u2014 Test the error message of the code.   This expects the code to throw an error.</p> </li> <li> <p><code>out</code> \u2014 Test the stdout of the command.</p> </li> <li> <p><code>err</code> \u2014 Test the stderr of the command.</p> </li> <li> <p><code>exit</code> \u2014 Test the exit code of the command.</p> </li> <li> <p><code>all</code> \u2014 An object containing <code>out</code>, <code>err</code> and <code>exit</code> values.</p> </li> </ul>"},{"location":"doc/ys-taptest/#the-ystaptest-api-functions","title":"The ys::taptest API Functions","text":"<ul> <li> <p><code>done</code> \u2014 Indicate that a certain number of tests were run.   Run this after running all tests.</p> </li> <li> <p><code>plan</code> \u2014 Plan to run a certain number of tests.   Run this before running any tests.</p> </li> <li> <p><code>test</code> \u2014 Run a sequence of tests.</p> </li> </ul>"},{"location":"doc/ys-yaml/","title":"YAML Library","text":"<ul> <li><code>load(S)</code> \u2014 Load a YAML string to a native data structure.</li> <li><code>load-all(S)</code> \u2014 Load a YAML string into a list of document nodes.</li> <li><code>dump(X)</code> \u2014 Dump a native data structure to a YAML string.</li> <li><code>dump-all(V)</code> \u2014 Dump an array of native data structures to a multi-document YAML string.</li> </ul>"},{"location":"doc/ys-ys/","title":"YS Internals Library","text":"<p>This library serves 2 purposes. It provides functions for working with YS code from within a YS program/file.</p> <p>It also provides functions that are wrappers around common Clojure functions so that they can be used in places where functions are not allowed; like in dot chaining operations.</p> <p>You can use these functions with the <code>ys/</code> (or <code>ys::ys/</code>) prefix.</p>"},{"location":"doc/ys-ys/#ys-functions","title":"YS Functions","text":"<ul> <li> <p><code>compile</code> \u2014 Compile a YS string to a Clojure string</p> </li> <li> <p><code>eval</code> \u2014 Evaluate a YS string</p> </li> <li> <p><code>load-file</code> \u2014 Load a YS file path</p> </li> <li> <p><code>load-pod</code> \u2014 Load a Babashka Pod</p> </li> <li> <p><code>unload-pods</code> \u2014 Unload all loaded pods</p> </li> <li> <p><code>use</code> \u2014 Use a YS or Clojure library found in <code>YSPATH</code>.   Normally called as <code>use</code>, not <code>ys/use</code>.</p> </li> </ul>"},{"location":"doc/ys-ys/#macro-wrapper-functions","title":"Macro Wrapper Functions","text":"<ul> <li><code>for</code> \u2014 An eager version of Clojure's lazy <code>for</code> macro</li> <li><code>if</code> \u2014 Wrapper around the Clojure <code>if</code> special form</li> <li><code>when</code> \u2014 Wrapper around the Clojure <code>when</code> macro</li> </ul>"},{"location":"doc/ys/","title":"ys - The YS CLI Tool","text":"<p>The YS <code>ys</code> command line tool is the primary way to run, load and compile YS programs.</p> <p>Note</p> <p>Loading is essentially the same as running, but the result is output is printed as JSON.</p> <p>Here's the <code>ys --help</code> output:</p> <pre><code>$ ys --help\n\nys - The YS Command Line Tool - v0.1.96\n\nUsage: ys [&lt;option...&gt;] [&lt;file&gt;]\n\nOptions:\n\n  -e, --eval YSEXPR        Evaluate a YS expression\n                             multiple -e values are joined by newline\n  -l, --load               Output the (compact) JSON of YS evaluation\n  -f, --file FILE          Explicitly indicate input file\n\n  -c, --compile            Compile YS to Clojure\n  -b, --binary             Compile to a native binary executable\n\n  -p, --print              Print the final evaluation result value\n  -o, --output FILE        Output file for --load, --compile or --binary\n  -s, --stream             Output all results from a multi-document stream\n\n  -T, --to FORMAT          Output format for --load:\n                             json, yaml, csv, tsv, edn\n  -J, --json               Output (pretty) JSON for --load\n  -Y, --yaml               Output YAML for --load\n  -U, --unordered          Mappings don't preserve key order (faster)\n\n  -m, --mode MODE          Add a mode tag: code, data, or bare (for -e)\n  -C, --clojure            Treat input as Clojure code\n\n  -d                       Debug all compilation stages\n  -D, --debug-stage STAGE  Debug a specific compilation stage:\n                             parse, compose, resolve, build,\n                             transform, construct, print\n                           can be used multiple times\n  -S, --stack-trace        Print full stack trace for errors\n  -x, --xtrace             Print each expression before evaluation\n\n      --install            Install the libyamlscript shared library\n      --upgrade            Upgrade both ys and libyamlscript\n\n      --version            Print version and exit\n  -h, --help               Print this help and exit\n</code></pre> <p>Let's start with a YAML file (<code>some.yaml</code>) that wants to use data from another YAML file and also do some simple calculations:</p> <pre><code>!YS-v0:\n\n::\n  name =: \"World\"\n  data =: load(\"data1.yaml\")\n  fruit =: data.food.fruit\n\nnum: 123\ngreet:: \"$(data.hello.rand-nth()), $name!\"\neat:: fruit.shuffle().first()\ndrink:: ([\"Bar\"] * 3).join(', ').str('!!!')\n</code></pre> <p>Here's the other YAML file (<code>data1.yaml</code>):</p> <pre><code>food:\n  fruit:\n  - apple\n  - banana\n  - cherry\n  - date\n\nhello:\n- Aloha\n- Bonjour\n- Ciao\n- Dzie\u0144 dobry\n</code></pre> <p>We can \"load\" the YAML/YS file with the <code>ys</code> command and it will print the result as JSON:</p> <pre><code>$ ys -l some.yaml \n{\"num\":123,\"greet\":\"Bonjour, World!\",\"eat\":\"apple\",\"drink\":\"Bar, Bar, Bar!!!\"}\n</code></pre> <p>We can also format the output as YAML:</p> <pre><code> ys -lY some.yaml \nnum: 123\ngreet: Ciao, World!\neat: cherry\ndrink: Bar, Bar, Bar!!!\n</code></pre> <p>Here's a tiny YS program called <code>program.ys</code>:</p> <pre><code>!YS-v0\n\ndefn main(name='world' n=3):\n  greet: name n\n\ndefn greet(name, times=1):\n  each [i (1 .. times)]:\n    say: \"$i) Hello, $name!\"\n</code></pre> <p>We can run this program with the <code>ys</code> command:</p> <pre><code>$ time ys program.ys\n1) Hello, world!\n2) Hello, world!\n3) Hello, world!\n\nreal    0m0.021s\nuser    0m0.014s\nsys 0m0.007s\n</code></pre> <p>Pretty fast, right?</p> <p>We can pass in arguments:</p> <pre><code>$ ys program.ys Bob 2\n ys program.ys Bob 2\n1) Hello, Bob!\n2) Hello, Bob!\n</code></pre> <p>To see what Clojure code is being generated under the hood:</p> <pre><code>$ ys -c program.ys\n(declare greet)\n(defn main\n  ([name n] (greet name n))\n  ([name] (main name 3))\n  ([] (main \"world\" 3)))\n(defn greet\n  ([name times] (each [i (rng 1 times)] (say (str i \") Hello, \" name \"!\"))))\n  ([name] (greet name 1)))\n(apply main ARGS)\n</code></pre> <p>You can compile the program to a native binary executable:</p> <pre><code>$ time ys -b program.ys \n* Compiling YS 'program.ys' to 'program' executable\n* Setting up build env in '/tmp/tmp.xU8K3OPymt'\n* This may take a few minutes...\n[1/8] Initializing      (2.8s @ 0.14GB)\n[2/8] Performing analysis       (9.1s @ 0.33GB)\n[3/8] Building universe     (1.2s @ 0.39GB)\n[4/8] Parsing methods       (1.4s @ 0.41GB)\n[5/8] Inlining methods      (0.9s @ 0.49GB)\n[6/8] Compiling methods     (10.6s @ 0.50GB)\n[7/8] Layouting methods     (1.0s @ 0.50GB)\n[8/8] Creating image        (1.5s @ 0.44GB)\n* Compiled YS 'program.ys' to 'program' executable\n\nreal    0m36.340s\nuser    4m34.165s\nsys 0m3.915s\n\n$ time ./program Bob 2\n1) Hello, Bob!\n2) Hello, Bob!\n\nreal    0m0.007s\nuser    0m0.003s\nsys 0m0.004s\n</code></pre> <p>As you can see, the native binary is faster than the interpreted version, but the compilation takes quite a long time.</p> <p>When debugging, you can see the output of each compilation stage by adding the <code>-d</code> option:</p> <pre><code>$ ys -cd program.ys\n*** parse output ***\n({:+ \"+MAP\", :! \"YS-v0\"}\n {:+ \"=VAL\", := \"defn main(name='world' n=3)\"}\n {:+ \"+MAP\"}\n {:+ \"=VAL\", := \"greet\"}\n {:+ \"=VAL\", := \"name n\"}\n {:+ \"-MAP\"}\n {:+ \"=VAL\", := \"defn greet(name, times=1)\"}\n {:+ \"+MAP\"}\n {:+ \"=VAL\", := \"each [i (1 .. times)]\"}\n {:+ \"+MAP\"}\n {:+ \"=VAL\", := \"say\"}\n {:+ \"=VAL\", :$ \"$i) Hello, $name!\"}\n {:+ \"-MAP\"}\n {:+ \"-MAP\"}\n {:+ \"-MAP\"}\n {:+ \"-DOC\"})\n\n*** compose output ***\n{:! \"YS-v0\",\n :%\n [{:= \"defn main(name='world' n=3)\"}\n  {:% [{:= \"greet\"} {:= \"name n\"}]}\n  {:= \"defn greet(name, times=1)\"}\n  {:%\n   [{:= \"each [i (1 .. times)]\"}\n    {:% [{:= \"say\"} {:$ \"$i) Hello, $name!\"}]}]}]}\n\n*** resolve output ***\n{:xmap\n [{:defn \"defn main(name='world' n=3)\"}\n  {:xmap [{:expr \"greet\"} {:expr \"name n\"}]}\n  {:defn \"defn greet(name, times=1)\"}\n  {:xmap\n   [{:expr \"each [i (1 .. times)]\"}\n    {:xmap [{:expr \"say\"} {:xstr \"$i) Hello, $name!\"}]}]}]}\n\n*** build output ***\n{:xmap\n [[{:Sym defn} {:Sym main} nil]\n  [{:Lst\n    [{:Vec [{:Sym name} {:Sym n}]}\n     {:xmap [{:Sym greet} [{:Sym name} {:Sym n}]]}]}\n   {:Lst\n    [{:Vec [{:Sym name}]} {:Lst [{:Sym main} {:Sym name} {:Int 3}]}]}\n   {:Lst [{:Vec []} {:Lst [{:Sym main} {:Str \"world\"} {:Int 3}]}]}]\n  [{:Sym defn} {:Sym greet} nil]\n  [{:Lst\n    [{:Vec [{:Sym name} {:Sym times}]}\n     {:xmap\n      [[{:Sym each}\n        {:Vec [{:Sym i} {:Lst [{:Sym rng} {:Int 1} {:Sym times}]}]}]\n       {:xmap\n        [{:Sym say}\n         {:Lst\n          [{:Sym str}\n           {:Sym i}\n           {:Str \") Hello, \"}\n           {:Sym name}\n           {:Str \"!\"}]}]}]}]}\n   {:Lst\n    [{:Vec [{:Sym name}]}\n     {:Lst [{:Sym greet} {:Sym name} {:Int 1}]}]}]]}\n\n*** transform output ***\n{:xmap\n [[{:Sym defn} {:Sym main} nil]\n  [{:Lst\n    [{:Vec [{:Sym name} {:Sym n}]}\n     {:xmap [{:Sym greet} [{:Sym name} {:Sym n}]]}]}\n   {:Lst\n    [{:Vec [{:Sym name}]} {:Lst [{:Sym main} {:Sym name} {:Int 3}]}]}\n   {:Lst [{:Vec []} {:Lst [{:Sym main} {:Str \"world\"} {:Int 3}]}]}]\n  [{:Sym defn} {:Sym greet} nil]\n  [{:Lst\n    [{:Vec [{:Sym name} {:Sym times}]}\n     {:xmap\n      [[{:Sym each}\n        {:Vec [{:Sym i} {:Lst [{:Sym rng} {:Int 1} {:Sym times}]}]}]\n       {:xmap\n        [{:Sym say}\n         {:Lst\n          [{:Sym str}\n           {:Sym i}\n           {:Str \") Hello, \"}\n           {:Sym name}\n           {:Str \"!\"}]}]}]}]}\n   {:Lst\n    [{:Vec [{:Sym name}]}\n     {:Lst [{:Sym greet} {:Sym name} {:Int 1}]}]}]]}\n\n*** construct output ***\n{:Top\n [{:Lst [{:Sym declare} {:Sym greet}]}\n  {:Lst\n   [{:Sym defn}\n    {:Sym main}\n    nil\n    {:Lst\n     [{:Vec [{:Sym name} {:Sym n}]}\n      {:Lst [{:Sym greet} {:Sym name} {:Sym n}]}]}\n    {:Lst\n     [{:Vec [{:Sym name}]} {:Lst [{:Sym main} {:Sym name} {:Int 3}]}]}\n    {:Lst [{:Vec []} {:Lst [{:Sym main} {:Str \"world\"} {:Int 3}]}]}]}\n  {:Lst\n   [{:Sym defn}\n    {:Sym greet}\n    nil\n    {:Lst\n     [{:Vec [{:Sym name} {:Sym times}]}\n      {:Lst\n       [{:Sym each}\n        {:Vec [{:Sym i} {:Lst [{:Sym rng} {:Int 1} {:Sym times}]}]}\n        {:Lst\n         [{:Sym say}\n          {:Lst\n           [{:Sym str}\n            {:Sym i}\n            {:Str \") Hello, \"}\n            {:Sym name}\n            {:Str \"!\"}]}]}]}]}\n    {:Lst\n     [{:Vec [{:Sym name}]}\n      {:Lst [{:Sym greet} {:Sym name} {:Int 1}]}]}]}\n  {:Lst [{:Sym +++} {:Lst [{:Sym apply} {:Sym main} {:Sym ARGS}]}]}]}\n\n*** print output ***\n\"(declare greet)(defn main  ([name n] (greet name n)) ([name] (main name 3))...\n\n(declare greet)\n(defn main\n  ([name n] (greet name n))\n  ([name] (main name 3))\n  ([] (main \"world\" 3)))\n(defn greet\n  ([name times] (each [i (rng 1 times)] (say (str i \") Hello, \" name \"!\"))))\n  ([name] (greet name 1)))\n(+++ (apply main ARGS))\n</code></pre>"},{"location":"doc/ys4yaml/","title":"Extend Your YAML","text":"<p>If you want to use YS to get more out of your YAML files, this page is a good place to start.</p> <p>We'll cover the most common ways to use YS in YAML files without diving into all the YS details first.</p>"},{"location":"doc/ys4yaml/#turn-on-the-ys","title":"Turn On the YS!","text":"<p>It's an extremely good chance that your YAML files are already valid YAML.</p> <p>To find out, run a command like this:</p> <pre><code>$ ys -J your-file.yaml\n</code></pre> <p>If the output is your data converted to JSON, then you're good to go!</p> <p>To turn on YS functional capabilities, just add a <code>!YS-v0:</code> line to the top of your YAML file.</p> <p>Try running that command again. The output should be exactly the same as before.</p> <p>You've turned on YS but you haven't used it yet!</p>"},{"location":"doc/ys4yaml/#string-interpolation","title":"String Interpolation","text":"<p>YS supports the interpolation (expansion) of variables and expressions in double-quoted and literal YAML scalars (strings).</p> <p>First we need some variables to interpolate. We'll show how to define variables shortly, but for now we'll just use some of the global variables that are built into YS.</p> <p>The <code>ENV</code> variable is a great place to start, because it contains a map of your current environment variables. For instance you can access your <code>USER</code> variable with <code>ENV.USER</code>. Also let's use the <code>VERSION</code> variable, which contains the current YS version.</p> <p>Here's an example of string interpolation: <pre><code>!YS-v0:\nfoo: bar   # Normal YAML data\ngreeting: |\n  My name is $(ENV.USER).\n  I'm using YS $VERSION!\nbar: baz\n</code></pre></p> <p>Lets see load this file to YAML with the <code>ys</code> command: <pre><code>$ ys -Y file.yaml\nfoo: bar\ngreeting: |\n  My name is $(ENV.USER).\n  I'm using YS $VERSION!\nbar: baz\n</code></pre></p> <p>Well that's not what we expected. No interpolation happened!</p> <p>In order for the YS YAML loader to see a particular YAML node as YS code, we need to flip that node to code mode. YS makes this easy. Just change the <code>:</code> before that particuar node to <code>::</code>.</p> <pre><code>!YS-v0:\nfoo: bar   # Normal YAML data\ngreeting:: |\n  My name is $(ENV.USER).\n  I'm using YS $VERSION!\nbar: baz\n</code></pre> <p>And now we get the expected output: <pre><code>$ ys -Y file.yaml\nfoo: bar\ngreeting: |\n  My name is ingy.\n  I'm using YS 0.1.91!\nbar: baz\n</code></pre></p> <p>YS has 3 different ways to interpolate in strings:</p> <ul> <li>Expand variables: <code>\"I am $name.\"</code><ul> <li>Put a <code>$</code> in front of a variable name.</li> </ul> </li> <li>Expand expressions: <code>\"In reverse I'm $(name:reverse).\"</code><ul> <li>Put a <code>$()</code> around an expression.</li> </ul> </li> <li>Separate variable from text: <code>\"${name}ami!\"</code><ul> <li>Put a <code>${}</code> around a variable name when it is followed by alphanumeric   characters.</li> </ul> </li> </ul>"},{"location":"use/","title":"YS Use Cases","text":"<p>The primary goal of the YS project is to make YAML be able to do more.</p> <p>While the original goal of YAML was to be a human readable data serialization language, YAML has found its place in the world primarily as a software configuration language.</p> <p>YS has a strong focus on making YAML as good as possible for configuration. That said, YS is a complete, general purpose, functional programming language, that builds on top of the success of YAML, JSON, Clojure, Java and other technologies. It embeds perfectly into your YAML files, enabling almost any need you might have there, but it it also stands on its own in many other contexts.</p> <p>Check back here for more use cases as we add them.</p> <p>We hope you will find lots of excellent uses for YS. If you discover use cases that we haven't thought of, please let us know! We'll showcase them here.</p>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/archive/2023/","title":"2023","text":""},{"location":"blog/category/summer-of-ys/","title":"Summer-of-YS","text":""},{"location":"blog/category/general/","title":"General","text":""},{"location":"blog/category/advent-2023/","title":"Advent-2023","text":""},{"location":"blog/page/2/","title":"Index","text":""}]}